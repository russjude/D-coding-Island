================================================================
RepopackPy Output File
================================================================

This file was generated by RepopackPy on: 2024-11-11T21:58:54.918824

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and RepopackPy's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

For more information about RepopackPy, visit: https://github.com/abinthomasonline/repopack-py

================================================================
Repository Structure
================================================================
Archive/
  Platformer_project/
    components/
      __pycache__/
        __init__.cpython-312.pyc
        button.cpython-312.pyc
        enemy.cpython-312.pyc
        objects.cpython-312.pyc
        platform.cpython-312.pyc
        player.cpython-312.pyc
        world.cpython-312.pyc
      __init__.py
      button.py
      enemy.py
      health.py
      objects.py
      platform.py
      player.py
      world.py
    utils/
      __pycache__/
        __init__.cpython-312.pyc
        helpers.cpython-312.pyc
      __init__.py
      helpers.py
    main.py
  Reference Pickle/
    level0_data
    level1_data
    level2_data
    level3_data
    level4_data
    level5_data
    level6_data
    level7_data
    level_times.txt
  __pycache__/
    FINAL_GAME.cpython-312.pyc
    FINAL_GAME1.cpython-312.pyc
  A1main.py
  AAAAMain.py
  AAMain.py
  FINAL_GAME.py
  FINAL_GAME1.py
  FINAL_GAME2.py
  NEW_Level_Data.py
  Platformer.zip
  Wordle.py
  player.py
  settings.py
Audio/
  Louie Zong - BOSS RUSH/
    Louie Zong - BOSS RUSH - 01 Harvest Tyrant- ORCHARD OGRE.mp3
    Louie Zong - BOSS RUSH - 02 Porcine Pilot- HOGWYLLD.mp3
    Louie Zong - BOSS RUSH - 03 Maladaptive Mallard- KWACKPOT.mp3
    Louie Zong - BOSS RUSH - 04 Corrupted Comrade- CITRUS KNIGHT.mp3
    Louie Zong - BOSS RUSH - 05 ______REST ZONE______.mp3
    Louie Zong - BOSS RUSH - 06 Mini Boss- MINNIE BUS.mp3
    Louie Zong - BOSS RUSH - 07 Digital Goblin- LAN GNOME.mp3
    Louie Zong - BOSS RUSH - 08 Stone Fruit Sages- PEACH & NECTARINE.mp3
    Louie Zong - BOSS RUSH - 09 VOID MOTHER.mp3
    Louie Zong - BOSS RUSH - 10 Thank You For Playing.mp3
    cover.jpg
  BACKGROUND_MUSIC.mp3
  SOUND_EFFECT.MP3
  Shining Sound Effect.mp3
  TRANSITIONS.MP3
  heartbeat-02-225103.mp3
DCI_Scenes/
  Sound_Effects/
    Scene1.mp3
    Scene10.mp3
    Scene11.mp3
    Scene12.mp3
    Scene13.mp3
    Scene14.mp3
    Scene15.mp3
    Scene16.mp3
    Scene17.mp3
    Scene18.mp3
    Scene19.mp3
    Scene2.mp3
    Scene3.mp3
    Scene4.mp3
    Scene5.mp3
    Scene6.mp3
    Scene7.mp3
    Scene8.mp3
    Scene9.mp3
  Scene1.png
  Scene10.png
  Scene11.png
  Scene12.png
  Scene13.png
  Scene14.png
  Scene15.png
  Scene16.png
  Scene17.png
  Scene18.png
  Scene19.png
  Scene2.png
  Scene3.png
  Scene4.png
  Scene5.png
  Scene6.png
  Scene7.png
  Scene8.png
  Scene9.png
Graphics/
  CREDITS BUTTON (1).png
  CREDITS BUTTON.mp4
  CREDITS BUTTON.png
  Forest3.png
  Geoffrey.png
  Jacobo.png
  Jessi.png
  LOGO.png
  MAINMENU VIDEO.mp4
  PLAY BUTTON (1).png
  PLAY BUTTON.mp4
  PLAY BUTTON.png
  Palak.png
  QUIT BUTTON (1).png
  QUIT BUTTON.mp4
  QUIT BUTTON.png
  Russel.png
  SPLASH VIDEO.mp4
  bg.png
  jessbackground.png
  mountainbg.png
  origbig.png
Level Data/
  Dialouge/
    Forest3.png
    Geoffrey.png
    Jacobo.png
    Jessi.png
    Palak.png
    Russel.png
    bg.png
    jessbackground.png
    mountainbg.png
    origbig.png
  Level Image/
    LEVEL0.png
    LEVEL1.png
    LEVEL2.png
    LEVEL2GAME!.png
    LEVEL3.png
    LEVEL3GAME!!.png
    LEVEL4.png
    LEVEL5.png
    Level0_Background.mp4
    Level1_Background.mp4
    Level1_Background2.mp4
    Level2_Background.mp4
    Level3_Background.mp4
    Level4_Background.mp4
  LEVEL0.py
  LEVEL1.py
  LEVEL2.py
  LEVEL3.py
  LEVEL4.py
  LEVEL5.py
Minigame1/
  Palak minigame img/
    1-unscreen.gif
    2-unscreen.gif
    3-unscreen.gif
    4-unscreen.gif
    5-unscreen.gif
    6-unscreen.gif
    7-unscreen.gif
    8-unscreen.gif
    9-unscreen.gif
    PRESSSTART2P.ttf
    Palak Minigame.png
  bg.png
  clickanywhere.png
  correct.png
  firstmove.png
  incorrect.png
  tie.png
  typeanswer.png
  youlose.png
  youwin.png
Minigame2/
  PRESSSTART2P.ttf
  Palak Minigame (7).png
  Russ Instructions.gif
  Russ Lost.gif
  Russ Short.gif
  Russ Time.gif
  Russ Welcome.gif
  Russ Won.gif
Minigame3/
  Music/
    BACKGROUND_MUSIC.mp3
    CLICK_SOUNDEFFECT.mp3
  SCORE/
    ONE.png
    OPPONENT.png
    OPPONENT2.png
    PLAYER.png
    PLAYER2.png
    PLAYER3.png
    ROUND.png
    ROUND_1OF5.png
    ROUND_2OF5.png
    ROUND_3OF5.png
    ROUND_4OF5.png
    ROUND_5OF5.png
    SCORE.png
    THREE.png
    TWO.png
  BACKGROUND_IMAGE.png
  BACKGROUND_IMAGE_1.png
  BACKGROUND_MUSIC.mp3
  CLICK_SOUNDEFFECT.mp3
  COLORED_STAR.png
  EMPTY_STAR.png
  GLOWING_HUMAN_PAPER.png
  GLOWING_HUMAN_ROCK.png
  GLOWING_HUMAN_SCISSORS.png
  HUMAN_PAPER.png
  HUMAN_ROCK.png
  HUMAN_SCISSORS.png
  OPPONENT_PAPER.png
  OPPONENT_ROCK.png
  OPPONENT_SCISSORS.png
Minigame4/
  Jess 3Initial.gif
  Jess 6Initial.gif
  Jess Decode.gif
  Jess Instructions.gif
  Jess Lost.gif
  Jess Time.gif
  Jess Welcome.gif
  Jess Win.gif
  Jessica Background.png
  PRESSSTART2P.ttf
  Python_1.png
  Python_2.png
  Python_3.png
  Python_4.png
  Python_5.png
  Python_6.png
  Python_7.png
  Python_8.png
  Python_9.png
  complete_python.png
  initial_tile_1.png
  initial_tile_2.png
  initial_tile_3.png
  initial_tile_4.png
  initial_tile_5.png
  initial_tile_6.png
  initial_tile_7.png
  initial_tile_8.png
  initial_tile_9.png
  jessbackground.png
Minigame5/
  Jacobo Background.png
  Jacobo Fast.gif
  Jacobo Inst1.gif
  Jacobo Inst2.gif
  Jacobo Lost.gif
  Jacobo Slow.gif
  Jacobo Win.gif
  PRESSSTART2P.ttf
  hero.png
  jacobo.png
  jessbackground.png
__pycache__/
  AAMain.cpython-312.pyc
  FINAL_GAME.cpython-312.pyc
  FINAL_GAME1.cpython-312.pyc
  FINAL_GAME2.cpython-312.pyc
  Level_Data.cpython-312.pyc
  MAINMENU.cpython-312.pyc
  Wordle.cpython-312.pyc
  dialogue_system.cpython-312.pyc
  mini_game1.cpython-312.pyc
  mini_game2.cpython-312.pyc
  mini_game3.cpython-312.pyc
  player.cpython-312.pyc
  settings.cpython-312.pyc
  tiles.cpython-312.pyc
  world.cpython-312.pyc
img/
  AnimatedKey_1.png
  AnimatedKey_10.png
  AnimatedKey_11.png
  AnimatedKey_12.png
  AnimatedKey_2.png
  AnimatedKey_3.png
  AnimatedKey_4.png
  AnimatedKey_5.png
  AnimatedKey_6.png
  AnimatedKey_7.png
  AnimatedKey_8.png
  AnimatedKey_9.png
  Background Music.MP3
  Background.png
  Character Walking.MP3
  Gust of Wind.MP3
  Jungle Chase - Action Tribal Drums | Upbeat Percussion Royalty Free Music for Trailers and Films.mp3
  Mage_boss.png
  MainC1.png
  MainC2.png
  MainC3.png
  MainC4.png
  SGhost.png
  Skeleton.png
  WGhost.png
  Zombie.png
  blob.png
  clock.png
  closed door.png
  closed_portal.png
  closeddoor.PNG
  coin.png
  coin.wav
  dino1.png
  dino2.png
  dino3.png
  dino4.png
  dirt.png
  dirt_block.png
  door_sound.MP3
  electric_zap.MP3
  exit.png
  exit_btn.png
  falling_character.MP3
  game_over.wav
  ghost.png
  grass.png
  grass_block.png
  grass_plat.png
  guy1.png
  guy2.png
  guy3.png
  guy4.png
  jump.wav
  key-white.gif
  key.png
  key_collect.MP3
  key_icon.png
  ladder.png
  lava.png
  left_dirt_block.png
  load_btn.png
  music.wav
  opendoor_img.png
  platform.png
  platform_x.png
  platform_y.png
  portal_frame_1.png
  portal_frame_2.png
  portal_frame_3.png
  portal_frame_4.png
  portal_frame_5.png
  restart_btn.png
  right_dirt_block.png
  save_btn.png
  sky.png
  start_btn.png
  sun.png
  trophy.png
  zoom_out.MP3
modules/
  __pycache__/
    __init__.cpython-312.pyc
    entities.cpython-312.pyc
    player.cpython-312.pyc
    utils.cpython-312.pyc
    world.cpython-312.pyc
  __init__.py
  entities.py
  player.py
  utils.py
  world.py
FINAL_GAME3.py
Level_Data.py
MAINMENU.py
PLATFORMER.py
README.md
Untitled-1.py
mini_game1.py
mini_game2.py
mini_game3.py
mini_game4.py
mini_game5.py
no_minigame.py
output.zip

================================================================
Repository Files
================================================================

================
File: MAINMENU.py
================
import pygame
import cv2
from pygame.locals import *
from pygame import mixer
import os
import git
from threading import Thread
from queue import Queue
import time

# Initialize Pygame
pygame.init()
pygame.mixer.init()

# Load Soundtrack
background_music = pygame.mixer.music.load("Audio/BACKGROUND_MUSIC.mp3")
sound_effect = pygame.mixer.Sound("Audio/SOUND_EFFECT.MP3")
sound_effect_channel = pygame.mixer.Channel(1)
sound_effect_channel.set_endevent(pygame.USEREVENT + 1)  # Set endevent for the sound channel

# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Set the desired resolution
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Decoding Island')

# Define tile size based on background height
TILE_SIZE = SCREEN_HEIGHT // 36  # 36 is the number of tiles vertically
GRAVITY = 0.79
JUMP_SPEED = -15
MOVE_SPEED = 7
game_over = 0
current_level = 0  # 0 for start screen, 1-5 for levels
keys_collected = 0
game_start_time = None
level_times = []
dialogue_states = {}

# Load and scale the background for each level
level_backgrounds = {}
for i in range(1, 6):  # Assuming you have 5 levels
    original_bg = pygame.image.load(f'Level Data/Level Image/LEVEL{i}.png')
    level_backgrounds[i] = pygame.transform.scale(original_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))

# You may need to adjust other elements (buttons, player size, etc.) to fit the new resolution
# For example:
# start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
# restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Decoding Island')

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Decoding Island')

# Define tile size based on background height
TILE_SIZE = SCREEN_HEIGHT // 36  # 36 is the number of tiles vertically

pygame.display.set_caption('Game Menu')

def display_video():
    while True:
        ret, frame = cap.read()
        if not ret:
            cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
            continue

        # Convert the frame to Pygame format and display it
        frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        frame = pygame.surfarray.make_surface(frame)
        frame = pygame.transform.scale(frame, (SCREEN_WIDTH, SCREEN_HEIGHT))
        screen.blit(frame, (0, 0))
        pygame.display.flip()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                cap.release()
                pygame.quit()
                return

class VideoPlayer:
    def __init__(self, video_path, buffer_size=100, speed_multiplier=2):
        self.cap = cv2.VideoCapture(video_path)
        self.frame_buffer = Queue(maxsize=buffer_size)
        self.current_frame = None
        self.buffer_size = buffer_size
        self.running = True
        self.speed_multiplier = speed_multiplier
        
        original_fps = self.cap.get(cv2.CAP_PROP_FPS)
        self.target_frame_time = (1.0 / original_fps) / self.speed_multiplier
        self.last_frame_time = time.time()
        
        self.load_thread = Thread(target=self._load_frames, daemon=True)
        self.load_thread.start()
    
    def _load_frames(self):
        while self.running:
            if self.frame_buffer.qsize() < self.buffer_size:
                ret, frame = self.cap.read()
                if not ret:
                    self.cap.set(cv2.CAP_PROP_POS_FRAMES, 0)
                    continue
                
                frame = cv2.rotate(frame, cv2.ROTATE_90_CLOCKWISE)
                frame = cv2.flip(frame, 1)
                frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                frame = pygame.surfarray.make_surface(frame)
                frame = pygame.transform.scale(frame, (SCREEN_WIDTH, SCREEN_HEIGHT))
                
                self.frame_buffer.put(frame)
            else:
                time.sleep(0.001)
    
    def get_frame(self):
        current_time = time.time()
        elapsed = current_time - self.last_frame_time
        
        if elapsed >= self.target_frame_time and not self.frame_buffer.empty():
            self.current_frame = self.frame_buffer.get()
            self.last_frame_time = current_time
            
        return self.current_frame
    
    def cleanup(self):
        self.running = False
        self.load_thread.join(timeout=1.0)
        if self.cap is not None:
            self.cap.release()

# Update the SplashScreen class to handle missing files more gracefully:
class SplashScreen:
    def __init__(self, video_path):
        self.video_player = VideoPlayer(video_path)
        self.font = pygame.font.Font(None, 50)
        self.text = self.font.render("Click to continue...", True, (255, 255, 255))
        self.text_rect = self.text.get_rect(center=(SCREEN_WIDTH/2, SCREEN_HEIGHT - 100))
        
    def run(self):
        waiting = True
        while waiting:
            current_frame = self.video_player.get_frame()
            if current_frame:
                screen.blit(current_frame, (0, 0))
                screen.blit(self.text, self.text_rect)
                pygame.display.flip()

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    return False
                
                # Handle both mouse clicks and key presses
                if event.type == pygame.MOUSEBUTTONDOWN or (event.type == pygame.KEYDOWN and event.key != pygame.K_ESCAPE):
                    try:
                        sound_effect_channel.play(sound_effect, loops=-1)
                        pygame.mixer.music.play(-1)
                    except (pygame.error, AttributeError):
                        print("Warning: Could not play sound effects")
                    waiting = False
                    return True
                
                if event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE:
                    return False
                
                if event.type == pygame.USEREVENT + 1:
                    try:
                        sound_effect_channel.play(sound_effect, loops=-1)
                    except (pygame.error, AttributeError):
                        pass

        self.video_player.cleanup()
        return True

class MenuButton:
    def __init__(self, x, y, video_path=None, text=None, font_size=60, scale=0.7, speed_multiplier=0.5):
        self.using_video = video_path is not None
        self.rect = pygame.Rect(x, y, int(200 * scale), int(50 * scale))  # Placeholder for rect

        if self.using_video:
            self.video_player = VideoPlayer(video_path, speed_multiplier=speed_multiplier)
            # Set rect size based on video dimensions
            self.rect = pygame.Rect(x, y, int(self.video_player.cap.get(cv2.CAP_PROP_FRAME_WIDTH) * scale),
                                    int(self.video_player.cap.get(cv2.CAP_PROP_FRAME_HEIGHT) * scale))
        else:
            self.text = text
            self.font = pygame.font.Font(None, font_size)
            self.color = (200, 200, 200)
            self.hover_color = (255, 255, 255)
            self.text_color = (0, 0, 0)
        
        self.is_hovered = False
        self.clicked = False
    
    def handle_event(self, event):
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        
        if event.type == pygame.MOUSEBUTTONDOWN:
            if self.is_hovered and not self.clicked:
                self.clicked = True
                return True
                
        if event.type == pygame.MOUSEBUTTONUP:
            self.clicked = False
            
        return False
    
    def draw(self, surface):
        if self.using_video:
            frame = self.video_player.get_frame()
            if frame:
                # Scale video frame to button size
                scaled_frame = pygame.transform.scale(frame, self.rect.size)
                surface.blit(scaled_frame, self.rect.topleft)
        else:
            color = self.hover_color if self.is_hovered else self.color
            pygame.draw.rect(surface, color, self.rect, border_radius=12)
            text_surface = self.font.render(self.text, True, self.text_color)
            text_rect = text_surface.get_rect(center=self.rect.center)
            surface.blit(text_surface, text_rect)

class MainMenu:
    def __init__(self):
        self.video_player = VideoPlayer('Graphics/MAINMENU VIDEO.mp4')
        
        # Load and scale logo
        self.logo = pygame.image.load('Graphics/LOGO.png')
        logo_width = int(SCREEN_WIDTH * 0.6)  # Make logo 60% of screen width
        logo_height = int(logo_width * (634/1037))  # Maintain aspect ratio
        self.logo = pygame.transform.scale(self.logo, (logo_width, logo_height))
        self.logo_rect = self.logo.get_rect()
        self.logo_rect.centerx = SCREEN_WIDTH // 2
        
        # Increase logo's y position (adjust the 0.25 value to move it up or down)
        self.logo_rect.top = SCREEN_HEIGHT * 0.04  # Increased from 0.1 to 0.25
        
        # Calculate button positions and size
        button_spacing = int(SCREEN_HEIGHT * 0.01)  # Spacing between buttons
        
        # Decrease the space between logo and buttons (adjust the 0.05 value to change the gap)
        button_start_y = self.logo_rect.bottom + int(SCREEN_HEIGHT * 0.01)  # Decreased from 0.15 to 0.05
        
        # Smaller scale factor for buttons
        button_scale = (SCREEN_HEIGHT / 1440) * 0.25  # Adjust scale factor as needed
        
        # Create centered buttons
        self.buttons = {}
        button_paths = {
            'play': 'Graphics/PLAY BUTTON.mp4',
            'credits': 'Graphics/CREDITS BUTTON.mp4',
            'quit': 'Graphics/QUIT BUTTON.mp4'
        }
        
        for i, (button_name, video_path) in enumerate(button_paths.items()):
            # Create a temporary VideoPlayer to get the button dimensions
            temp_player = VideoPlayer(video_path)
            button_width = int(temp_player.cap.get(cv2.CAP_PROP_FRAME_WIDTH) * button_scale)
            button_height = int(temp_player.cap.get(cv2.CAP_PROP_FRAME_HEIGHT) * button_scale)
            temp_player.cleanup()
            
            # Calculate the centered x position for each button
            button_x = (SCREEN_WIDTH - button_width) // 2
            
            # Add vertical spacing between buttons
            button_y = button_start_y + (i * (button_height + button_spacing))
            
            self.buttons[button_name] = MenuButton(
                button_x, button_y,
                video_path=video_path,
                scale=button_scale,
                speed_multiplier=1.5
            )

    def run(self):
        clock = pygame.time.Clock()
        running = True

        while running:
            current_frame = self.video_player.get_frame()
            if current_frame:
                screen.blit(current_frame, (0, 0))
            
            screen.blit(self.logo, self.logo_rect)

            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    return "quit"
                if event.type == pygame.KEYDOWN:
                    if event.key == pygame.K_ESCAPE:
                        return "quit"
                    elif event.key == pygame.K_F11:
                        toggle_fullscreen()

                for button_name, button in self.buttons.items():
                    if button.handle_event(event):
                        return button_name

            for button in self.buttons.values():
                button.draw(screen)

            pygame.display.flip()
            clock.tick(24)  # Reduce the frame rate
        
        self.video_player.cleanup()

def toggle_fullscreen():
    global screen, fullscreen
    fullscreen = not fullscreen
    if fullscreen:
        screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.FULLSCREEN)
    else:
        screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))

def switch_branch(MINI_GAME):
    repo = git.Repo(os.getcwd())
    if repo.active_branch.name != MINI_GAME:
        repo.git.checkout(MINI_GAME)
        print(f"Switched to branch '{MINI_GAME}'")

# Update the main function
def main():
    pygame.init()
    mixer.init()

    # Initialize audio channels if not already initialized
    if pygame.mixer.get_num_channels() < 2:
        pygame.mixer.set_num_channels(2)

    # Load and play the music during the splash screen
    splash = SplashScreen("Graphics/SPLASH VIDEO.mp4")
    try:
        mixer.music.load("Audio/Shining Sound Effect.mp3")
        mixer.music.play(1)  # Play once (1)
    except pygame.error:
        print("Warning: Could not load splash screen music")

    # Run the splash screen and stop if it doesn't complete
    if not splash.run():
        pygame.quit()
        return

    # Stop the music before the main menu opens
    mixer.music.stop()

    try:
        # Load menu background music
        mixer.music.load("Audio/BACKGROUND_MUSIC.mp3")
    except pygame.error:
        print("Warning: Could not load menu background music")

    # Initialize and run the main menu
    menu = MainMenu()
    
    while True:
        action = menu.run()
        
        if action == "quit":
            break
        elif action == "credits":
            try:
                import CREDITS
                print("Opened credits...")
            except ImportError:
                print("Could not load CREDITS module")
        elif action == "play":
            try:
                import Archive.FINAL_GAME2 as FINAL_GAME2
                print("Starting mini-game...")
            except ImportError:
                print("Could not load MINI_GAME module")
    
    pygame.quit()

# Run the main function
if __name__ == "__main__":
    main()

================
File: PLATFORMER.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os
import time
import cv2
import numpy as np
import math
from datetime import datetime, timedelta
import subprocess
import sys


def load_minigame(level):
    """Load a minigame module when needed"""
    try:
        if level == 1:
            from mini_game1 import main  # Change to your actual game file/function
            return main()
        elif level == 2:
            from mini_game2 import main  # Change to your actual game file/function
            return main()
        elif level == 3:
            from mini_game3 import main  # Change to your actual game file/function
            return main()
        elif level == 4:
            from mini_game4 import main  # Change to your actual game file/function
            return main()
        elif level == 5:
            from mini_game5 import main  # Change to your actual game file/function
            return main()
    except ImportError as e:
        print(f"Warning: Could not load minigame {level}: {e}")
        return False
    return False


# Initialize Pygame and mixer first
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Set up display and constants
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940
BASE_WIDTH = 1539
BASE_HEIGHT = 940
SCALE_X = 1.0
SCALE_Y = 1.0
FULLSCREEN = False

# Set up the display
# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'
# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Decoding Island')

# Update these constants at the top of your file
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.40  # Reduced from 0.45
JUMP_SPEED = -11  # Reduced from -13
MOVE_SPEED = 6  # Reduced from 5
game_over = 0
current_level = 0  # 0 for start screen, 1-5 for levels
keys_collected = 0
game_start_time = None
level_times = []
dialogue_states = {}

# Add these with other global variables
paused = False
pause_start_time = None
total_pause_time = timedelta(0)
fade_alpha = 0
fade_target = 180
fade_speed = 15


# You may need to adjust other elements (buttons, player size, etc.) to fit the new resolution
# For example:
# start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
# restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Define colors
WHITE = (255, 255, 255)
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)

# Load images
start_bg = pygame.image.load('img/background.png')
start_bg = pygame.transform.scale(start_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
start_btn = pygame.image.load('img/start_btn.png')
restart_img = pygame.image.load('img/restart_btn.png')
closeddoor_img = pygame.image.load('img/closeddoor.PNG')
opendoor_img = pygame.image.load('img/opendoor_img.PNG')
key_img = pygame.image.load('img/key.png')
npc_img = pygame.image.load('img/Wghost.png')
key_frames = []
target_size = (25, 25)  # Your desired size

# Append Keys
for i in range(1, 13):
    image = pygame.image.load(f'img/AnimatedKey_{i}.png')
    scaled_image = pygame.transform.scale(image, target_size)
    key_frames.append(scaled_image)

# Scale images
closeddoor_img = pygame.transform.scale(closeddoor_img, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
key_img = pygame.transform.scale(key_img, (10, 25 ))
npc_img = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2)))

# Load sounds
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

FULLSCREEN = False  # Track fullscreen state

def update_scale_factors():
    """Update scale factors based on current screen size"""
    global SCALE_X, SCALE_Y
    current_size = pygame.display.get_surface().get_size()
    SCALE_X = current_size[0] / BASE_WIDTH
    SCALE_Y = current_size[1] / BASE_HEIGHT

def toggle_fullscreen():
    """Toggle between fullscreen and windowed mode"""
    global FULLSCREEN, screen, SCREEN_WIDTH, SCREEN_HEIGHT
    FULLSCREEN = not FULLSCREEN
    
    if FULLSCREEN:
        # Get monitor resolution
        info = pygame.display.Info()
        # Calculate aspect ratio preserved resolution
        target_ratio = BASE_WIDTH / BASE_HEIGHT
        monitor_ratio = info.current_w / info.current_h
        
        if monitor_ratio > target_ratio:
            # Monitor is wider than our target ratio
            SCREEN_HEIGHT = info.current_h
            SCREEN_WIDTH = int(SCREEN_HEIGHT * target_ratio)
        else:
            # Monitor is taller than our target ratio
            SCREEN_WIDTH = info.current_w
            SCREEN_HEIGHT = int(SCREEN_WIDTH / target_ratio)
            
        screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.FULLSCREEN)
    else:
        SCREEN_WIDTH = BASE_WIDTH
        SCREEN_HEIGHT = BASE_HEIGHT
        screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    
    # Update scale factors after changing resolution
    update_scale_factors()

# Level platform data (you'll need to adjust these coordinates based on your level designs)
LEVEL_PLATFORM_DATA = {
    0: [
            # Top platforms
            (5.2, 13.4, 6, 2.5),    
            (48, 13.4, 6, 2.5),   

            # small-top platform
            (13.3, 15.5, 1.4, 1.0), 
            (44.4, 15.5, 1.6, 1.0), 
            
            # semi-top platform
            (16.7, 16.6, 4.5, 1.0), 
            (38, 16.6, 4.5, 1.0), 

            # Middle platform
            (26.5, 18.3, 6.2, 2.5),  
            
            # Lower platforms
            (34.6, 23.2, 4.8, 2.5),
            (19.9, 23.2, 4.7, 2.5),
            
            # Bottom platforms
            (11.8, 28, 6.2, 2.5),
            (26.6, 28, 6.2, 2.5),
            (41.3, 28, 8, 1.),
            
            # Ground level
            (0, 33, 8, 3.0),
            (51, 33, 8.2, 3.0),
    ],
    1: [
            # 5th layer
            (23.1, 8.4, 4.8, 1.4),
            (44.5, 8.4, 4.8, 1.4),
            (15, 5.1, 6.2, 3),
            (0, 6.8, 9.8, 1.3),

            # 4th layer
            (28.1, 11.7, 6.4, 3),
            (51.2, 11.7, 6.3, 3),

            # 3rd layer
            (24.8, 15.5, 1.4, 1.7),
            (36.3, 16.6, 4.8, 1.3),
            (44.5, 16.6, 4.8, 1.3),

            # 2nd layer
            (51.1, 21.5, 6.4, 3),
            (36.3, 23.2, 6.4, 1),
            (18.3, 19.9, 9.6, 3),
            (31.3, 19.9, 3.3, 1.4),

            # Ground level
            (44.6, 26.4, 6.4, 3),
            (33, 29.7, 9.7, 3),
            (16.6, 28.1, 4.8, 1.4),
            (16.6, 34.7, 16, 12),

            # Ground Pillars
            (11.7, 23.2, 3.1, 12),
            (6.7, 26.4, 3.1, 9),
            (1.7, 29.8, 3.1, 6)
    ],
    2: [
            # 7th layer
            (13.5, 2, 7.6, 4),
            (10.1, 3.7, 3, 1),
            (0.3, 3.7, 4.6, 1),
            (5.2, 5.3, 1.3, 1),

            # 6th layer
            (51.3, 10.2, 7.5, 5.7),
            (5.2, 8.6, 4.6, 1),

            # 5th layer
            (43, 11.9, 6.3, 1),
            (11.8, 13.5, 4.6, 1),
            (0.2, 13.5, 4.6, 1),

            # 4th layer
            (31.7, 18.1, 1.8, 1.3),
            (42.3, 18.1, 1.8, 1.3),
            (33.3, 15.2, 9.2, 4),
            (0, 18.4, 9.5, 2.5),

            # 3rd layer
            (47.9, 20, 4.7, 1),
            (29.85, 20, 1.3, 1),
            (13.6, 21.7, 6, 1),
            (9.9, 20.1, 1.4, 1),

            # 2nd layer
            (48, 26.7, 6.2, 1),
            (41.4, 23.4, 4.6, 1),
            (26.7, 23.4, 7.6, 2.5),
            (7, 25, 14, 5),

            # Ground level
            (0.5, 28.4, 6.6, 8.0),
            (21, 28.4, 6.7, 8.0),
            (43.2, 31.7, 27, 5.0),

            # Ground Pillars
            (39.8, 31.7, 1.2, 3),
            (34.8, 31.7, 1.2, 3),
            (29.9, 31.7, 1.2, 3)
    ],
    3: [
            # 6th layer
            (3.5, 7, 6.2, 1),
            (0.3, 2, 4.3, 2.5),
            (20, 8.5, 3, 1),
            (46.4, 8.5, 11.4, 1),
            (57.8, 0.4, 1.3, 9),
            (29.9, 3.7, 9.5, 1),
            (48, 3.7, 4.6, 1),
            

            # 5th layer
            (26.4, 11.5, 2.8, 1.3),
            (25, 8.6, 1.4, 4.3),
            (11.5, 10.2, 5, 1),


            # 4th layer
            (18.1, 10.3, 1.7, 5.8),
            (7.1, 14.8, 10.9, 1.3),
            (31.5, 13.6, 3, 0.8),
            (36.5, 16.8, 7.8, 0.8),

            # 3rd layer
            (51.3, 20.1, 2.8, 5.7),
            (44.8, 20.1, 2.8, 5.7),
            (47.6, 24.8, 3.8, 1),
            (33.2, 23.4, 7.8, 1),
            (9.9, 25, 11.3, 1),
            (1.4, 20.1, 6.5, 5.8),
            (23.4, 18.5, 7.5, 4.2),
            (11.8, 21.8, 3, 0.8),
            (1.7, 13.6, 1.6, 1),
            (37.9, 11.9, 1.6, 1),
            (43, 10.3, 1.2, 2.7),
            (16.7, 13.5, 1.3, 1.3),
            

            # 2nd layer
            (34.8, 30, 2.9, 1),
            (26.7, 26.7, 5.9, 1),
            (31.3, 26.7, 1.4, 5.8),
            (23.6, 31.3, 7.7, 1.2),
            (10, 28.4, 4.8, 1),
            (21.6, 21.9, 1.4, 2.3),
            (19.8, 18.5, 1.6, 1),
            (8.3, 20, 1.6, 1),
            (0.1, 18.4, 1.6, 1),


            # Ground level
            (0.3, 35, 19, 6),
            (23.4, 35, 20.6, 6),
            (46.6, 35, 12.6, 6)
    ],
    4: [
            # 4th layer
            (33.2, 15.2, 7.8, 5.8),
            (31.3, 16.8, 2, 1),

            (6.8, 11.9, 5, 1),
            (10.2, 5.3, 3, 2.4),
            (15, 21.9, 1.2, 2),
            (13, 7, 1.8, 2.3),

            (19.9, 7, 1.2, 2.3),
            (21.4, 5.2, 1.3, 11),
            (22.6, 7, 1.8, 1),
            (11.9, 5.3, 1.1, 10.9),
            (13, 14.9, 8.4, 1.3),
            (16.4, 8.5, 1.7, 1),
            (14.9, 11.9, 5, 1),

            (24.8, 11.9, 3, 1),
            (46, 11.9, 5, 1),
            (44.4, 16.8, 6.6, 1),

            (51, 20, 8, 1),
            (38.1, 0, 1.3, 8),
            (39.3, 6.8, 6.3, 1.2),
            (39.3, 3.5, 1.7, 1),



            # 3rd layer
            (8.5, 21.8, 1.5, 1),
            (21.2, 21.8, 1.5, 1),
            (16.9, 29.5, 1.6, 1.5),
            (19.4, 29.5, 1.6, 1.5),
            (26.4, 20, 1.8, 1),
            (29.4, 20, 1.8, 1),
            (28.2, 15.2, 1.2, 9.3),
            (26.4, 23.4, 1.8, 1),
            (29.4, 23.4, 3.3, 1),
            

            # 2nd layer
            (6.9, 28.3, 4.3, 1),
            (1.7, 25, 6.3, 1),
            (0, 20, 8, 1),
            (0, 15.1, 5, 1),
            (11.9, 26.7, 1.3, 6),
            (13, 31.2, 1.3, 1.4),
            (11.9, 26.6, 6.7, 1),
            (23, 26.7, 5, 1),
            (33, 26.7, 3, 1),
            (39, 38.2, 5, 1),
            (29.8, 30, 3, 1),
            (56, 30, 3, 1),
            (41, 23.4, 5, 1),
            (52.9, 33.1, 2.9, 4),
            (38, 28.2, 5, 1),
            (46, 26.7, 6.7, 5.8),
            (44.7, 31.2, 1.5, 1.3),


            # Ground level
            (0, 33.3, 6.3, 6),
            (6.7, 34.9, 3, 6),
            (11.6, 34.9, 8.1, 6),
            (21.6, 34.9, 1.3, 6),
            (23, 33.2, 6.5, 0.9),
            (34.7, 33.3, 9.5, 6)
    ],
    5: [

            (0, 5.2, 9.5, 1),
            (0, 13.5, 11.4, 1),
            (0.2, 23.4, 1.1, 14),
            (3.5, 26.7, 1.4, 11),

            (6.8, 30, 3, 1),
            (6.7, 23.4, 3, 1),
            (10, 18.5, 4.6, 1),
            (10, 26.7, 8.2, 1.5),
            (26.3, 26.7, 5.3, 1.5),
            (36.1, 26.7, 3.7, 1.5), 

            (15, 13.5, 3, 1), 
            (18, 8.5, 5, 1),
            (49.3, 30, 3.3, 1.1), 
            (46, 23.3, 6.5, 1),
            (44.4, 18.5, 4.8, 1),

            (16.5, 20, 5, 1.3),
            (23, 20, 1.7, 1.3),
            (33, 20, 3.3, 1.3),
            (38, 20, 4.7, 1.3),
            (41.2, 13.5, 3.2, 1),
            (29.7, 7, 6.5, 1.1),
            (22.9, 7, 5, 1.2),

            (19.8, 13.5, 5, 1.3),
            (29.6, 13.5, 1.7, 1.3),
            (34.4, 13.5, 5.2, 1.3),
            (36.4, 8.5, 4.5, 1.2),
            (42.9, 5.3, 6.5, 1),
            (51, 15, 8, 1),

            (15.1, 26.8, 1, 8),
            (43.1, 26.8, 1, 8),
            (21.7, 13.6, 1.2, 7.7),
            (36.5, 13.6, 1.2, 7.7),
            (18.4, 20, 1, 8.1), 
            (39.9, 20, 1, 8.1),
            (25, 7, 1, 7.8),
            (33.3, 7, 1, 7.8),

            (54.5, 26.8, 1.2, 11),
            (57.9, 23.4, 1.2, 14),
            (51.3, 3.2, 1.5, 6.3),
            (53, 8.3, 4.4, 1.3),
            (57.6, 3.3, 1.5, 6),
            (54.3, 5, 1.7, 1.3),

            (28.2, 12, 1.2, 2.5), 
            (31.5, 18.5, 1.3, 2.5),
            (25, 25, 1, 3),
            (34.9, 31.7, 1, 3),
            (17.7, 31.5, 1.8, 1),

            (9.9, 33.2, 5, 1.3),
            (19.4, 33.2, 7.3, 1.3),
            (29.4, 33.2, 5.4, 1.3),
            (36, 33.2, 5.5, 1.3),
            (44, 33.2, 5.3, 1.3)
    ]
}

# 1. Fix the level_backgrounds initialization
level_backgrounds = {
    0: {'type': 'video', 'path': 'Level Data/Level Image/Level0_Background.mp4'},
    1: {'type': 'video', 'path': 'Level Data/Level Image/Level1_Background.mp4'},
    2: {'type': 'video', 'path': 'Level Data/Level Image/Level2_Background.mp4'},
    3: {'type': 'video', 'path': 'Level Data/Level Image/Level3_Background.mp4'},
    4: {'type': 'video', 'path': 'Level Data/Level Image/Level4_Background.mp4'},
    5: {'type': 'image', 'path': 'Level Data/Level Image/Level5.png'}
}

# Dictionary mapping dialogue scenes to background images
DIALOGUE_BACKGROUNDS = {
    "intro": "Level Data/Dialouge/bg.png",
    "level0": "Level Data/Dialouge/Forest3.png",
    "level1": "Level Data/Dialouge/origbig.png",
    "level2": "Level Data/Dialouge/mountainbg.png",
    "level3": "Level Data/Dialouge/Geoffrey.png",
    "level4": "Level Data/Dialouge/Jessi.png",
    "level5": "Level Data/Dialouge/Jacobo.png",
    "ending": "Level Data/Dialouge/Jacobo.png"
}

# Update LEVEL_REQUIREMENTS dictionary
LEVEL_REQUIREMENTS = {
    0: 3,  # Tutorial level 
    1: 4,  # Level 1: Assassin's Trial
    2: 5,  # Level 2: Wizard's Tower
    3: 6,  # Level 3: Autocrat's Domain
    4: 8,  # Level 4: Wraith's Nightmare
    5: 10  # Level 5: Undead King's Castle
}

# Update LEVEL_NAMES dictionary
LEVEL_NAMES = {
    0: "The Awakening Path",
    1: "Shadows of Deception",
    2: "Mystic Tower Ascent", 
    3: "Cryptic Dominion",
    4: "Phantom's Labyrinth",
    5: "Undead King's Sanctum"
}

# Update LEVEL_TIME_LIMITS dictionary
LEVEL_TIME_LIMITS = {
    0: 60,  # Tutorial: 1 minute
    1: 60,  # Level 1: 1 minute 
    2: 60,  # Level 2: 1 minute
    3: 60,  # Level 3: 1 minute
    4: 60,  # Level 4: 1 minute
    5: 60   # Level 5: 1 minute
}

# Update LEVEL_ENEMY_DATA to match old version
LEVEL_ENEMY_DATA = {
    0: [],  # No enemies in tutorial
    1: [
        (17, 33.4, "horizontal", 17, 32),
        (0.2, 5.5, "horizontal", 0.2, 8.5),
        (36.2, 22, "horizontal", 36.2, 41.2),
        (50.5, 10.6, "horizontal", 50.5, 56),
        (18.5, 19, "horizontal", 18.5, 27.2)
    ],
    2: [
        (8.5, 24, "horizontal", 8.5, 20),
        (0.2, 17.2, "horizontal", 0.2, 8.7),
        (44.5, 30.5, "horizontal", 44, 58.5),
        (35, 14, "horizontal", 35, 41),
        (52.3, 9.1, "horizontal", 52.3, 58.5)
    ],
    3: [
        (10.5, 24, "horizontal", 10.5, 20.5),
        (24, 34, "horizontal", 24, 43),
        (8, 13.6, "horizontal", 8, 16.5),
        (30, 2.6, "horizontal", 30, 38.5),
        (48, 6.4, "horizontal", 48, 57),
        (37.5, 13.8, "horizontal", 37.5, 43.5)
    ],
    4: [],  # No enemies in level 4
    5: [
        (0, 4.2, "horizontal", 0, 9.5),
        (0, 12.5, "horizontal", 0, 11.4),
        (10, 25.7, "horizontal", 10, 18.2),
        (41, 25.7, "horizontal", 41, 45),
        (16.5, 19, "horizontal", 16.5, 22.3),
        (38, 19, "horizontal", 38, 42),
        (19.8, 12.5, "horizontal", 19.8, 24),
        (34.4, 12.5, "horizontal", 34.4, 39.7),
        (42.9, 4.3, "horizontal", 42.9, 48.9),
        (51, 14, "horizontal", 51, 59),
        (44, 32.2, "horizontal", 44, 49),
        (10, 32.2, "horizontal", 10, 14)
    ]
}

# Update LEVEL_DEADLY_DATA for hazardous tiles
LEVEL_DEADLY_DATA = {
    0: [],  # No deadly tiles in tutorial
    1: [],  # No deadly tiles in level 1
    2: [
        (23.2, 3.6, 3, 1),
        (26.4, 10.2, 4.8, 1.3),
        (28, 34, 15, 1)
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6)
    ],
    4: [
        (10, 22.4, 11.3, 1.3)
    ],
    5: [
        (0.2, 34, 59, 4),
        (15.4, 28, 2.2, 3),
        (22, 25.4, 2, 2),
        (25, 12, 2.4, 2.7),
        (28.4, 18.7, 2.4, 2.3),
        (31.8, 25.2, 2.3, 2),
        (26.9, 32, 2, 2),
        (40.2, 25.3, 2, 2),
        (41.7, 30.3, 2, 2)
    ]
}

# Update LEVEL_BLUE_DATA for special tiles
LEVEL_BLUE_DATA = {
    0: [],  # No blue tiles in tutorial
    1: [],  # No blue tiles in level 1
    2: [
        (23.2, 3.6, 3, 1.1),
        (26.4, 10.2, 4.8, 1.4)
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6)
    ],
    4: [
        (10, 23.4, 11.3, 1.3),
        (18.5, 23.4, 1, 7.6)
    ],
    5: [
        (26.2, 13.5, 1.7, 1.3),
        (26.4, 20, 4.8, 1.3),
        (19.6, 26.7, 5.3, 1.5),
        (41, 26.7, 5, 1.5),
        (31.1, 26.7, 3.3, 1.5)
    ]
}

# Initialize video capture and load images
background_surfaces = {}
video_captures = {}

for level, bg_data in level_backgrounds.items():
    if bg_data['type'] == 'video':
        try:
            video_captures[level] = cv2.VideoCapture(bg_data['path'])
        except Exception as e:
            print(f"Error loading video for level {level}: {e}")
            # Fallback to a solid color or default image
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))
    else:
        try:
            img = pygame.image.load(bg_data['path']).convert()
            background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except Exception as e:
            print(f"Error loading image for level {level}: {e}")
            # Fallback to a solid color
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))

# Update collision tile creation (in World class):
def __init__(self, level_data, deadly_data):
    self.collision_tiles = []
    self.deadly_tiles = []

    for plat in level_data:
        # Adjust coordinates to align with background
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        height = int(plat[3] * TILE_SIZE)
        
        # Add small margin for better collision
        margin = 2
        collision_rect = pygame.Rect(
            x + margin,
            y + margin,
            width - margin * 2,
            height - margin * 2
        )
        self.collision_tiles.append(CollisionTile(x, y, width, height))

    for deadly in deadly_data:
        x = deadly[0] * TILE_SIZE
        y = deadly[1] * TILE_SIZE
        width = deadly[2] * TILE_SIZE
        height = int(deadly[3] * TILE_SIZE)
        
        # Add similar margin for deadly tiles
        margin = 2
        self.deadly_tiles.append(CollisionTile(
            x + margin, 
            y + margin, 
            width - margin * 2, 
            height - margin * 2
        ))

    
# Update LEVEL_DIALOGUES dictionary to add Level 0
LEVEL_DIALOGUES = {
    0: [
        "Tutorial Level: Learning the Basics",
        "Master the art of movement and key collection.",
        "Collect 3 keys to proceed to your first real challenge.",
        "Press SPACE to continue..."
    ],
    1: [
        "Level 1: The Assassin's Trial",
        "Find 4 keys while avoiding deadly traps.",
        "Press SPACE to continue..."
    ],
    2: [
        "Level 2: The Wizard's Tower",
        "Collect 5 keys hidden by magical illusions.",
        "Press SPACE to continue..."
    ],
    3: [
        "Level 3: The Autocrat's Domain",
        "Gather 6 keys from this sprawling fortress.",
        "Press SPACE to continue..."
    ],
    4: [
        "Level 4: The Wraith's Nightmare",
        "Find 8 keys in this realm of shadows.",
        "Press SPACE to continue..."
    ],
    5: [
        "Final Level: The Undead King's Castle",
        "Collect all 10 keys to complete your journey.",
        "Press SPACE to continue..."
    ]
}

class Leaderboard:
    def __init__(self, screen):
        self.screen = screen
        self.scores = []
        self.font = pygame.font.SysFont('Bauhaus 93', 24)
        self.title_font = pygame.font.SysFont('Bauhaus 93', 32)
        self.load_scores()

    def add_score(self, player_name, time_seconds):
        self.scores.append({
            'name': player_name,
            'time': time_seconds
        })
        self.scores.sort(key=lambda x: x['time'])  # Sort by time (ascending)
        self.scores = self.scores[:10]  # Keep only top 10
        self.save_scores()

    def load_scores(self):
        try:
            with open('leaderboard.txt', 'r') as f:
                lines = f.readlines()
                self.scores = []
                for line in lines:
                    name, time = line.strip().split(',')
                    self.scores.append({'name': name, 'time': float(time)})
        except FileNotFoundError:
            self.scores = []

    def save_scores(self):
        with open('leaderboard.txt', 'w') as f:
            for score in self.scores:
                f.write(f"{score['name']},{score['time']}\n")

    def draw(self):
        # Create semi-transparent background
        leaderboard_surface = pygame.Surface((300, 400), pygame.SRCALPHA)
        pygame.draw.rect(leaderboard_surface, (0, 0, 0, 180), (0, 0, 300, 400))
        
        # Draw title
        title = self.title_font.render("LEADERBOARD", True, (255, 215, 0))
        leaderboard_surface.blit(title, (150 - title.get_width()//2, 10))
        
        # Draw scores
        y = 60
        for i, score in enumerate(self.scores):
            minutes = int(score['time'] // 60)
            seconds = int(score['time'] % 60)
            text = self.font.render(f"{i+1}. {score['name']}: {minutes:02d}:{seconds:02d}", True, (255, 255, 255))
            leaderboard_surface.blit(text, (20, y))
            y += 30
        
        # Position leaderboard on right side of screen
        self.screen.blit(leaderboard_surface, (self.screen.get_width() - 320, 60))

class SceneManager:
    def __init__(self, screen):
        self.screen = screen
        self.current_scene = None
        self.scenes = []
        self.scene_index = 0
        self.player_name = ""
        self.text_input = TextInput(screen)
        self.text_input.active = True
        self.current_state = "scene"
        self.level_completed = False
        self.current_level = 0
        self.load_scenes()

    def load_scenes(self):
        self.scenes = [
            # Scene 1 - Name Input
            {
                'image': 'DCI_Scenes/Scene1.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene1.mp3',
                'text': 'Enter Your Name:',
                'input': True,
                'next': 'scene'
            },
            # Scene 2
            {
                'image': 'DCI_Scenes/Scene2.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene2.mp3',
                'text': f'Dear {self.player_name}, you stumbled upon the ancient artifact, half-buried in a cave. It was a stone box, covered in intricate, interlocking symbols that seemed to shift if you stared too long.',
                'next': 'scene'
            },
            # Scene 3
            {
                'image': 'DCI_Scenes/Scene3.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene3.mp3',
                'text': f'{self.player_name} worked carefully, pressing and turning parts of the stone, the symbols clicked into alignment. Inside was a letter that wrote: "Whoever unlocks these secrets is bound to us. Your presence is now required. The island awaits, {self.player_name}."',
                'next': 'scene'
            },
            # Scene 4
            {
                'image': 'DCI_Scenes/Scene4.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene4.mp3',
                'text': f'{self.player_name} feels something watching. A mysterious voice echoes through the darkness.',
                'next': 'scene'
            },
            # Scene 5
            {
                'image': 'DCI_Scenes/Scene5.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene5.mp3',
                'text': f'{self.player_name} follows the voice as it gets closer and closer.',
                'next': 'scene'
            },
            # Scene 6
            {
                'image': 'DCI_Scenes/Scene6.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene6.mp3',
                'text': f'Before {self.player_name} realizes, the path leads to a forest with an eerie feel.',
                'next': 'scene'
            },
            # Scene 7 - Lead to Tutorial Level
            {
                'image': 'DCI_Scenes/Scene7.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene7.mp3',
                'text': f'The ghostly voice of Eralt lingers in the air.\n\nEralt the Ghost: "Welcome, {self.player_name}. Beware, young master. The island knows your fears, your weaknesses. Solve the code, and move closer to your destiny. Fail, and join the lost souls who could not decode the island\'s secrets."',
                'next': 'level_0'
            },
            # Scene 8 - After Tutorial, before Level 1
            {
                'image': 'DCI_Scenes/Scene8.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene8.mp3',
                'text': f'A figure emerges from the shadows.\n\nPalak the Assassin: "I am Palak, the Assassin, Guardian of the First Level. Ah, so you are {self.player_name}. To pass my challenge, you must prove you can see through deception and lies. Codes are more than wordstheyre veils of truth and deceit. Decipher mine, or face the consequences."',
                'next': 'level_1'
            },
            # Scene 9 - After Level 1 completion
            {
                'image': 'DCI_Scenes/Scene9.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene9.mp3',
                'text': f'{self.player_name} completes the code with determination.\n\nPalak the Assassin: "Impressive, {self.player_name}. You may pass for now. Your journey has only begun."',
                'next': 'scene'
            },
            # Scene 10 - Lead to Level 2
            {
                'image': 'DCI_Scenes/Scene10.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene10.mp3',
                'text': f'Russ the Wizard: "Ah, so the prophecy speaks true. {self.player_name}, the new champion, has arrived." He gestures to a puzzle box floating in mid-air, surrounded by a shimmering aura.',
                'next': 'level_2'
            },
            # Scene 11 - After Level 2 completion
            {
                'image': 'DCI_Scenes/Scene11.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene11.mp3',
                'text': f'The Wizard smiles approvingly, nodding.\n\nRuss the Wizard: "Well done, {self.player_name}. You\'ve earned the right to advance. Your wisdom grows stronger with each challenge."',
                'next': 'scene'
            },
            # Scene 12 - Lead to Level 3
            {
                'image': 'DCI_Scenes/Scene12.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene12.mp3',
                'text': f'Geoff the Autocrat: "So, {self.player_name}, you\'ve passed the others. But codes are not just puzzles; they\'re tools of control, of power. I rule through secrets, and now you shall learn their true weight."',
                'next': 'level_3'
            },
            # Scene 13 - After Level 3 completion
            {
                'image': 'DCI_Scenes/Scene13.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene13.mp3',
                'text': f'Autocrat inclines his head, a dark smile on his lips.\n\nGeoff the Autocrat: "Impressive, {self.player_name}. Remember, only those who understand power can control it. Your mastery grows. Proceed."',
                'next': 'scene'
            },
            # Scene 14 - Lead to Level 4
            {
                'image': 'DCI_Scenes/Scene14.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene14.mp3',
                'text': f'Jessica the Wraith materializes from the mist.\n\nJessica: "Ah, {self.player_name}, you are brave, but bravery means nothing in the face of fear. This trial is not of logic, but of your darkest nightmares. Let us see what lies in the depths of your soul."',
                'next': 'level_4'
            },
            # Scene 15 - After Level 4 completion
            {
                'image': 'DCI_Scenes/Scene15.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene15.mp3',
                'text': f'Jessica the Wraith: "You surprise me, {self.player_name}. Few have faced their fears with such resolve. You may go on, though many are lost here Remember this strength in the trials ahead."',
                'next': 'scene'
            },
            # Scene 16 - Lead to Final Level
            {
                'image': 'DCI_Scenes/Scene16.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene16.mp3',
                'text': f'The Undead King\'s voice resonates through the chamber.\n\nJacobo: "At last, {self.player_name}, you stand before the final trial. I am Jacobo, the Undead King, master of the lost and forgotten. To claim victory, you must decipher the oldest code of all, the language of life and death itself."',
                'next': 'level_5'
            },
            # Scene 17 - After Final Level completion
            {
                'image': 'DCI_Scenes/Scene17.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene17.mp3',
                'text': f'Jacobo the Undead King: "Remarkable, {self.player_name}. You have proven yourself beyond all expectations. But know that this accomplishment is not a prize, but a burden. The codes you now possess contain secrets that even the spirits dare not speak. Guard them well, for they will change everything."',
                'next': 'scene'
            },
            # Scene 18 - Exit scene
            {
                'image': 'DCI_Scenes/Scene18.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene18.mp3',
                'text': f'{self.player_name} emerges from the cave, forever changed by the journey.',
                'next': 'scene'
            },
            # Scene 19 - Final scene and credits
            {
                'image': 'DCI_Scenes/Scene19.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene19.mp3',
                'text': f'Congratulations, {self.player_name}. You are free, but the knowledge you carry will be your eternal companion.',
                'next': 'game_complete',
                'show_credits': True
            }
        ]
        
        # Initialize first scene
        self.current_scene = Scene(self.screen, self.scenes[0])

    def update_scenes_with_name(self):
        """Update all scenes with the player's name"""
        for i in range(1, len(self.scenes)):
            if 'text' in self.scenes[i]:
                self.scenes[i]['text'] = self.scenes[i]['text'].format(
                    player_name=self.player_name)
        
        # Update current scene if not on first scene
        if self.scene_index > 0:
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index], self.player_name)

    def next_scene(self):
        self.scene_index += 1
        if self.scene_index < len(self.scenes):
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index], self.player_name)
        else:
            self.scene_index = len(self.scenes) - 1  # Stay on last scene

    def handle_level_completion(self, level):
        self.level_completed = True
        self.current_level = level + 1
        level_to_scene = {
            0: 7,  # After tutorial, go to Scene 8
            1: 8,  # After Level 1, go to Scene 9
            2: 10, # After Level 2, go to Scene 11
            3: 12, # After Level 3, go to Scene 13
            4: 14, # After Level 4, go to Scene 15
            5: 16  # After Level 5, go to Scene 17
        }
        if level in level_to_scene:
            self.scene_index = level_to_scene[level]
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index], self.player_name)
            return 'scene'
        return 'playing'

    def update(self, dt):
        # Handle current scene update
        if self.current_scene:
            scene_complete = self.current_scene.update(dt)
            if scene_complete:
                next_state = self.scenes[self.scene_index].get('next', 'scene')
                if next_state.startswith('level_'):
                    level_num = int(next_state.split('_')[1])
                    self.current_level = level_num
                    return 'playing'
                elif next_state == 'scene':
                    self.next_scene()
        return self.current_state

    def next_scene(self):
        self.scene_index += 1
        if self.scene_index < len(self.scenes):
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index])
        else:
            self.scene_index = len(self.scenes) - 1  # Stay on last scene

    def draw(self):
        """Draw the current scene"""
        if self.current_scene:
            self.current_scene.draw()
            
            # Draw text input if active and in name input state
            if self.text_input.active:
                self.text_input.draw(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        

class TextInput:
    def __init__(self, screen, font_size=32):
        self.screen = screen
        self.font = pygame.font.SysFont('Bauhaus 93', font_size)
        self.input_text = ""
        self.active = True
        self.cursor_visible = True
        self.cursor_timer = pygame.time.get_ticks()
        self.cursor_blink_speed = 500  # Blink every 500ms
        self.max_length = 20
        
        # Visual styling
        self.box_width = 300
        self.box_height = 50
        self.text_color = (255, 255, 255)
        self.box_color = (0, 0, 0, 180)
        self.border_color = (100, 100, 100)
        self.active_border_color = (200, 200, 200)
        self.prompt_text = "Enter your name:"
        
        # Create prompt surface once
        self.prompt_surface = self.font.render(self.prompt_text, True, self.text_color)

    def handle_event(self, event):
        if not self.active:
            return None

        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RETURN:
                if self.input_text.strip():  # Only accept if there's actual text
                    result = self.input_text.strip()
                    self.active = False
                    return result
            elif event.key == pygame.K_BACKSPACE:
                self.input_text = self.input_text[:-1]
            else:
                if len(self.input_text) < self.max_length and event.unicode.isprintable():
                    self.input_text += event.unicode
        return None

    def draw(self, x, y):
        if not self.active:
            return

        # Center the input box
        box_x = x - self.box_width // 2
        box_y = y

        # Draw the prompt text centered above the input box
        prompt_x = x - self.prompt_surface.get_width() // 2
        prompt_y = box_y - 40
        self.screen.blit(self.prompt_surface, (prompt_x, prompt_y))

        # Draw input box background
        s = pygame.Surface((self.box_width, self.box_height), pygame.SRCALPHA)
        pygame.draw.rect(s, self.box_color, (0, 0, self.box_width, self.box_height))
        self.screen.blit(s, (box_x, box_y))

        # Draw border
        border_color = self.active_border_color if self.active else self.border_color
        pygame.draw.rect(self.screen, border_color, 
                        (box_x, box_y, self.box_width, self.box_height), 2)

        # Draw input text
        if self.input_text:
            text_surface = self.font.render(self.input_text, True, self.text_color)
            text_x = box_x + 10
            text_y = box_y + (self.box_height - text_surface.get_height()) // 2
            self.screen.blit(text_surface, (text_x, text_y))

        # Draw blinking cursor
        current_time = pygame.time.get_ticks()
        if current_time - self.cursor_timer > self.cursor_blink_speed:
            self.cursor_visible = not self.cursor_visible
            self.cursor_timer = current_time

        if self.cursor_visible:
            cursor_x = box_x + 10 + (self.font.size(self.input_text)[0] if self.input_text else 0)
            cursor_y = box_y + 10
            pygame.draw.line(self.screen, self.text_color,
                           (cursor_x, cursor_y),
                           (cursor_x, cursor_y + self.box_height - 20),
                           2)

        # Draw instruction text
        instruction_text = "Press ENTER to confirm"
        instruction_surface = pygame.font.SysFont('Bauhaus 93', 20).render(
            instruction_text, True, (200, 200, 200))
        instruction_x = x - instruction_surface.get_width() // 2
        instruction_y = box_y + self.box_height + 10
        self.screen.blit(instruction_surface, (instruction_x, instruction_y))

class Scene:
    def __init__(self, screen: pygame.Surface, scene_data: dict, player_name=""):  # Add player_name parameter
        self.screen = screen
        self.scene_data = scene_data.copy()
        self.bg_image = None
        self.audio = None
        self.text_box = None
        self.text_font = pygame.font.SysFont('Bauhaus 93', 32)
        self.fade_alpha = 0
        self.fade_speed = 5
        self.fading_in = True
        self.fading_out = False
        self.completed = False
        self.is_name_input = scene_data.get('input', False)
        
        # Format the text with the player's name if available
        if 'text' in self.scene_data and player_name:
            self.scene_data['text'] = self.scene_data['text'].replace('{self.player_name}', player_name)
            self.scene_data['text'] = self.scene_data['text'].replace('{player_name}', player_name)
                
        self.load_assets()
                
    def load_assets(self):
        # Load background image
        if 'image' in self.scene_data:
            try:
                self.bg_image = WINDOWSHOWN
                pygame.image.load(self.scene_data['image'])
                self.bg_image = pygame.transform.scale(self.bg_image, self.screen.get_size())
            except pygame.error:
                print(f"Could not load image: {self.scene_data['image']}")
                self.bg_image = pygame.Surface(self.screen.get_size())
                self.bg_image.fill((0, 0, 0))
        
        # Load audio
        if 'audio' in self.scene_data:
            try:
                self.audio = pygame.mixer.Sound(self.scene_data['audio'])
                self.audio.play()
            except pygame.error:
                print(f"Could not load audio: {self.scene_data['audio']}")
    
    def update(self, dt: float) -> bool:
        if self.fading_in:
            self.fade_alpha = min(255, self.fade_alpha + self.fade_speed)
            if self.fade_alpha >= 255:
                self.fading_in = False
        elif self.fading_out:
            self.fade_alpha = max(0, self.fade_alpha - self.fade_speed)
            if self.fade_alpha <= 0:
                self.cleanup()  # Stop audio when fade out completes
                self.completed = True
        
        # Only return completed if we're not in the middle of a fade effect
        return self.completed
    
    def draw(self):
        # Always draw background image first
        if self.bg_image:
            self.screen.blit(self.bg_image, (0, 0))
        
        # Draw text box if there's text and not a name input scene
        if not self.is_name_input and 'text' in self.scene_data:
            self.draw_text_box(self.scene_data['text'])
        
        # Show prompt when ready for input
        if not self.fading_in and not self.fading_out and not self.is_name_input:
            prompt_font = pygame.font.SysFont('Bauhaus 93', 24)
            prompt = prompt_font.render("Press SPACE to continue...", True, (200, 200, 200))
            prompt_rect = prompt.get_rect(
                right=self.screen.get_width() - 20,
                bottom=self.screen.get_height() - 20
            )
            self.screen.blit(prompt, prompt_rect)
        
        # Apply fade effect last
        fade_surface = pygame.Surface(self.screen.get_size(), pygame.SRCALPHA)
        fade_surface.fill((0, 0, 0, 255 - self.fade_alpha))
        self.screen.blit(fade_surface, (0, 0))
    
    def draw_text_box(self, text: str):
        # Create semi-transparent text box
        box_height = 150
        box_surface = pygame.Surface((self.screen.get_width(), box_height), pygame.SRCALPHA)
        box_surface.fill((0, 0, 0, 180))
        
        # Draw text
        lines = self.wrap_text(text, self.screen.get_width() - 40)
        y_offset = 20
        for line in lines:
            text_surface = self.text_font.render(line, True, (255, 255, 255))
            box_surface.blit(text_surface, (20, y_offset))
            y_offset += 40
        
        # Draw box at bottom of screen
        self.screen.blit(box_surface, (0, self.screen.get_height() - box_height))
    
    def wrap_text(self, text: str, max_width: int):
        words = text.split()
        lines = []
        current_line = []
        current_width = 0
        
        for word in words:
            word_surface = self.text_font.render(word + " ", True, (255, 255, 255))
            word_width = word_surface.get_width()
            
            if current_width + word_width <= max_width:
                current_line.append(word)
                current_width += word_width
            else:
                lines.append(" ".join(current_line))
                current_line = [word]
                current_width = word_width
        
        if current_line:
            lines.append(" ".join(current_line))
        
        return lines
    
    def cleanup(self):
        """Stop audio playback and cleanup resources"""
        if hasattr(self, 'audio') and self.audio:
            try:
                self.audio.stop()
            except (pygame.error, AttributeError):
                pass  # Ignore errors during cleanup
        self.audio = None

    def __del__(self):
        """Ensure audio is stopped when the scene is destroyed"""
        self.cleanup()

    def handle_input(self, event: pygame.event.Event):
        if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
            if not self.fading_in and not self.fading_out:
                self.fading_out = True

class PauseButton:
    def __init__(self, screen):
        self.screen = screen
        # Create button in top right corner with padding
        self.rect = pygame.Rect(SCREEN_WIDTH - 120, 10, 100, 30)
        self.color = (0, 0, 0, 180)  # Semi-transparent black
        self.hover_color = (50, 50, 50, 180)
        self.font = pygame.font.SysFont('Bauhaus 93', 24)
        self.text = self.font.render('PAUSE', True, (255, 255, 255))
        self.text_rect = self.text.get_rect(center=self.rect.center)
        self.is_hovered = False

    def draw(self):
        # Create surface with alpha for transparency
        button_surface = pygame.Surface((self.rect.width, self.rect.height), pygame.SRCALPHA)
        
        # Draw button with hover effect
        color = self.hover_color if self.is_hovered else self.color
        pygame.draw.rect(button_surface, color, button_surface.get_rect(), border_radius=5)
        
        # Draw button on screen
        self.screen.blit(button_surface, self.rect)
        self.screen.blit(self.text, self.text_rect)

    def handle_event(self, event):
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1 and self.rect.collidepoint(event.pos):
                return True
        return False

class EnhancedGameStats:
    def __init__(self, screen):
        self.screen = screen
        
        # Load and scale icons with more reasonable size
        try:
            icon_size = (32, 32)  # Reduced from 40
            self.trophy_icon = pygame.transform.scale(pygame.image.load('img/trophy.png'), icon_size)
            self.key_icon = pygame.transform.scale(pygame.image.load('img/key_icon.png'), icon_size)
            self.clock_icon = pygame.transform.scale(pygame.image.load('img/clock.png'), icon_size)
        except Exception as e:
            print(f"Error loading game stats icons: {e}")
            self.trophy_icon = pygame.Surface(icon_size)
            self.trophy_icon.fill((255, 215, 0))
            self.key_icon = pygame.Surface(icon_size)
            self.key_icon.fill((255, 255, 255))
            self.clock_icon = pygame.Surface(icon_size)
            self.clock_icon.fill((100, 200, 255))
        
        # Fonts with better sizes
        self.title_font = pygame.font.SysFont('Bauhaus 93', 28)
        self.stats_font = pygame.font.SysFont('Bauhaus 93', 24)
        self.small_font = pygame.font.SysFont('Bauhaus 93', 20)

    def draw_stats_panel(self, level, keys_collected, required_keys, elapsed_time, time_limit):
        # Main panel dimensions
        panel_width = 600  # Fixed width
        panel_height = 40  # Reduced height
        panel_x = (SCREEN_WIDTH - panel_width) // 2  # Center horizontally
        panel_y = 10  # Top padding
        
        # Create semi-transparent panel
        panel_surface = pygame.Surface((panel_width, panel_height), pygame.SRCALPHA)
        pygame.draw.rect(panel_surface, (0, 0, 0, 150), (0, 0, panel_width, panel_height), border_radius=10)
        
        # Section widths
        section_width = panel_width // 3
        
        # Level name (left section)
        level_text = f"{LEVEL_NAMES[level]}"
        name_surface = self.stats_font.render(level_text, True, (255, 215, 0))
        name_x = 20  # Left padding
        name_y = (panel_height - name_surface.get_height()) // 2
        panel_surface.blit(name_surface, (name_x, name_y))
        
        # Time remaining (middle section)
        remaining_time = time_limit - elapsed_time
        minutes = int(remaining_time // 60)
        seconds = int(remaining_time % 60)
        timer_text = self.stats_font.render(f"{minutes:02}:{seconds:02}", True, (255, 255, 255))
        timer_x = section_width + (section_width - timer_text.get_width()) // 2
        timer_y = (panel_height - timer_text.get_height()) // 2
        panel_surface.blit(timer_text, (timer_x, timer_y))
        
        # Keys collected (right section)
        key_text = self.stats_font.render(f"{keys_collected}/{required_keys}", True, (255, 255, 255))
        key_x = section_width * 2 + (section_width - key_text.get_width() - self.key_icon.get_width() - 5) // 2
        key_y = (panel_height - key_text.get_height()) // 2
        panel_surface.blit(self.key_icon, (key_x, key_y))
        panel_surface.blit(key_text, (key_x + self.key_icon.get_width() + 5, key_y))
        
        # Draw the panel on screen
        self.screen.blit(panel_surface, (panel_x, panel_y))

class PauseMenu:
    def __init__(self, screen):
        self.screen = screen
        self.options = ['RESUME', 'RESTART LEVEL', 'QUIT TO MENU']
        
        # Button dimensions and styling
        self.button_width = 250
        self.button_height = 40
        self.button_spacing = 20
        
        # Create button rects centered on screen
        self.button_rects = []
        start_y = SCREEN_HEIGHT // 2
        for i in range(len(self.options)):
            rect = pygame.Rect(
                (SCREEN_WIDTH - self.button_width) // 2,
                start_y + (self.button_height + self.button_spacing) * i,
                self.button_width,
                self.button_height
            )
            self.button_rects.append(rect)
            
        # Fonts
        self.title_font = pygame.font.SysFont('Bauhaus 93', 50)
        self.option_font = pygame.font.SysFont('Bauhaus 93', 35)
        
        # Colors
        self.text_color = (255, 255, 255)
        self.button_color = (50, 50, 50, 180)
        self.hover_color = (70, 70, 70, 180)
        self.selected_color = (255, 215, 0)
        
        self.hovered = None

    def draw(self):
        # Draw dark overlay
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        
        # Draw PAUSED text
        pause_text = self.title_font.render('PAUSED', True, self.text_color)
        text_rect = pause_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//4))
        self.screen.blit(pause_text, text_rect)
        
        # Get mouse position
        mouse_pos = pygame.mouse.get_pos()
        
        # Draw buttons with hover effect
        for i, (option, rect) in enumerate(zip(self.options, self.button_rects)):
            # Check if mouse is hovering over button
            is_hovered = rect.collidepoint(mouse_pos)
            if is_hovered:
                self.hovered = i
                color = self.hover_color
            else:
                color = self.button_color
            
            # Create button surface with alpha
            button_surface = pygame.Surface((rect.width, rect.height), pygame.SRCALPHA)
            pygame.draw.rect(button_surface, color, button_surface.get_rect(), border_radius=5)
            self.screen.blit(button_surface, rect)
            
            # Draw button text
            text = self.option_font.render(option, True, self.selected_color if is_hovered else self.text_color)
            text_rect = text.get_rect(center=rect.center)
            self.screen.blit(text, text_rect)

    def handle_input(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            mouse_pos = pygame.mouse.get_pos()
            for i, rect in enumerate(self.button_rects):
                if rect.collidepoint(mouse_pos):
                    return self.options[i]
        return None

def handle_level_completion(current_level, door, player):
    """Handle level completion and transitions"""
    if not door.entered and keys_collected >= LEVEL_REQUIREMENTS[current_level]:
        # Start door zoom if we have enough keys
        if not door.is_open:
            camera.start_door_zoom(door)
        elif pygame.sprite.collide_rect(player, door):
            door.entered = True
            camera.stop_sounds()
            return True
    return False

def transition_to_next_level():
    """Handle transition to the next level"""
    global current_level, movement_enabled
    
    # Store completion time
    if game_start_time:
        elapsed_time = int(time.time() - game_start_time)
        level_times.append(elapsed_time)
    
    # Determine next level
    next_level = current_level + 1 if current_level < 5 else None
    
    if next_level is not None:
        # Initialize next level
        result = init_level(next_level)
        if result is not None:
            keys_group, door, world, moving_enemies, player, ghost = result
            camera.start_transition()
            movement_enabled = False
            return "playing"
        else:
            print(f"Failed to initialize level {next_level}")
            return "error"
    else:
        # Game completed
        return "game_complete"

def handle_pause():
    """Handle pause menu state and actions"""
    global paused, running, current_state, keys_collected, game_over, total_pause_time, pause_start_time
    
    pause_menu.draw()
    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
            
        if current_state in ["intro_scenes", "level_transition"]:
            scene_manager.handle_input(event)
        
        # Handle pause button click
        if current_state == "playing" and not paused and pause_button.handle_event(event):
            paused = True
            pause_start_time = datetime.now()
            fade_alpha = 0
            
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                paused = False
                total_pause_time += datetime.now() - pause_start_time
                return True
                
        action = pause_menu.handle_input(event)
        if action:
            if action == 'RESUME':
                paused = False
                total_pause_time += datetime.now() - pause_start_time
            elif action == 'RESTART LEVEL':
                paused = False
                game_over = 0
                keys_collected = 0
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                camera.cleanup()
                camera.reset_zoom()
                keys_group, door, world, moving_enemies, player, ghost = init_level(current_level)
                camera.start_transition()
            elif action == 'QUIT TO MENU':
                # Cleanup current game resources
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                cleanup_backgrounds()
                pygame.mixer.stop()  # Stop all sound channels
                pygame.mixer.music.stop()  # Stop background music
                pygame.quit()

                # Import and run main menu
                try:
                    import MAINMENU
                    MAINMENU.main()
                    sys.exit()
                except ImportError as e:
                    print(f"Error returning to main menu: {e}")
                    return False
    
    pygame.display.update()
    return True

def cleanup_game():
    """Cleanup all game resources"""
    if hasattr(player, 'stop_sounds'):
        player.stop_sounds()
    if hasattr(camera, 'stop_sounds'):
        camera.stop_sounds()
    if hasattr(scene_manager, 'cleanup'):
        scene_manager.cleanup()
    cleanup_backgrounds()
    pygame.mixer.stop()
    pygame.mixer.music.stop()
    pygame.quit()

class DialogueBox:
    def __init__(self, screen):
        self.screen = screen
        self.animation_complete = False
        self.current_alpha = 0
        self.target_alpha = 180
        self.fade_speed = 10
        self.current_line = 0
        self.current_word = 0
        self.text_delay = 2
        self.frame_counter = 0
        self.words_revealed = []
        
        # Dialogue box dimensions and position
        self.box_height = 200
        self.box_padding = 20
        self.box_y = SCREEN_HEIGHT - self.box_height - 30
        
        # Text formatting
        self.line_height = 40
        self.max_width = SCREEN_WIDTH - (self.box_padding * 2)
        self.font = pygame.font.SysFont('Bauhaus 93', 32)
        
    def wrap_text(self, text):
        """Split text into lines that fit within the dialogue box"""
        words = text.split()
        lines = []
        current_line = []
        current_width = 0
        
        for word in words:
            word_surface = self.font.render(word + ' ', True, (255, 255, 255))
            word_width = word_surface.get_width()
            
            if current_width + word_width <= self.max_width:
                current_line.append(word)
                current_width += word_width
            else:
                lines.append(' '.join(current_line))
                current_line = [word]
                current_width = word_width
        
        if current_line:
            lines.append(' '.join(current_line))
            
        return lines
        
    def animate(self, dialogue_lines, background_image=None):
        # Draw background image if provided
        if background_image:
            try:
                bg_img = pygame.image.load(background_image).convert()
                bg_img = pygame.transform.scale(bg_img, (SCREEN_WIDTH, SCREEN_HEIGHT))
                self.screen.blit(bg_img, (0, 0))
            except (pygame.error, FileNotFoundError) as e:
                print(f"Error loading background image: {e}")
                self.screen.fill((0, 0, 0))
        
        # Create semi-transparent dialogue box
        dialogue_surface = pygame.Surface((SCREEN_WIDTH, self.box_height), pygame.SRCALPHA)
        box_color = (0, 0, 0, self.current_alpha)
        pygame.draw.rect(dialogue_surface, box_color, (0, 0, SCREEN_WIDTH, self.box_height))
        
        # Animate fade in
        if self.current_alpha < self.target_alpha:
            self.current_alpha = min(self.current_alpha + self.fade_speed, self.target_alpha)
        
        self.screen.blit(dialogue_surface, (0, self.box_y))
        
        # Initialize words_revealed if needed
        if not self.words_revealed:
            # Wrap each dialogue line
            wrapped_lines = []
            for line in dialogue_lines:
                wrapped_lines.extend(self.wrap_text(line))
            self.words_revealed = [[] for _ in wrapped_lines]
        
        # Update text animation
        self.frame_counter += 1
        if self.frame_counter >= self.text_delay:
            self.frame_counter = 0
            self.update_text(dialogue_lines)
        
        # Draw text
        y_offset = self.box_y + self.box_padding
        line_spacing = 40
        
        for i, revealed_words in enumerate(self.words_revealed):
            if revealed_words:  # Only draw lines that have revealed words
                text = ' '.join(revealed_words)
                text_surface = self.font.render(text, True, (255, 255, 255))
                text_rect = text_surface.get_rect(
                    left=self.box_padding,
                    top=y_offset + i * line_spacing
                )
                self.screen.blit(text_surface, text_rect)
        
        # Add "Press SPACE to continue" prompt when animation is complete
        if self.animation_complete:
            prompt = pygame.font.SysFont('Bauhaus 93', 24).render(
                "Press SPACE to continue...", True, (200, 200, 200))
            prompt_rect = prompt.get_rect(
                right=SCREEN_WIDTH - self.box_padding,
                bottom=SCREEN_HEIGHT - self.box_padding
            )
            self.screen.blit(prompt, prompt_rect)
        
        return self.animation_complete
    
    def update_text(self, dialogue_lines):
        if self.current_line < len(dialogue_lines):
            wrapped_lines = []
            for line in dialogue_lines:
                wrapped_lines.extend(self.wrap_text(line))
            
            if self.current_line < len(wrapped_lines):
                words = wrapped_lines[self.current_line].split()
                if self.current_word < len(words):
                    self.words_revealed[self.current_line].append(words[self.current_word])
                    self.current_word += 1
                else:
                    self.current_line += 1
                    self.current_word = 0
            else:
                self.animation_complete = True
        else:
            self.animation_complete = True

def show_dialogue(dialogue_lines, background_key=None):
    """
    Show dialogue with background image based on the dialogue section.
    
    Args:
        dialogue_lines (list): List of strings containing dialogue text
        background_key (str): Key for background image from DIALOGUE_BACKGROUNDS
    """
    dialogue_box = DialogueBox(screen)
    background_path = None
    
    if background_key and background_key in DIALOGUE_BACKGROUNDS:
        background_path = DIALOGUE_BACKGROUNDS[background_key]
        try:
            background = pygame.image.load(background_path).convert()
            background = pygame.transform.scale(background, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except (pygame.error, FileNotFoundError) as e:
            print(f"Error loading background image {background_path}: {e}")
            background = None
    else:
        background = None

    waiting = True
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                    return True
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        # Clear screen
        screen.fill((0, 0, 0))
        
        # Draw background if available
        if background:
            screen.blit(background, (0, 0))
            
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

class Ghost(pygame.sprite.Sprite):
    def __init__(self, screen_width, screen_height, player, level):
        super().__init__()
        # Load and scale ghost image
        self.image = pygame.image.load('img/sghost.png').convert_alpha()
        self.image = pygame.transform.scale(self.image, (60, 60))
        self.rect = self.image.get_rect()
        
        # Ghost properties - Make ghost slower in higher levels
        self.base_speed = 2.0
        # Decrease speed for each level instead of increasing
        self.level_speed_multiplier = -0.25  # Changed from 0.4 to -0.25
        # Set minimum speed to prevent ghost from becoming too slow
        self.speed = max(0.8, self.base_speed + (level * self.level_speed_multiplier))
        self.player = player
        
        # Decrease visibility range in higher levels
        self.visibility_range = max(400, 600 - (level * 50))  # Starts at 600, decreases by 50 each level
        
        # Set initial position
        self.spawn_position(screen_width, screen_height)
        
        # Floating movement properties
        self.float_offset = 0
        self.float_speed = 0.05
        self.float_amplitude = 8
        self.true_x = float(self.rect.x)
        self.true_y = float(self.rect.y)
        
        # Transparency properties - Make ghost more transparent in higher levels
        self.min_alpha = max(80, 120 - (level * 10))  # Starts at 120, decreases by 10 each level
        
        # Pulsing effect
        self.pulse_counter = 0
        self.pulse_speed = 0.05
        self.pulse_range = max(20, 40 - (level * 5))  # Reduced pulsing range in higher levels

    def spawn_position(self, screen_width, screen_height):
        """Spawn ghost at the farthest point from player"""
        corners = [
            (0, 0),
            (screen_width - self.rect.width, 0),
            (0, screen_height - self.rect.height),
            (screen_width - self.rect.width, screen_height - self.rect.height)
        ]
        
        max_distance = 0
        spawn_pos = corners[0]
        
        for corner in corners:
            distance = math.sqrt(
                (corner[0] - self.player.rect.x) ** 2 + 
                (corner[1] - self.player.rect.y) ** 2
            )
            if distance > max_distance:
                max_distance = distance
                spawn_pos = corner
        
        self.rect.x = spawn_pos[0]
        self.rect.y = spawn_pos[1]
        self.true_x = float(self.rect.x)
        self.true_y = float(self.rect.y)

    def update(self):
        if not movement_enabled or camera.door_zoom:
            return
            
        # Calculate direction to player
        dx = self.player.rect.centerx - self.rect.centerx
        dy = self.player.rect.centery - self.rect.centery
        
        # Normalize the direction
        distance = math.sqrt(dx ** 2 + dy ** 2)
        if distance > 0:
            dx = dx / distance
            dy = dy / distance
        
        # Update position with adjusted tracking
        distance_factor = min(1.0, distance / self.visibility_range)  # Reduced from 1.5 to 1.0
        actual_speed = self.speed * distance_factor
        
        self.true_x += dx * actual_speed
        self.true_y += dy * actual_speed
        
        # Add floating movement
        self.float_offset += self.float_speed
        float_y = math.sin(self.float_offset) * self.float_amplitude
        
        # Update rect position
        self.rect.x = int(self.true_x)
        self.rect.y = int(self.true_y + float_y)
        
        # Update pulsing effect
        self.pulse_counter += self.pulse_speed
        pulse_alpha = math.sin(self.pulse_counter) * self.pulse_range
        
        # Calculate alpha with reduced visibility range
        current_distance = math.sqrt(
            (self.player.rect.centerx - self.rect.centerx) ** 2 + 
            (self.player.rect.centery - self.rect.centery) ** 2
        )
        
        # Calculate alpha with pulsing effect
        base_alpha = max(self.min_alpha, min(255, (1 - current_distance / self.visibility_range) * 255))
        final_alpha = min(255, max(self.min_alpha, base_alpha + pulse_alpha))
        
        # Apply alpha
        self.image.set_alpha(int(final_alpha))

    def check_collision(self, player):
        """Check for collision with player using a larger collision margin in higher levels"""
        # Increase collision margin for higher levels to make it more forgiving
        collision_margin = 8 + (current_level * 2)  # Increases by 2 pixels per level
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)
    
def check_level_timer(elapsed_time, time_limit):
    """Check if the level time limit has been exceeded"""
    return elapsed_time >= time_limit

class Camera:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.scroll_x = 0
        self.scroll_y = 0
        self.zoom = 1
        self.target_zoom = 1
        self.base_zoom = 2.5
        self.zoom_out_level = 1.3
        self.zoom_speed = 0.04
        self.transitioning = False
        self.transition_start_time = 0
        self.transition_delay = 2000
        self.transition_duration = 2000
        self.transition_total_time = self.transition_delay + self.transition_duration
        self.transition_complete = False
        self.manual_zoom_active = False
        self.initial_zoom_done = False
        
        # Door zoom properties
        self.door_zoom = False
        self.door_zoom_target = None
        self.door_zoom_speed = 0.02
        self.door_target_zoom = 3.5
        self.door_transition_start = 0
        self.door_transition_duration = 1500
        self.post_open_delay = 1000
        self.door_opened_time = 0
        self.reset_on_death = False
        self.death_reset_time = 0
        self.death_reset_duration = 1000  # 1 second for reset animation
        
        # Sound properties
        self.wind_sound = pygame.mixer.Sound('img/Gust of Wind.mp3')
        self.jungle_music = pygame.mixer.Sound('img/Background Music.MP3')
        self.zoom_out_sound = pygame.mixer.Sound('img/zoom_out.mp3')  # Add this line
        self.wind_sound.set_volume(0.8)
        self.jungle_music.set_volume(0.4)
        self.zoom_out_sound.set_volume(0.5)  # Add this line
        self.wind_sound_playing = False
        self.jungle_music_playing = False
        self.wind_sound_start_time = 0
        self.wind_sound_duration = int(self.wind_sound.get_length() * 1000)
        
        self.visible_width = width
        self.visible_height = height

    def apply(self, surface, entity):
        scaled_rect = scale_rect(entity.rect)
        return pygame.Rect(
            scaled_rect.x - self.scroll_x,
            scaled_rect.y - self.scroll_y,
            scaled_rect.width,
            scaled_rect.height
        )

    def apply_sprite(self, surface, sprite):
        scaled_pos = scale_position(
            sprite.rect.x - self.scroll_x,
            sprite.rect.y - self.scroll_y
        )
        return scaled_pos

    def reset_zoom(self):
        """Reset camera zoom when player dies"""
        self.reset_on_death = True
        self.death_reset_time = pygame.time.get_ticks()
        self.zoom = self.base_zoom
        self.target_zoom = self.base_zoom
        self.manual_zoom_active = False
        self.door_zoom = False
        self.door_zoom_target = None
        self.transitioning = False
        self.initial_zoom_done = True

    def start_door_zoom(self, door):
        if not self.door_zoom and not self.manual_zoom_active:
            self.door_zoom = True
            self.door_zoom_target = door
            self.door_transition_start = pygame.time.get_ticks()
            self.door_target_zoom = 3.5
            # All entities will freeze due to the door_zoom check in their update methods
        
    def start_transition(self):
        # Stop any existing sounds before starting new ones
        self.stop_sounds()
        self.transitioning = True
        self.transition_complete = False
        self.zoom = 1
        self.transition_start_time = pygame.time.get_ticks()
        
        # Start wind sound and track its start time
        self.wind_sound.play()
        self.wind_sound_playing = True
        self.wind_sound_start_time = pygame.time.get_ticks()
        self.jungle_music_playing = False
    
    def update(self, target, keys_collected, door, required_keys):
        current_time = pygame.time.get_ticks()
        
        # Handle manual zoom control with Enter key
        keys = pygame.key.get_pressed()
        if keys[pygame.K_RETURN]:
            self.manual_zoom_active = True
            self.target_zoom = self.zoom_out_level
            self.zoom_out_sound.play()
        elif self.manual_zoom_active:
            self.manual_zoom_active = False
            self.target_zoom = self.base_zoom if self.transition_complete else 1
        
        # Handle initial transition
        if self.transitioning and not self.initial_zoom_done:
            elapsed = current_time - self.transition_start_time
            
            if elapsed >= self.transition_delay:
                zoom_elapsed = elapsed - self.transition_delay
                progress = min(zoom_elapsed / self.transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                if not self.manual_zoom_active:
                    self.zoom = 1 + (self.base_zoom - 1) * progress
                
                if progress >= 1:
                    self.transitioning = False
                    self.transition_complete = True
                    self.initial_zoom_done = True
                    global movement_enabled, game_start_time
                    movement_enabled = True
                    
                    # Only start the timer when the initial zoom is complete
                    if game_start_time is None:
                        game_start_time = time.time()
                    
                    if not self.manual_zoom_active:
                        self.zoom = self.base_zoom
                        self.target_zoom = self.base_zoom
        
        # Handle smooth zoom transition
        elif not self.door_zoom:
            if self.zoom != self.target_zoom:
                diff = self.target_zoom - self.zoom
                self.zoom += diff * self.zoom_speed
        
        # Handle door zoom if active
        if self.door_zoom and self.door_zoom_target:
            elapsed = current_time - self.door_transition_start
            
            if not self.door_zoom_target.is_open:
                progress = min(elapsed / self.door_transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                self.zoom = 1 + (self.door_target_zoom - 1) * progress
                
                # Calculate center position for the door
                target_x = self.door_zoom_target.rect.centerx - (SCREEN_WIDTH // (2 * self.zoom))
                target_y = self.door_zoom_target.rect.centery - (SCREEN_HEIGHT // (2 * self.zoom))
                
                # Smoothly move camera to center the door
                self.scroll_x += (target_x - self.scroll_x) * 0.1
                self.scroll_y += (target_y - self.scroll_y) * 0.1
                
                if progress >= 1.0:
                    self.door_zoom_target.open_door()
                    self.door_opened_time = current_time
            else:
                hold_time = current_time - self.door_opened_time
                if hold_time >= self.post_open_delay:
                    zoom_out_progress = min((hold_time - self.post_open_delay) / 1000, 1.0)
                    zoom_out_progress = self.ease_out_cubic(zoom_out_progress)
                    
                    target_zoom = self.target_zoom
                    self.zoom = self.door_target_zoom - (self.door_target_zoom - target_zoom) * zoom_out_progress
                    
                    if zoom_out_progress >= 1.0:
                        self.door_zoom = False
                        self.zoom = target_zoom
        
        # Handle death reset
        if self.reset_on_death:
            elapsed = current_time - self.death_reset_time
            if elapsed <= self.death_reset_duration:
                # Smoothly transition zoom back to base level
                progress = elapsed / self.death_reset_duration
                progress = self.ease_out_cubic(progress)
                self.zoom = 1 + (self.base_zoom - 1) * progress
            else:
                self.reset_on_death = False
                self.zoom = self.base_zoom
                self.target_zoom = self.base_zoom
        
        # Update sound behavior
        if (self.wind_sound_playing and 
            current_time - self.wind_sound_start_time >= self.wind_sound_duration and 
            not self.jungle_music_playing):
            self.wind_sound_playing = False
            self.jungle_music.play()
            self.jungle_music_playing = True
        
        # Update visible area and camera position
        self.visible_width = self.width // self.zoom
        self.visible_height = self.height // self.zoom
        
        # Normal camera follow behavior when not zooming to door
        if not self.door_zoom:
            target_x = target.rect.centerx - self.visible_width // 2
            target_y = target.rect.centery - self.visible_height // 2
            
            self.scroll_x += (target_x - self.scroll_x) * 0.1
            self.scroll_y += (target_y - self.scroll_y) * 0.1
        
        # Keep the camera within bounds
        self.scroll_x = max(0, min(self.scroll_x, SCREEN_WIDTH - self.visible_width))
        self.scroll_y = max(0, min(self.scroll_y, SCREEN_HEIGHT - self.visible_height))
    
    def stop_sounds(self):
        """Stop all sounds and reset sound states"""
        try:
            if pygame.mixer.get_init():  # Check if mixer is initialized
                self.wind_sound.stop()
                self.jungle_music.stop()
                self.zoom_out_sound.stop()  # Add this line
        except (AttributeError, pygame.error):
            pass
        self.wind_sound_playing = False
        self.jungle_music_playing = False

        
    # Update the Camera class cleanup method:
    def cleanup(self):
        """Clean up all audio resources and reset camera state"""
        self.stop_sounds()
        self.transitioning = False
        self.transition_complete = False
        self.zoom = 1
        self.wind_sound_start_time = 0
        self.door_zoom = False
        self.door_zoom_target = None
        
    def __del__(self):
        """Destructor to ensure sounds are stopped when the camera object is destroyed"""
        try:
            self.stop_sounds()
        except:
            pass  # Ignore any errors during cleanup

    def ease_out_cubic(self, x):
        return 1 - pow(1 - x, 3)

    def apply(self, surface, entity):
        return pygame.Rect(
            entity.rect.x - self.scroll_x,
            entity.rect.y - self.scroll_y,
            entity.rect.width,
            entity.rect.height
        )

    def apply_sprite(self, surface, sprite):
        # Return the position where the sprite should be drawn
        return (sprite.rect.x - self.scroll_x,
                sprite.rect.y - self.scroll_y)
                
    def apply_rect(self, rect):
        # Apply camera offset to a rect
        return pygame.Rect(
            rect.x - self.scroll_x,
            rect.y - self.scroll_y,
            rect.width,
            rect.height
        )

def reset_level():
    """Properly reset the level state"""
    global game_over, keys_collected, movement_enabled, game_start_time
    global player, world, moving_enemies, keys_group, door, ghost, camera

    # Reset game state
    game_over = 0
    keys_collected = 0
    movement_enabled = False
    game_start_time = None

    # Stop all sounds
    if hasattr(player, 'stop_sounds'):
        player.stop_sounds()
    if hasattr(camera, 'stop_sounds'):
        camera.stop_sounds()

    # Cleanup camera
    camera.cleanup()
    camera.reset_zoom()

    # Initialize level data
    platforms = LEVEL_PLATFORM_DATA[current_level]
    deadly_tiles = LEVEL_DEADLY_DATA[current_level]
    enemy_data = LEVEL_ENEMY_DATA[current_level]

    # Create world
    world = World(platforms, deadly_tiles)

    # Find spawn position
    spawn_pos = find_spawn_position(platforms)

    # Create new player at spawn position
    player = Player(spawn_pos[0], spawn_pos[1])

    # Create ghost
    ghost = Ghost(SCREEN_WIDTH, SCREEN_HEIGHT, player, current_level)

    # Set up door
    door_pos = find_door_position(platforms)
    door = Door(door_pos[0], door_pos[1])

    # Generate and place keys
    keys_group = pygame.sprite.Group()
    key_positions = generate_key_positions(current_level)
    for pos in key_positions:
        keys_group.add(Key(pos[0], pos[1]))

    # Create enemies
    moving_enemies = pygame.sprite.Group()
    for enemy_info in enemy_data:
        x, y, direction, boundary_start, boundary_end = enemy_info
        enemy = MovingEnemy(x * TILE_SIZE, y * TILE_SIZE, direction, boundary_start, boundary_end)
        moving_enemies.add(enemy)

    camera.start_transition()
    return True

def generate_key_positions(level):
    """Improved key position generation with better boundary checking"""
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    
    # Screen boundaries with margin
    MARGIN = TILE_SIZE * 2
    screen_bounds = {
        'left': MARGIN,
        'right': SCREEN_WIDTH - MARGIN,
        'top': MARGIN,
        'bottom': SCREEN_HEIGHT - MARGIN
    }
    
    def is_within_bounds(x, y):
        """Check if position is within screen bounds"""
        return (screen_bounds['left'] <= x <= screen_bounds['right'] and
                screen_bounds['top'] <= y <= screen_bounds['bottom'])
    
    # Get viable platform positions
    viable_platforms = []
    for plat in platforms:
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip ground level platforms
        if y < SCREEN_HEIGHT * 0.8:
            # Adjust platform boundaries to ensure keys stay within screen
            plat_left = max(x + MARGIN, screen_bounds['left'])
            plat_right = min(x + width - MARGIN, screen_bounds['right'])
            
            if plat_right > plat_left:  # Only add if there's valid space
                viable_platforms.append((plat_left, y, plat_right - plat_left))
    
    import random
    random.shuffle(viable_platforms)
    
    # Keep trying until we have all required keys
    attempts = 0
    max_attempts = required_keys * 10  # Generous attempt limit
    
    while len(positions) < required_keys and attempts < max_attempts:
        if not viable_platforms:
            break
            
        plat = random.choice(viable_platforms)
        
        # Generate position on platform
        key_x = random.uniform(plat[0], plat[0] + plat[2])
        key_y = plat[1] - TILE_SIZE * 1.5  # Place above platform
        
        # Verify position is within bounds
        if is_within_bounds(key_x, key_y):
            positions.append((key_x, key_y))
        
        attempts += 1
    
    # If we still need more keys, place them on the most suitable platforms
    while len(positions) < required_keys:
        if not viable_platforms:
            break
            
        # Use the widest platform available
        plat = max(viable_platforms, key=lambda p: p[2])
        
        # Calculate safe position
        key_x = plat[0] + (plat[2] / 2)  # Center of platform
        key_y = plat[1] - TILE_SIZE * 1.5
        
        if is_within_bounds(key_x, key_y):
            positions.append((key_x, key_y))
        viable_platforms.remove(plat)
    
    return positions

# Update the video background handling code
def update_video_background(level):
    """Update video frame for video backgrounds"""
    if level in video_captures and video_captures[level] is not None:
        ret, frame = video_captures[level].read()
        if not ret:
            # Reset video to beginning if we've reached the end
            video_captures[level].set(cv2.CAP_PROP_POS_FRAMES, 0)
            ret, frame = video_captures[level].read()
        
        if ret:
            # Convert frame from BGR to RGB and flip to match Pygame's format
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame = cv2.resize(frame, (SCREEN_WIDTH, SCREEN_HEIGHT))
            frame = np.rot90(frame)
            frame = np.flipud(frame)
            frame = pygame.surfarray.make_surface(frame)
            return frame
    return None

# Update the initialization of video captures
# Initialize game assets
def init_game():
    """Initialize video captures and background surfaces"""
    global video_captures, background_surfaces, game_stats, pause_menu
    update_scale_factors()  # Update scaling factors
    video_captures = {}
    background_surfaces = {}
    # Update this line to use EnhancedGameStats instead of GameStats
    game_stats = EnhancedGameStats(screen)
    pause_menu = PauseMenu(screen)
    
    for level, bg_data in level_backgrounds.items():
        if bg_data['type'] == 'video':
            try:
                cap = cv2.VideoCapture(bg_data['path'])
                if not cap.isOpened():
                    print(f"Failed to open video file for level {level}")
                    cap = None
                video_captures[level] = cap
            except Exception as e:
                print(f"Error loading video for level {level}: {e}")
                video_captures[level] = None
        else:
            try:
                img = pygame.image.load(bg_data['path']).convert()
                background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
            except Exception as e:
                print(f"Error loading image for level {level}: {e}")
                fallback = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
                fallback.fill((0, 0, 0))
                background_surfaces[level] = fallback

def get_background(level):
    """Get the current background surface for the given level"""
    if level_backgrounds[level]['type'] == 'video':
        return update_video_background(level)
    else:
        return background_surfaces[level]

# Update the cleanup function
def cleanup_backgrounds():
    """Release all video captures properly"""
    global video_captures
    if 'video_captures' in globals():
        for cap in video_captures.values():
            if cap is not None:
                cap.release()
        video_captures.clear()


def create_zoomed_view(screen, camera, player, world, keys_group, door, moving_enemies, ghost):
    current_visible_width = int(SCREEN_WIDTH // camera.zoom)
    current_visible_height = int(SCREEN_HEIGHT // camera.zoom)
    
    view_surface = pygame.Surface((current_visible_width, current_visible_height))
    
    # Get and draw the current background
    current_background = get_background(current_level)
    if current_background:
        view_surface.blit(current_background, (-camera.scroll_x, -camera.scroll_y))
    
    # Draw platforms (if you want them visible)
    # for tile in world.collision_tiles:
    #     pygame.draw.rect(view_surface, (255, 0, 0), camera.apply_rect(tile.rect), 1)
    
    # Draw keys
    for key in keys_group:
        pos = camera.apply_sprite(view_surface, key)
        if (0 <= pos[0] < current_visible_width and 
            0 <= pos[1] < current_visible_height):
            view_surface.blit(key.image, pos)
    
    # Draw door
    door_pos = camera.apply_sprite(view_surface, door)
    if (0 <= door_pos[0] < current_visible_width and 
        0 <= door_pos[1] < current_visible_height):
        view_surface.blit(door.image, door_pos)
    
    # Draw moving enemies
    for enemy in moving_enemies:
        enemy_pos = camera.apply_sprite(view_surface, enemy)
        if (0 <= enemy_pos[0] < current_visible_width and 
            0 <= enemy_pos[1] < current_visible_height):
            view_surface.blit(enemy.image, enemy_pos)
    
    # Draw ghost
    ghost_pos = camera.apply_sprite(view_surface, ghost)
    if (0 <= ghost_pos[0] < current_visible_width and 
        0 <= ghost_pos[1] < current_visible_height):
        view_surface.blit(ghost.image, ghost_pos)
    
    # Draw player last
    player_pos = camera.apply_sprite(view_surface, player)
    if (0 <= player_pos[0] < current_visible_width and 
        0 <= player_pos[1] < current_visible_height):
        view_surface.blit(player.image, player_pos)
    
    # Scale and draw the final view
    scaled_surface = pygame.transform.scale(view_surface, (SCREEN_WIDTH, SCREEN_HEIGHT))
    screen.blit(scaled_surface, (0, 0))
    
    """"
    # Draw HUD elements
    draw_text(f"Level {current_level}", 40, WHITE, 10, 10)
    draw_text(f"Keys: {keys_collected}/{LEVEL_REQUIREMENTS[current_level]}", 40, WHITE, 10, 60)
    """
    
class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Key(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.frames = key_frames  # Use the key_frames list we created earlier
        
        # Animation variables
        self.current_frame = 0
        self.animation_timer = 0
        self.animation_delay = 100  # Milliseconds between frame changes
        
        # Set initial image
        self.image = self.frames[self.current_frame] if self.frames else key_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        
        # Floating movement variables
        self.original_y = float(y)
        self.float_offset = 0
        self.float_speed = 0.03  # Slightly slower float speed
        
    def update(self):
        if self.frames:  # Only animate if we have frames
            # Update animation frame
            current_time = pygame.time.get_ticks()
            if current_time - self.animation_timer > self.animation_delay:
                self.animation_timer = current_time
                self.current_frame = (self.current_frame + 1) % len(self.frames)
                self.image = self.frames[self.current_frame]
        
        # Update floating movement with reduced amplitude (changed from 15 to 5)
        self.float_offset += self.float_speed
        self.rect.y = self.original_y + math.sin(self.float_offset) * 5  # Reduced from 15 to 5

# In the Door class, update the open_door method to handle the image transition properly:
class Door:
    def __init__(self, x, y):
        super().__init__()
        try:
            # Load closed portal image (using underscore instead of space)
            self.closed_image = pygame.image.load('img/closed_portal.png')
            self.closed_image = pygame.transform.scale(self.closed_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            
            # Load portal animation frames
            self.portal_frames = []
            for i in range(1, 6):
                frame = pygame.image.load(f'img/portal_frame_{i}.png')
                frame = pygame.transform.scale(frame, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
                self.portal_frames.append(frame)
                
        except FileNotFoundError as e:
            print(f"Error loading portal images: {e}")
            print("Falling back to default door images...")
            # Fallback to original door images if portal images aren't found
            self.closed_image = pygame.image.load('img/closeddoor.PNG')
            self.closed_image = pygame.transform.scale(self.closed_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            # Create a simple animation using the open door image
            self.portal_frames = []
            open_image = pygame.image.load('img/opendoor_img.PNG')
            open_image = pygame.transform.scale(open_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            self.portal_frames = [open_image] * 5  # Create 5 copies of the open door image
        
        # Animation properties
        self.current_frame = 0
        self.animation_timer = 0
        self.animation_delay = 50  # Milliseconds between frame changes
        self.is_animating = False
        
        # Initial setup
        self.image = self.closed_image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.is_open = False
        self.door_sound = pygame.mixer.Sound('img/electric_zap.MP3')
        self.door_sound.set_volume(0.5)
        self.sound_played = False
        self.collision_enabled = True
        self.entered = False

    def update(self):
        if self.is_animating:
            current_time = pygame.time.get_ticks()
            
            # Update animation frame
            if current_time - self.animation_timer > self.animation_delay:
                self.animation_timer = current_time
                self.current_frame = (self.current_frame + 1) % len(self.portal_frames)
                self.image = self.portal_frames[self.current_frame]

    def open_door(self):
        if not self.is_open:
            self.is_open = True
            self.is_animating = True
            self.collision_enabled = False
            self.animation_timer = pygame.time.get_ticks()
            if not self.sound_played:
                self.door_sound.play()
                self.sound_played = True

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.6), int(TILE_SIZE * 1.6))  # Doubled the size from TILE_SIZE * 1
        
        # Load animations
        for i in range(1, 5):
            img = pygame.image.load(f'img/MainC{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        # Load sound effects
        self.walking_sound = pygame.mixer.Sound('img/Character Walking.MP3')
        self.walking_sound.set_volume(0.5)
        self.is_walking_sound_playing = False
        
        self.key_collect_sound = pygame.mixer.Sound('img/key_collect.mp3')
        self.key_collect_sound.set_volume(0.4)
        
        self.falling_sound = pygame.mixer.Sound('img/falling_character.mp3')
        self.falling_sound.set_volume(2)
        self.is_falling_sound_playing = False
        self.falling_threshold = 10
        self.falling_counter = 0
        
        self.dead = False  # Add this flag
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, (int(TILE_SIZE * 1.6), int(TILE_SIZE * 1.6)))
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

        self.image = self.animations_right[0]
        self.stop_sounds()
        spawn_pos = find_spawn_position(LEVEL_PLATFORM_DATA[current_level])
        self.rect.x = spawn_pos[0]
        self.rect.y = spawn_pos[1]


    def stop_sounds(self):
        """Stop all player sounds"""
        if self.is_walking_sound_playing:
            self.walking_sound.stop()
            self.is_walking_sound_playing = False
        if self.is_falling_sound_playing:
            self.falling_sound.stop()
            self.is_falling_sound_playing = False

    def cleanup(self):
        """Clean up player resources"""
        self.stop_sounds()
        self.is_walking_sound_playing = False
        self.is_falling_sound_playing = False
        self.falling_counter = 0

    def __del__(self):
        """Ensure sounds are stopped when player object is destroyed"""
        self.stop_sounds()

    def update(self, game_over, world, keys_group, camera):
        global keys_collected
        dx = 0
        dy = 0
        walk_cooldown = 12

        # Check for game over state
        if game_over == -1:
            if not self.dead:
                self.dead = True
                self.image = self.dead_image
                game_over_fx.play()
                self.stop_sounds()  # Stop all player sounds when dying
              # Don't process movement if not enabled or during door zoom

            draw_text('GAME OVER!', 70, BLUE, (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
            if restart_button.draw(screen):

                # Reset death state
                self.dead = False
                self.image = self.animations_right[self.index]  # Reset to normal image
                # Rest of reset code...
                # Reset necessary variables
                game_over = 0
                keys_collected = 0
                
                # Stop any ongoing sounds
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                    
                # Reset camera state
                camera.cleanup()
                camera.reset_zoom()
                camera.start_transition()
                
                # Reset the timer when the player restarts
                global game_start_time
                game_start_time = time.time()  # Set the timer to the current time
                
                # Reinitialize game assets
                init_game()  # Call the init_game function to reset game assets

        if not movement_enabled or camera.door_zoom:
            self.stop_sounds()  # Stop sounds when movement is disabled
            self.vel_y = 0  # Reset vertical velocity

        if self.dead:
            return game_over  
        
        if not movement_enabled or camera.door_zoom:
            return game_over
        # Reset death handling flag when game is restarted
        self._death_handled = False
        
        # Normal movement code here
        if camera.transition_complete:
            key = pygame.key.get_pressed()
            
            # Handle walking sound
            is_moving = False
            
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
                # Reset falling counter when jumping
                self.falling_counter = 0
                if self.is_falling_sound_playing:
                    self.falling_sound.stop()
                    self.is_falling_sound_playing = False
            
            if not key[pygame.K_SPACE]:
                self.jumped = False

            # Check for movement keys and play sound
            if key[pygame.K_LEFT] or key[pygame.K_a]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
                is_moving = True
            if key[pygame.K_RIGHT] or key[pygame.K_d]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
                is_moving = True
            
            # Handle walking sound
            if is_moving and not self.in_air and not self.is_walking_sound_playing:
                self.walking_sound.play(-1)
                self.is_walking_sound_playing = True
            elif (not is_moving or self.in_air) and self.is_walking_sound_playing:
                self.walking_sound.stop()
                self.is_walking_sound_playing = False

            if not (key[pygame.K_LEFT] or key[pygame.K_RIGHT] or key[pygame.K_a] or key[pygame.K_d]):
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

        # Always apply gravity regardless of camera state
        self.vel_y += GRAVITY
        if self.vel_y > 10:
            self.vel_y = 10
        dy += self.vel_y

        if not movement_enabled or camera.door_zoom:
            return game_over
        
        # Handle falling sound
        if self.in_air and self.vel_y > 0:  # If falling
            self.falling_counter += 1
            if self.falling_counter >= self.falling_threshold and not self.is_falling_sound_playing:
                self.falling_sound.play()
                self.is_falling_sound_playing = True
        elif not self.in_air:  # When landing
            self.falling_counter = 0
            if self.is_falling_sound_playing:
                self.falling_sound.stop()
                self.is_falling_sound_playing = False

        # Check for collision with keys
        key_hits = pygame.sprite.spritecollide(self, keys_group, True)
        if key_hits:
            self.key_collect_sound.play()
            keys_collected += len(key_hits)

        # Assume we're in the air unless collision detection proves otherwise
        self.in_air = True

        # Check for collision
        result = world.check_collision(self, dx, dy)
        if result == "deadly":
            return -1  # Return game over state
        else:
            dx, dy = result

        # Update player position
        self.rect.x += dx
        self.rect.y += dy

        # Keep player on screen
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH:
            self.rect.right = SCREEN_WIDTH
            
        # Check if player has fallen off the map
        if self.rect.top > SCREEN_HEIGHT:
            return -1  # Return game over state
            
        return game_over

class World:
    def __init__(self, level_data, deadly_data):
        self.collision_tiles = []
        self.deadly_tiles = []
        self.blue_tiles = []  # Initialize blue_tiles list

        # Create collision tiles
        for plat in level_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            
            offset_x = 0
            offset_y = 0
            
            collision_rect = pygame.Rect(
                x + offset_x,
                y + offset_y,
                width,
                height
            )
            self.collision_tiles.append(CollisionTile(x + offset_x, y + offset_y, width, height))

        # Create deadly tiles
        for deadly in deadly_data:
            x = deadly[0] * TILE_SIZE
            y = deadly[1] * TILE_SIZE
            width = deadly[2] * TILE_SIZE
            height = int(deadly[3] * TILE_SIZE)
            
            self.deadly_tiles.append(CollisionTile(x, y, width, height))

        # Create blue tiles
        if current_level in LEVEL_BLUE_DATA:
            for blue in LEVEL_BLUE_DATA[current_level]:
                x = blue[0] * TILE_SIZE
                y = blue[1] * TILE_SIZE
                width = blue[2] * TILE_SIZE
                height = int(blue[3] * TILE_SIZE)
                
                self.blue_tiles.append(CollisionTile(x, y, width, height))

                '''    def draw(self, screen):
                        # Draw regular collision tiles in red
                        for tile in self.collision_tiles:
                            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)
                        
                        # Draw deadly tiles in green
                        for tile in self.deadly_tiles:
                            pygame.draw.rect(screen, (0, 255, 0), tile.rect, 2)
                        
                        # Draw blue tiles in blue
                        for tile in self.blue_tiles:
                            pygame.draw.rect(screen, (0, 0, 255), tile.rect, 1)'''

    def check_collision(self, player, dx, dy):
        # Check collision with both regular and blue tiles
        for tile in self.collision_tiles + self.blue_tiles:
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False
                    
        # Check deadly collisions
        for tile in self.deadly_tiles:
            if tile.rect.colliderect(player.rect):
                return "deadly"
                
        return dx, dy

def init_level(level_num):
    """Initialize a new level with all required components"""
    global keys_collected, game_start_time, current_level, player, camera
    global ghost, movement_enabled, total_pause_time
    
    try:
        # Reset level state
        keys_collected = 0
        current_level = level_num
        game_start_time = None  # Reset timer - will be started after transition
        total_pause_time = timedelta(0)
        movement_enabled = False
        
        # Stop all existing sounds
        if 'player' in globals() and player is not None:
            player.stop_sounds()
        if 'camera' in globals() and camera is not None:
            camera.stop_sounds()
        
        # Clean up existing camera if it exists
        if 'camera' in globals() and camera is not None:
            camera.cleanup()
        
        # Load level data
        platforms = LEVEL_PLATFORM_DATA.get(level_num, [])
        if not platforms:
            raise ValueError(f"No platform data found for level {level_num}")
            
        deadly_tiles = LEVEL_DEADLY_DATA.get(level_num, [])
        enemy_data = LEVEL_ENEMY_DATA.get(level_num, [])
        
        # Create world
        world = World(platforms, deadly_tiles)
        
        # Calculate spawn position
        spawn_pos = find_spawn_position(platforms)
        
        # Create player
        player = Player(spawn_pos[0], spawn_pos[1])
        
        # Create ghost with appropriate level difficulty
        ghost = Ghost(SCREEN_WIDTH, SCREEN_HEIGHT, player, level_num)
        
        # Set up door
        door_pos = find_door_position(platforms)
        door = Door(door_pos[0], door_pos[1])
        
        # Generate and place keys
        keys_group = pygame.sprite.Group()
        key_positions = generate_key_positions(level_num)
        for pos in key_positions:
            adjusted_y = pos[1] + TILE_SIZE - 20
            keys_group.add(Key(pos[0], adjusted_y))
            
        # Create enemies
        moving_enemies = pygame.sprite.Group()
        for enemy_info in enemy_data:
            x, y, direction, boundary_start, boundary_end = enemy_info
            enemy = MovingEnemy(x * TILE_SIZE, y * TILE_SIZE, direction, boundary_start, boundary_end)
            moving_enemies.add(enemy)
            
        # Reset camera
        camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
        camera.transitioning = False
        camera.transition_complete = False
        camera.manual_zoom_active = False
        camera.door_zoom = False
        camera.door_zoom_target = None
        camera.reset_on_death = False
        
        print(f"Level {level_num} initialized successfully")
        return keys_group, door, world, moving_enemies, player, ghost
        
    except Exception as e:
        import traceback
        print(f"\nError initializing level {level_num}:")
        print(f"Error type: {type(e).__name__}")
        print(f"Error message: {str(e)}")
        print("Traceback:")
        traceback.print_exc()
        return None, None, None, None, None, None


class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2)))
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.direction = direction
        self.speed = 1.2
        self.moving_right = True
        self.moving_down = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE
        self.initial_pos = self.rect.x if direction == "horizontal" else self.rect.y


    def update(self):
        if not movement_enabled or camera.door_zoom:
            return
            
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)

    def draw_boundaries(self, screen):
        # Draw movement boundaries (for debugging)
        if self.direction == "horizontal":
            pygame.draw.line(screen, (255, 0, 0),
                           (self.boundary_start, self.rect.centery),
                           (self.boundary_end, self.rect.centery), 2)
        else:
            pygame.draw.line(screen, (255, 0, 0),
                           (self.rect.centerx, self.boundary_start),
                           (self.rect.centerx, self.boundary_end), 2)

    def check_collision(self, player):
        # Create a slightly smaller collision rect for more forgiving collisions
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button:
    def __init__(self, x, y, image):
        self.original_image = image
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = int(x * SCALE_X)
        self.rect.y = int(y * SCALE_Y)
        self.clicked = False
        
        # Scale image if needed
        if SCALE_X != 1.0 or SCALE_Y != 1.0:
            new_size = (int(self.rect.width * SCALE_X), int(self.rect.height * SCALE_Y))
            self.image = pygame.transform.scale(self.original_image, new_size)
            self.rect = self.image.get_rect(x=self.rect.x, y=self.rect.y)

    def draw(self, screen):
        action = False
        # Get mouse position
        pos = pygame.mouse.get_pos()  # This gets the (x, y) position of the mouse

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and not self.clicked:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font_size, color, x, y):
    font = pygame.font.SysFont('Bauhaus 93', font_size)
    img = font.render(text, True, color)
    screen.blit(img, (x, y))

def find_suitable_platform(platforms):
    """
    Find a suitable platform for door placement using better criteria:
    1. Platform must be wide enough for door and NPC
    2. Platform should be reasonably high up but not necessarily the highest
    3. Platform should have enough space above it
    """
    # Sort platforms by height (y-coordinate), from top to bottom
    sorted_platforms = sorted(platforms, key=lambda p: p[1])
    
    # Required width for door and NPC (in tile units)
    required_width = 4  # Space for door and NPC
    
    # Check top 1/3 of platforms for a suitable spot
    top_third = len(sorted_platforms) // 3
    if top_third < 1:
        top_third = 1
    
    for platform in sorted_platforms[:top_third]:
        # Get platform dimensions
        x, y, width, height = platform
        
        # Check if platform is wide enough
        if width >= required_width:
            # Check if there's another platform directly above
            has_obstruction = False
            platform_top = y
            platform_left = x
            platform_right = x + width
            
            # Check for obstructions above
            for other_platform in platforms:
                other_x, other_y, other_width, other_height = other_platform
                other_left = other_x
                other_right = other_x + other_width
                other_bottom = other_y + other_height
                
                # Check if there's a platform directly above
                if (other_bottom > platform_top - 4 and  # Leave space for door height
                    other_y < platform_top and
                    other_right > platform_left and
                    other_left < platform_right):
                    has_obstruction = True
                    break
            
            if not has_obstruction:
                return platform
                
    # Fallback to the widest platform in the top half if no perfect match
    top_half = sorted_platforms[:len(sorted_platforms)//2]
    widest_platform = max(top_half, key=lambda p: p[2])
    return widest_platform

def find_spawn_position(platforms):
    """Find a safe spawn position on the leftmost ground platform"""
    # Filter for ground-level platforms (in the bottom third of the screen)
    ground_platforms = []
    screen_bottom_third = (SCREEN_HEIGHT / TILE_SIZE) * 2/3
    
    for platform in platforms:
        if platform[1] > screen_bottom_third:
            ground_platforms.append(platform)
    
    if not ground_platforms:
        # Fallback to the lowest platform if no ground platforms found
        lowest_platform = max(platforms, key=lambda p: p[1])
        spawn_x = (lowest_platform[0] + 1) * TILE_SIZE
        spawn_y = lowest_platform[1] * TILE_SIZE - TILE_SIZE * 1.6  # Adjust to be exactly on platform
        return (spawn_x, spawn_y)
    
    # Find leftmost ground platform
    leftmost = min(ground_platforms, key=lambda p: p[0])
    
    # Position player exactly on top of the platform
    spawn_x = (leftmost[0] + 1) * TILE_SIZE
    spawn_y = leftmost[1] * TILE_SIZE - TILE_SIZE * 1.6  # Adjust for player height
    
    return (spawn_x, spawn_y)

def find_door_position(platforms):
    """Find an appropriate position for the door"""
    # Find a suitable platform (high up but accessible)
    suitable_platform = find_suitable_platform(platforms)
    
    # Position door near the right edge of the platform
    door_x = (suitable_platform[0] + suitable_platform[2] - 2) * TILE_SIZE
    door_y = (suitable_platform[1] - 2) * TILE_SIZE
    
    # Ensure door doesn't go off screen
    if door_x > SCREEN_WIDTH - 3 * TILE_SIZE:
        door_x = SCREEN_WIDTH - 3 * TILE_SIZE
    
    return (door_x, door_y)

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    deadly_tiles = LEVEL_DEADLY_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Function to check if position is safe from deadly tiles
    def is_safe_position(x, y):
        SAFE_DISTANCE = TILE_SIZE * 3  # Minimum distance from deadly tiles
        
        for deadly in deadly_tiles:
            deadly_x = deadly[0] * TILE_SIZE
            deadly_y = deadly[1] * TILE_SIZE
            deadly_width = deadly[2] * TILE_SIZE
            deadly_height = deadly[3] * TILE_SIZE
            
            # Calculate boundaries of the deadly area with safety margin
            deadly_left = deadly_x - SAFE_DISTANCE
            deadly_right = deadly_x + deadly_width + SAFE_DISTANCE
            deadly_top = deadly_y - SAFE_DISTANCE
            deadly_bottom = deadly_y + deadly_height + SAFE_DISTANCE
            
            # Check if key position is within the danger zone
            if (deadly_left < x < deadly_right and 
                deadly_top < y < deadly_bottom):
                return False
        return True
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    attempts = 0
    max_attempts = 100  # Prevent infinite loop
    
    while len(positions) < required_keys and attempts < max_attempts:
        for plat in viable_platforms:
            if len(positions) >= required_keys:
                break
                
            # Try multiple positions on each platform
            for _ in range(5):  # Try 5 times per platform
                # Place key somewhere along the platform
                key_x = plat[0] + random.uniform(TILE_SIZE, plat[2] - TILE_SIZE * 2)
                key_y = plat[1] - TILE_SIZE * 1.5
                
                # Only add position if it's safe
                if is_safe_position(key_x, key_y):
                    positions.append((key_x, key_y))
                    break
            
            attempts += 1
    
    # If we couldn't find enough safe positions, fill remaining with positions farther from platforms
    while len(positions) < required_keys:
        plat = random.choice(viable_platforms)
        key_x = plat[0] + random.uniform(TILE_SIZE * 2, plat[2] - TILE_SIZE * 2)
        key_y = plat[1] - TILE_SIZE * 2  # Place keys higher above platform
        if is_safe_position(key_x, key_y):
            positions.append((key_x, key_y))
    
    return positions

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    
    for i in range(min(required_keys, len(viable_platforms))):
        plat = viable_platforms[i]
        # Place key somewhere along the platform
        key_x = plat[0] + random.uniform(0, plat[2] - TILE_SIZE)
        key_y = plat[1] - TILE_SIZE * 1.5  # Place key above platform
        positions.append((key_x, key_y))
    
    return positions

# Modify the initialize_game_objects function to include the leaderboard
def initialize_game_objects():
    global start_button, restart_button, camera, player, world, moving_enemies
    global keys_group, door, ghost, game_over, current_state, movement_enabled
    global pause_button, scene_manager, game_stats, leaderboard

    # Create scene manager first
    scene_manager = SceneManager(screen)
    
    # Initialize other objects
    start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
    restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)
    camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
    player = Player(100, SCREEN_HEIGHT - 130)
    world = World(LEVEL_PLATFORM_DATA[1], LEVEL_DEADLY_DATA[1])
    moving_enemies = pygame.sprite.Group()
    keys_group = pygame.sprite.Group()
    door = None
    ghost = None
    game_over = 0
    current_state = "name_input"
    movement_enabled = False 
    pause_button = PauseButton(screen)
    game_stats = EnhancedGameStats(screen)
    leaderboard = Leaderboard(screen)

    return scene_manager

# Initialize game state
scene_manager = initialize_game_objects()
init_game()
update_scale_factors()

# Game loop
clock = pygame.time.Clock()
fps = 60
running = True
fullscreen = False

# Main game loop
while running:
    clock.tick(fps)
    
    # Handle pause state first
    if current_state == "playing" and paused:
        if not handle_pause():
            running = False
        continue
    
    # Global event handling
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
            
        # Handle fullscreen toggle and update scaling
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RSHIFT:
                toggle_fullscreen()
                # Recreate UI elements with new scaling
                initialize_game_objects()
                
        # Global pause handling
        if current_state == "playing" and not paused:
            if (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE) or \
               pause_button.handle_event(event):
                paused = True
                pause_start_time = datetime.now()
                fade_alpha = 0
                continue

        # Handle scene-specific input
        if current_state in ["scene", "intro_scenes", "level_transition", "ending_scenes"]:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                if not scene_manager.current_scene.fading_in and not scene_manager.current_scene.fading_out:
                    scene_manager.current_scene.fading_out = True
        
        # Handle name input
        if current_state == "name_input" and scene_manager.text_input.active:
            result = scene_manager.text_input.handle_event(event)
            if result:
                scene_manager.player_name = result
                scene_manager.text_input.active = False
                scene_manager.update_scenes_with_name()
                current_state = "scene"
    
    if not running:
        break

    # Clear screen
    screen.fill(BLACK)
    
    # State-specific updates
    if current_state == "name_input":
        scene_manager.draw()
        
    elif current_state in ["scene", "intro_scenes", "level_transition", "ending_scenes"]:
        scene_manager.update(clock.get_time() / 1000.0)
        scene_manager.draw()
        
        if scene_manager.current_scene.completed:
            next_state = scene_manager.scenes[scene_manager.scene_index].get('next', 'scene')
            
            if next_state == 'scene':
                scene_manager.next_scene()
            elif next_state.startswith('level_'):
                level_num = 0 if scene_manager.scene_index == 6 else int(next_state.split('_')[1])
                game_start_time = None
                movement_enabled = False
                
                level_objects = init_level(level_num)
                if all(obj is not None for obj in level_objects):
                    keys_group, door, world, moving_enemies, player, ghost = level_objects
                    camera.start_transition()
                    current_state = "playing"
            elif next_state == 'game_complete':
                current_state = "game_complete"
                
    elif current_state == "playing":
        # Get and draw the current background
        current_background = get_background(current_level)
        if current_background:
            scaled_bg = pygame.transform.scale(current_background, (SCREEN_WIDTH, SCREEN_HEIGHT))
            screen.blit(scaled_bg, (0, 0))
        
        # Determine if entities can move
        can_move = movement_enabled and not camera.door_zoom and not paused
        
        # Update game entities only when movement is allowed
        if can_move:
            # Update entities
            keys_group.update()
            moving_enemies.update()
            ghost.update()
            
            # Check collisions with enemies and ghost
            for enemy in moving_enemies:
                if enemy.check_collision(player):
                    game_over = -1
                    break
            
            if ghost.check_collision(player):
                game_over = -1
            
            # Update player and check for game over
            game_over = player.update(game_over, world, keys_group, camera)
            
            # Update timer only when game started and movement allowed
            if game_start_time is None:
                if camera.transition_complete and camera.initial_zoom_done:
                    game_start_time = time.time()
            elif not game_over:
                current_time = time.time()
                elapsed_time = current_time - game_start_time
                if total_pause_time:
                    elapsed_time -= total_pause_time.total_seconds()
                
                # Check level timer
                if check_level_timer(elapsed_time, LEVEL_TIME_LIMITS[current_level]):
                    game_over = -1
                    game_over_fx.play()
        
        # Always update door animation
        door.update()
        
        # Check level completion
        if keys_collected >= LEVEL_REQUIREMENTS[current_level]:
            if not door.is_open:
                camera.start_door_zoom(door)
            elif pygame.sprite.collide_rect(player, door) and not door.entered:
                door.entered = True
                camera.stop_sounds()
                
                level_complete_mapping = {
                    0: (1, 7),    # Tutorial -> Level 1, Scene 8
                    1: (2, 9),    # Level 1 -> Level 2, Scene 10
                    2: (3, 11),   # Level 2 -> Level 3, Scene 12
                    3: (4, 13),   # Level 3 -> Level 4, Scene 14
                    4: (5, 15),   # Level 4 -> Level 5, Scene 16
                    5: (None, 17) # Level 5 -> Ending (Scene 18)
                }
                
                if current_level in level_complete_mapping:
                    next_level, next_scene = level_complete_mapping[current_level]
                    if next_level is None:
                        current_state = "ending_scenes"
                    else:
                        current_level = next_level
                        current_state = "level_transition"
                    scene_manager.scene_index = next_scene
                    scene_manager.current_scene = Scene(screen, scene_manager.scenes[next_scene])
        
        # Update camera and create zoomed view with scaling
        camera.update(player, keys_collected, door, LEVEL_REQUIREMENTS[current_level])
        create_zoomed_view(screen, camera, player, world, keys_group, door, moving_enemies, ghost)
        
        # Draw HUD if not in door zoom
        if not camera.door_zoom and camera.transition_complete:
            game_stats.draw_stats_panel(
                current_level,
                keys_collected,
                LEVEL_REQUIREMENTS[current_level],
                time.time() - game_start_time if game_start_time else 0,
                LEVEL_TIME_LIMITS[current_level]
            )
            if not paused:
                pause_button.draw()
                leaderboard.draw()  # Draw leaderboard during gameplay
        
        # Handle game over state
        if game_over == -1:
            text_x = (SCREEN_WIDTH // 2) - int(200 * SCALE_X)
            text_y = SCREEN_HEIGHT // 2
            draw_text('GAME OVER!', int(70 * SCALE_Y), BLUE, text_x, text_y)
            if restart_button.draw(screen):
                if not reset_level():
                    print("Failed to restart level")
                    running = False
        
    elif current_state == "game_complete":
        screen.fill(BLACK)
        
        # Calculate final stats
        if game_start_time:
            total_time = datetime.now() - datetime.fromtimestamp(game_start_time) - total_pause_time
            total_seconds = total_time.total_seconds()
            
            # Add score to leaderboard
            leaderboard.add_score(scene_manager.player_name, total_seconds)
            
            minutes = int(total_time.total_seconds() // 60)
            seconds = int(total_time.total_seconds() % 60)
            
            # Draw completion card
            card_width = int(600 * SCALE_X)
            card_height = int(400 * SCALE_Y)
            completion_card = pygame.Surface((card_width, card_height))
            completion_card.fill((40, 40, 40))
            
            title_font = pygame.font.SysFont('Bauhaus 93', int(70 * SCALE_Y))
            title = title_font.render("GAME COMPLETE!", True, (255, 215, 0))
            completion_card.blit(title, (card_width//2 - title.get_width()//2, int(40 * SCALE_Y)))
            
            stats = [
                f"Player: {scene_manager.player_name}",
                f"Total Time: {minutes:02d}:{seconds:02d}",
                f"Keys Collected: {sum(LEVEL_REQUIREMENTS.values())}",
                f"Levels Completed: 5"
            ]
            
            stats_font = pygame.font.SysFont('Bauhaus 93', int(40 * SCALE_Y))
            for i, stat in enumerate(stats):
                text = stats_font.render(stat, True, WHITE)
                completion_card.blit(text, (card_width//2 - text.get_width()//2, 
                                         int((160 + i * 60) * SCALE_Y)))
            
            screen.blit(completion_card, 
                      (SCREEN_WIDTH//2 - card_width//2,
                       SCREEN_HEIGHT//2 - card_height//2))
            
            # Draw leaderboard next to completion card
            leaderboard.draw()
            
            if restart_button.draw(screen):
                current_state = "name_input"
                game_start_time = None
                current_level = 0
                keys_collected = 0
                level_times = []
                scene_manager = SceneManager(screen)
    
    pygame.display.update()

# Cleanup
cleanup_game()
pygame.quit()

================
File: mini_game3.py
================
import pygame
import random
import time
import sys

def main():
    # Initialize Pygame
    pygame.init()
    pygame.mixer.init()

    # Screen settings
    WIDTH = 1539
    HEIGHT = 940
    screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption("Rock Paper Scissors Word Collection Game")

    # Colors
    WHITE = (255, 255, 255)
    BLACK = (0, 0, 0)
    BROWN = (122, 92, 72)
    GREEN = (0, 255, 0)
    RED = (255, 0, 0)

    # Font settings
    font = pygame.font.Font(None, 74)
    small_font = pygame.font.Font(None, 40)
    end_font = pygame.font.Font(None, 80)

    # Load background image
    background_img = pygame.image.load("minigame3/BACKGROUND_IMAGE_1.png")
    background_img = pygame.transform.scale(background_img, (WIDTH, HEIGHT))

    # Load images for player's rock, paper, scissors
    rock_img = pygame.image.load("minigame3/HUMAN_ROCK.png")
    paper_img = pygame.image.load("minigame3/HUMAN_PAPER.png")
    scissors_img = pygame.image.load("minigame3/HUMAN_SCISSORS.png")

    # Load glowing images
    glow_rock_img = pygame.image.load("minigame3/GLOWING_HUMAN_ROCK.png")
    glow_paper_img = pygame.image.load("minigame3/GLOWING_HUMAN_PAPER.png")
    glow_scissors_img = pygame.image.load("minigame3/GLOWING_HUMAN_SCISSORS.png")

    # Load opponent images
    opponent_rock_img = pygame.image.load("minigame3/OPPONENT_ROCK.png")
    opponent_paper_img = pygame.image.load("minigame3/OPPONENT_PAPER.png")
    opponent_scissors_img = pygame.image.load("minigame3/OPPONENT_SCISSORS.png")

    # Default images
    default_player_image = rock_img
    default_opponent_image = rock_img

    # Load audio
    pygame.mixer.music.load("minigame3/BACKGROUND_MUSIC.mp3")
    click_sound = pygame.mixer.Sound("minigame3/music/CLICK_SOUNDEFFECT.mp3")

    # Scale settings
    scale_size = (225, 225)
    larger_scale_size = (300, 300)

    # Scale game icons
    rock_img = pygame.transform.scale(rock_img, scale_size)
    paper_img = pygame.transform.scale(paper_img, scale_size)
    scissors_img = pygame.transform.scale(scissors_img, scale_size)
    glow_rock_img = pygame.transform.scale(glow_rock_img, larger_scale_size)
    glow_paper_img = pygame.transform.scale(glow_paper_img, larger_scale_size)
    glow_scissors_img = pygame.transform.scale(glow_scissors_img, larger_scale_size)
    opponent_rock_img = pygame.transform.scale(opponent_rock_img, scale_size)
    opponent_paper_img = pygame.transform.scale(opponent_paper_img, scale_size)
    opponent_scissors_img = pygame.transform.scale(opponent_scissors_img, scale_size)

    # Position settings
    player_rock_pos = (WIDTH // 3 - 112.5, HEIGHT - 225)
    player_paper_pos = (WIDTH // 2 - 112.5, HEIGHT - 225)
    player_scissors_pos = (3 * WIDTH // 4.5 - 112.5, HEIGHT - 225)

    # Create hitboxes
    player_rock_rect = pygame.Rect(player_rock_pos, scale_size)
    player_paper_rect = pygame.Rect(player_paper_pos, scale_size)
    player_scissors_rect = pygame.Rect(player_scissors_pos, scale_size)

    # Opponent settings
    opponent_base_pos = WIDTH // 2 - 112.5
    opponent_y_pos = 0
    hand_position = opponent_base_pos

    # Technology-related word bank
    TECH_WORDS = [
        "CODING", "PYTHON", "ROUTER", "SERVER", "BINARY",
        "GITHUB", "LINUX", "DOCKER", "CLOUD", "GAMING"
    ]

    class WordGame:
        def __init__(self):
            self.target_word = random.choice(TECH_WORDS)
            self.collected_letters = []
            self.displayed_word = ["_"] * len(self.target_word)
            self.guessing_phase = False
            self.attempts_left = 3
            self.current_guess = ""
            self.message = ""
            self.game_over = False
            self.won = False
            self.scrambled_letters = []

        def add_letter(self):
            available_positions = []
            for i, char in enumerate(self.target_word):
                if self.displayed_word[i] == "_":  # If position is empty
                    available_positions.append(i)
                    
            if available_positions:
                pos = random.choice(available_positions)
                letter = self.target_word[pos]
                self.collected_letters.append(letter)
                self.displayed_word[pos] = letter
                self.scrambled_letters.append(letter)
                
                if len(self.collected_letters) >= len(self.target_word):
                    self.guessing_phase = True
                    random.shuffle(self.scrambled_letters)
                return True
            return False

        def get_scrambled_display(self):
            return " ".join(self.scrambled_letters)

        def check_guess(self, guess):
            guess = guess.upper().strip()
            target = self.target_word.upper().strip()
            
            print(f"Guess: '{guess}', Target: '{target}'")
            if guess == target:
                self.won = True
                self.game_over = True
                self.message = "Congratulations! You won!"
                return True
            self.attempts_left -= 1
            if self.attempts_left == 0:
                self.game_over = True
                self.message = f"Game Over! The word was {self.target_word}"
            else:
                self.message = f"Wrong guess! {self.attempts_left} attempts left"
            return False

    class GameState:
        def __init__(self):
            self.reset_game()
        
        def reset_game(self):
            self.player_choice = None
            self.computer_choice = None
            self.result_text = "Pick an option"
            self.showing_result = False
            self.result_timer = 0
            self.choice_made = False
            self.word_game = WordGame()
            self.swipe_direction = 1

    def determine_winner(player, computer):
        if player == computer:
            return "tie"
        elif (player == "rock" and computer == "scissors") or \
             (player == "paper" and computer == "rock") or \
             (player == "scissors" and computer == "paper"):
            return "player"
        else:
            return "computer"
        
    def draw_word_progress(screen, word_game):
        box_width = 650
        box_height = 200
        box_x = WIDTH//2 - box_width//2
        box_y = HEIGHT//2 - 120
        
        progress_box = pygame.Surface((box_width, box_height))
        progress_box.fill(BLACK)
        progress_box.set_alpha(128)
        screen.blit(progress_box, (box_x, box_y))
        
        display_spaces = ["_" for _ in range(len(word_game.target_word))]
        for i, letter in enumerate(word_game.collected_letters):
            display_spaces[i] = letter
        
        letter_display = "  ".join(display_spaces)
        letter_surface = font.render(letter_display, True, WHITE)
        letter_rect = letter_surface.get_rect()
        letter_rect.centerx = box_x + box_width//2
        letter_rect.centery = box_y + box_height//3
        screen.blit(letter_surface, letter_rect)
        
        progress_text = f"Letters: {len(word_game.collected_letters)}/{len(word_game.target_word)}"
        progress_surface = small_font.render(progress_text, True, WHITE)
        progress_rect = progress_surface.get_rect()
        progress_rect.centerx = box_x + box_width//2
        progress_rect.centery = box_y + 2*box_height//3
        screen.blit(progress_surface, progress_rect)

    def draw_guessing_phase(screen, word_game):
        overlay = pygame.Surface((WIDTH, HEIGHT))
        overlay.fill(BLACK)
        overlay.set_alpha(128)
        screen.blit(overlay, (0, 0))
        
        box_width = 800
        box_height = 400
        box_x = WIDTH//2 - box_width//2
        box_y = HEIGHT//2 - box_height//2
        
        guess_box = pygame.Surface((box_width, box_height))
        guess_box.fill(BLACK)
        guess_box.set_alpha(128)
        screen.blit(guess_box, (box_x, box_y))
        
        total_elements = 5
        spacing = box_height // (total_elements + 1)
        current_y = box_y + spacing
        
        scrambled_text = "  ".join(word_game.scrambled_letters)
        scrambled_surface = font.render(scrambled_text, True, WHITE)
        scrambled_rect = scrambled_surface.get_rect()
        scrambled_rect.centerx = box_x + box_width//2
        scrambled_rect.centery = current_y
        screen.blit(scrambled_surface, scrambled_rect)
        current_y += spacing
        
        prompt_text = "Unscramble these letters!"
        prompt_surface = small_font.render(prompt_text, True, WHITE)
        prompt_rect = prompt_surface.get_rect()
        prompt_rect.centerx = box_x + box_width//2
        prompt_rect.centery = current_y
        screen.blit(prompt_surface, prompt_rect)
        current_y += spacing
        
        guess_text = f"Your guess: {word_game.current_guess}"
        guess_surface = font.render(guess_text, True, WHITE)
        guess_rect = guess_surface.get_rect()
        guess_rect.centerx = box_x + box_width//2
        guess_rect.centery = current_y
        screen.blit(guess_surface, guess_rect)
        current_y += spacing
        
        attempts_text = f"Attempts remaining: {word_game.attempts_left}"
        attempts_surface = small_font.render(attempts_text, True, WHITE)
        attempts_rect = attempts_surface.get_rect()
        attempts_rect.centerx = box_x + box_width//2
        attempts_rect.centery = current_y
        screen.blit(attempts_surface, attempts_rect)
        current_y += spacing
        
        if word_game.message:
            message_surface = small_font.render(word_game.message, True, WHITE)
            message_rect = message_surface.get_rect()
            message_rect.centerx = box_x + box_width//2
            message_rect.centery = current_y
            screen.blit(message_surface, message_rect)

    # Start background music
    pygame.mixer.music.play(-1)
    pygame.mixer.music.set_volume(0.5)

    # Initialize game state
    game_state = GameState()

    # Animation variables
    last_frame_change_time = pygame.time.get_ticks()
    frame_change_time = 200

    # Game loop
    running = True
    clock = pygame.time.Clock()

    while running:
        current_time = pygame.time.get_ticks()
        screen.fill(BROWN)
        screen.blit(background_img, (0, 0))

        if game_state.word_game.game_over:
            screen.fill(BLACK)
            end_text = "GAME OVER"
            final_result = "YOU WIN!" if game_state.word_game.won else "YOU LOSE!"
            
            end_surface = end_font.render(end_text, True, WHITE)
            end_rect = end_surface.get_rect(center=(WIDTH // 2, HEIGHT // 2 - 40))
            screen.blit(end_surface, end_rect)

            final_surface = end_font.render(final_result, True, WHITE)
            final_rect = final_surface.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 40))
            screen.blit(final_surface, final_rect)

            word_text = f"The word was: {game_state.word_game.target_word}"
            word_surface = small_font.render(word_text, True, WHITE)
            word_rect = word_surface.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 100))
            screen.blit(word_surface, word_rect)

            restart_text = "PRESS SPACE TO RESTART"
            restart_surface = small_font.render(restart_text, True, WHITE)
            restart_rect = restart_surface.get_rect(center=(WIDTH // 2, HEIGHT // 2 + 150))
            screen.blit(restart_surface, restart_rect)
            
        elif game_state.word_game.guessing_phase:
            draw_guessing_phase(screen, game_state.word_game)
            
        else:
            screen.blit(rock_img, player_rock_pos)
            screen.blit(paper_img, player_paper_pos)
            screen.blit(scissors_img, player_scissors_pos)
            
            draw_word_progress(screen, game_state.word_game)
            
            if game_state.result_text:
                result_surface = small_font.render(game_state.result_text, True, WHITE)
                result_rect = result_surface.get_rect(center=(WIDTH//2, HEIGHT//2 + 150))
                screen.blit(result_surface, result_rect)
            
            game_state.hand_position = opponent_base_pos + (25 * game_state.swipe_direction)
            if game_state.computer_choice:
                if game_state.computer_choice == "rock":
                    opponent_hand_img = opponent_rock_img
                elif game_state.computer_choice == "paper":
                    opponent_hand_img = opponent_paper_img
                else:
                    opponent_hand_img = opponent_scissors_img
                
                opponent_hand_img_flipped = pygame.transform.flip(opponent_hand_img, False, True)
                screen.blit(opponent_hand_img_flipped, (game_state.hand_position, opponent_y_pos))
            elif not game_state.showing_result:
                opponent_hand_img_flipped = pygame.transform.flip(opponent_rock_img, False, True)
                screen.blit(opponent_hand_img_flipped, (opponent_base_pos, opponent_y_pos))
            
            if game_state.player_choice and not game_state.showing_result:
                if game_state.player_choice == "rock":
                    screen.blit(glow_rock_img, (player_rock_pos[0] - 37.5, player_rock_pos[1] - 37.5))
                elif game_state.player_choice == "paper":
                    screen.blit(glow_paper_img, (player_paper_pos[0] - 37.5, player_paper_pos[1] - 37.5))
                elif game_state.player_choice == "scissors":
                    screen.blit(glow_scissors_img, (player_scissors_pos[0] - 37.5, player_scissors_pos[1] - 37.5))

        # Event handling
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                return False

            if event.type == pygame.KEYDOWN:
                if game_state.word_game.game_over and event.key == pygame.K_SPACE:
                    # If player won, return True, otherwise return False
                    if game_state.word_game.won:
                        pygame.quit()
                        return True
                    game_state = GameState()  # Reset game
                elif game_state.word_game.guessing_phase:
                    if event.key == pygame.K_RETURN and game_state.word_game.current_guess:
                        print(f"Attempting guess: {game_state.word_game.current_guess}")  # Debug print
                        game_state.word_game.check_guess(game_state.word_game.current_guess)
                        game_state.word_game.current_guess = ""
                    elif event.key == pygame.K_BACKSPACE:
                        game_state.word_game.current_guess = game_state.word_game.current_guess[:-1]
                    elif event.unicode.isalpha() and len(game_state.word_game.current_guess) < len(game_state.word_game.target_word):
                        game_state.word_game.current_guess += event.unicode.upper()

            if event.type == pygame.MOUSEBUTTONDOWN and not game_state.word_game.game_over and not game_state.word_game.guessing_phase and not game_state.showing_result:
                mouse_pos = pygame.mouse.get_pos()
                
                if player_rock_rect.collidepoint(mouse_pos):
                    game_state.player_choice = "rock"
                    game_state.computer_choice = random.choice(["rock", "paper", "scissors"])
                    click_sound.play()
                    game_state.showing_result = True
                    game_state.result_timer = current_time
                elif player_paper_rect.collidepoint(mouse_pos):
                    game_state.player_choice = "paper"
                    game_state.computer_choice = random.choice(["rock", "paper", "scissors"])
                    click_sound.play()
                    game_state.showing_result = True
                    game_state.result_timer = current_time
                elif player_scissors_rect.collidepoint(mouse_pos):
                    game_state.player_choice = "scissors"
                    game_state.computer_choice = random.choice(["rock", "paper", "scissors"])
                    click_sound.play()
                    game_state.showing_result = True
                    game_state.result_timer = current_time
                
                if game_state.player_choice:
                    winner = determine_winner(game_state.player_choice, game_state.computer_choice)
                    game_state.result_text = f"You chose {game_state.player_choice}. Opponent chose {game_state.computer_choice}."
                    
                    if winner == "player":
                        letter_added = game_state.word_game.add_letter()
                        if letter_added:
                            game_state.result_text += " You win! Letter added!"
                        else:
                            game_state.result_text += " You win!"
                    elif winner == "computer":
                        game_state.result_text += " You lose!"
                    else:
                        game_state.result_text += " It's a tie!"
                    
                    if len(game_state.word_game.collected_letters) == len(game_state.word_game.target_word):
                        game_state.word_game.guessing_phase = True
                        game_state.result_text = "All letters collected! Time to guess the word!"

        # Handle result display timing
        if game_state.showing_result:
            if current_time - game_state.result_timer >= 1500:  # 1.5 seconds
                game_state.showing_result = False
                if not game_state.word_game.guessing_phase:
                    game_state.player_choice = None
                    game_state.computer_choice = None
                    game_state.result_text = "Pick an option"

        # Update hand swipe animation
        if current_time - last_frame_change_time >= frame_change_time:
            game_state.swipe_direction *= -1 if random.random() < 0.1 else 1
            last_frame_change_time = current_time

        pygame.display.flip()
        clock.tick(60)

    pygame.quit()
    return False

if __name__ == "__main__":
    main()

================
File: Level_Data.py
================
level_layouts = {
    1: [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1],
        [1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 2, 2, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 2, 2, 2, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1]
    ],
    2: [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1],
        [1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 2, 2, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 2, 2, 2, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    3: [
        [1, 1, 1, 1, 1, 1, 1 , 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1],
        [1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 2, 2, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 0, 0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 7, 0, 0, 0, 0, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0, 2, 2, 2, 2, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    4: [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 2, 2, 1],
        [1, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 7, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 2, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 1],
        [1, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0 , 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    5: [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 2, 2, 1],
        [1, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 7, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 2, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 1],
        [1, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    6: [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 2, 2, 1],
        [1, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 7, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 2, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 1],
        [1, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
    ],
    7: [
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 2, 2, 1],
        [1, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 0, 1],
        [1, 7, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 1],
        [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 0, 0, 2, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 3, 0, 0, 0, 0, 1],
        [1, 0, 0, 3, 0, 0, 3, 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 2, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 0, 0, 2, 0, 1],
        [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 2, 0, 0, 0, 0, 1],
        [1, 0, 0, 0, 4, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
        [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  1, 1, 1, 1, 1, 1, 1, 1, 1]
    ]
    # Add more levels as needed
}

level_graphics = {
    1: {
        'background': 'img/background_level1.png',
        'tiles': {
            1: 'img/dirt_block_level1.png',
            2: 'img/grass_block_level1.png',
            6: 'img/lava_level1.png',
            7: 'img/key_level1.png',
            8: 'img/exit_level1.png',
        }
    },
    2: {
        'background': 'img/background_level2.png',
        'tiles': {
            1: 'img/dirt_block_level2.png',
            2: 'img/grass_block_level2.png',
            6: 'img/lava_level2.png',
            7: 'img/key_level2.png',
            8: 'img/exit_level2.png',
        }
    }

}

================
File: mini_game2.py
================
"""
mini-game2.py

Primary Author: Russel Rafanan
Editor: Jessica Ng
Enhanced by: Claude

A Python-based word guessing game inspired by Wordle, featuring a programming-themed
word list, timer, and GIF feedback system.
"""

import pygame
import random
from PIL import Image
import os
import sys

pygame.init()

# Screen and game constants
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940
GRID_SIZE = 6
WORD_LENGTH = 5
FONT_SIZE = 50
ANSWER_FONT_SIZE = 40  # Smaller font size for answer
BOX_SIZE = 100
BOX_SPACING = 15
BOX_BORDER_RADIUS = 5

# Feedback position constants
FEEDBACK_X = SCREEN_WIDTH - 420
FEEDBACK_Y = SCREEN_HEIGHT // 2 - 300

# Color scheme definitions
BACKGROUND_COLOR = (18, 18, 19)
EMPTY_BOX_COLOR = (58, 58, 60)
BORDER_COLOR = (58, 58, 60)
FILLED_BOX_COLOR = (58, 58, 60)
GREEN = (83, 141, 78)
YELLOW = (181, 159, 59)
GRAY = (58, 58, 60)
TEXT_COLOR = (255, 255, 255)

# Programming-themed word bank plus master word
word_list = [
    "ARRAY", "CLASS", "DEBUG", "ERROR", "FLOAT", 
    "INPUT", "LOGIC", "LOOPS", "QUEUE", "STACK",
    "PARSE", "PRINT", "PROXY", "QUERY", "RANGE",
    "SCOPE", "SHELL", "SLICE", "SWING", "TUPLE",
    "TYPES", "VALUE", "WHILE", "YIELD", "BREAK",
    "CATCH", "CONST", "EVENT", "FALSE", "FINAL",
    "FRAME", "INDEX", "LABEL", "MACRO", "MATCH",
    "MERGE", "NODES", "PIXEL", "POINT", "POWER",
    "REACT", "ROUTE", "SCALA", "SETUP", "SPLIT",
    "STATE", "SUPER", "TABLE", "TRACE", "VALID",
    "BLOCK", "CACHE", "CHAIN", "CHECK", "COUNT",
    "DELAY", "DRAFT", "EMPTY", "FETCH", "FLAGS",
    "FLASH", "GROUP", "GUARD", "HTTPS", "LEVEL",
    "LINKS", "MODEL", "NUMPY", "PATCH", "PAUSE",
    "PROTO", "RESET", "ROUND", "SCALE", "THROW",
    "RUSSS"  # Master word for instant win
]

class GifPlayer:
    def __init__(self, gif_path):
        self.frames = []
        self.current_frame = 0
        self.last_update = 0
        self.frame_duration = 30  # Fast animation speed
        self.is_complete = False
        
        # Load GIF frames using Pillow
        gif = Image.open(gif_path)
        try:
            while True:
                frame = gif.copy()
                frame = pygame.image.fromstring(
                    frame.convert('RGBA').tobytes(), frame.size, 'RGBA')
                self.frames.append(frame)
                gif.seek(gif.tell() + 1)
        except EOFError:
            pass

    def update(self):
        current_time = pygame.time.get_ticks()
        if current_time - self.last_update > self.frame_duration:
            self.current_frame += 1
            if self.current_frame >= len(self.frames):
                self.current_frame = 0
                self.is_complete = True
            self.last_update = current_time

    def get_current_frame(self):
        return self.frames[self.current_frame]

    def reset(self):
        self.current_frame = 0
        self.is_complete = False

class FeedbackSystem:
    def __init__(self):
        self.gifs = {
            'welcome': GifPlayer('Minigame2/Russ Welcome.gif'),
            'instructions': GifPlayer('Minigame2/Russ Instructions.gif'),
            'time': GifPlayer('Minigame2/Russ Time.gif'),
            'short': GifPlayer('Minigame2/Russ Short.gif'),
            'won': GifPlayer('Minigame2/Russ Won.gif'),
            'lost': GifPlayer('Minigame2/Russ Lost.gif')
        }
        self.current_gif = None
        self.display_time = 0
        self.gif_queue = []
        self.showing_answer = False
        self.answer_start_time = 0
        self.lost_gif_complete = False
        self.won_gif_complete = False
        self.answer_display_duration = 2000  # 2 seconds to show answer
        self.answer_font = pygame.font.Font('Minigame2/PRESSSTART2P.ttf', ANSWER_FONT_SIZE)

    def show_gif(self, gif_name):
        if gif_name not in [g[0] for g in self.gif_queue]:
            self.gifs[gif_name].reset()
            self.gif_queue.append((gif_name, None))

    def update(self, screen, secret_word=None, game_font=None):
        current_time = pygame.time.get_ticks()
        
        # Handle win state
        if self.won_gif_complete:
            pygame.time.wait(1000)  # Wait for 1 second after win animation
            pygame.quit()
            sys.exit()

        # Show answer after loss
        if self.showing_answer and secret_word:
            # Calculate position at bottom of grid
            start_y = 175  # Starting Y position of grid
            grid_height = GRID_SIZE * (BOX_SIZE + BOX_SPACING)
            answer_y = start_y + grid_height + 30  # 30 pixels padding below grid
            
            answer_text = f"The word was: {secret_word}"
            text_surface = self.answer_font.render(answer_text, True, TEXT_COLOR)
            text_rect = text_surface.get_rect(center=(SCREEN_WIDTH // 2, answer_y))
            screen.blit(text_surface, text_rect)
            
            # Check if we should restart after showing answer
            if self.lost_gif_complete and current_time - self.answer_start_time > self.answer_display_duration:
                return True  # Signal to restart game
        
        # Update current GIF
        if self.gif_queue:
            gif_name, _ = self.gif_queue[0]
            current_gif = self.gifs[gif_name]
            current_gif.update()
            frame = current_gif.get_current_frame()
            screen.blit(frame, (FEEDBACK_X, FEEDBACK_Y))
            
            if current_gif.is_complete:
                self.gif_queue.pop(0)
                
                if gif_name == 'lost':
                    self.showing_answer = True
                    self.answer_start_time = current_time
                    self.lost_gif_complete = True
                elif gif_name == 'won':
                    self.won_gif_complete = True
        
        return False

    def reset(self):
        self.showing_answer = False
        self.lost_gif_complete = False
        self.won_gif_complete = False
        self.gif_queue = []
        for gif in self.gifs.values():
            gif.reset()

class Timer:
    def __init__(self, duration):
        self.duration = duration
        self.start_time = pygame.time.get_ticks()
        self.is_running = True
        self.thirty_second_warning_shown = False

    def get_time_left(self):
        if not self.is_running:
            return 0
        elapsed = (pygame.time.get_ticks() - self.start_time) // 1000
        remaining = max(0, self.duration - elapsed)
        return remaining

    def is_finished(self):
        return self.get_time_left() <= 0

    def stop(self):
        self.is_running = False

    def draw(self, screen, font):
        if self.is_running:
            seconds_left = self.get_time_left()
            minutes = seconds_left // 60
            seconds = seconds_left % 60
            time_text = f"{minutes}:{seconds:02d}"
            text_surface = font.render(time_text, True, TEXT_COLOR)
            screen.blit(text_surface, (20, 20))

    def should_show_warning(self):
        seconds_left = self.get_time_left()
        if seconds_left <= 30 and not self.thirty_second_warning_shown:
            self.thirty_second_warning_shown = True
            return True
        return False

def draw_box(screen, game_font, x, y, color, letter='', border_color=None):
    """Draw a letter box with specified styling and content"""
    box_rect = pygame.Rect(x, y, BOX_SIZE, BOX_SIZE)
    pygame.draw.rect(screen, color, box_rect, border_radius=BOX_BORDER_RADIUS)
    
    if border_color:
        pygame.draw.rect(screen, border_color, box_rect, 3, border_radius=BOX_BORDER_RADIUS)
    
    if letter:
        text_surface = game_font.render(letter, True, TEXT_COLOR)
        text_rect = text_surface.get_rect(center=(x + BOX_SIZE // 2, y + BOX_SIZE // 2))
        screen.blit(text_surface, text_rect)

def get_letter_colors(guess, secret):
    """Determine feedback colors for each letter in the guess"""
    # Special case for RUSSS - all green
    if guess == "RUSSS":
        return [GREEN] * WORD_LENGTH
        
    colors = [GRAY] * WORD_LENGTH
    remaining_letters = {}

    # Count remaining letters after marking exact matches
    for i in range(WORD_LENGTH):
        if guess[i] != secret[i]:
            remaining_letters[secret[i]] = remaining_letters.get(secret[i], 0) + 1

    # Mark correct letters in correct positions
    for i in range(WORD_LENGTH):
        if guess[i] == secret[i]:
            colors[i] = GREEN
            if guess[i] in remaining_letters:
                remaining_letters[guess[i]] -= 1

    # Mark correct letters in wrong positions
    for i in range(WORD_LENGTH):
        if colors[i] != GREEN and guess[i] in remaining_letters and remaining_letters[guess[i]] > 0:
            colors[i] = YELLOW
            remaining_letters[guess[i]] -= 1

    return colors

def draw_grid(screen, game_font, guesses, current_guess, secret_word):
    """Render the game grid with all guesses and current input"""
    start_x = (SCREEN_WIDTH - (WORD_LENGTH * (BOX_SIZE + BOX_SPACING))) // 2
    start_y = 175

    # Draw previous guesses
    for i in range(GRID_SIZE):
        for j in range(WORD_LENGTH):
            x = start_x + j * (BOX_SIZE + BOX_SPACING)
            y = start_y + i * (BOX_SIZE + BOX_SPACING)

            if i < len(guesses):
                letter = guesses[i][j]
                colors = get_letter_colors(guesses[i], secret_word)
                draw_box(screen, game_font, x, y, colors[j], letter)
            else:
                draw_box(screen, game_font, x, y, BACKGROUND_COLOR, border_color=BORDER_COLOR)

    # Draw current guess
    current_row = len(guesses)
    if current_row < GRID_SIZE:
        for j in range(WORD_LENGTH):
            x = start_x + j * (BOX_SIZE + BOX_SPACING)
            y = start_y + current_row * (BOX_SIZE + BOX_SPACING)
            if j < len(current_guess):
                draw_box(screen, game_font, x, y, FILLED_BOX_COLOR, current_guess[j])
            else:
                draw_box(screen, game_font, x, y, BACKGROUND_COLOR, border_color=BORDER_COLOR)

def main():
    # Initialize display window
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption("Wordle")

    def reset_game():
        nonlocal secret_word, timer, guesses, current_guess, game_over, won
        secret_word = random.choice(word_list)
        timer = Timer(90)  # 90 seconds = 1 minute and 30 seconds
        guesses = []
        current_guess = ""
        game_over = False
        won = False
        feedback.reset()  # Reset feedback system
        feedback.show_gif('welcome')
        feedback.show_gif('instructions')

    # Initialize game components
    game_font = pygame.font.Font('Minigame2/PRESSSTART2P.ttf', FONT_SIZE)
    background_image = pygame.image.load("Minigame2/Palak Minigame (7).png")
    background_image = pygame.transform.scale(background_image, (SCREEN_WIDTH, SCREEN_HEIGHT))
    
    secret_word = None
    timer = None
    guesses = None
    current_guess = None
    game_over = None
    won = None
    feedback = FeedbackSystem()
    
    # Initial game setup
    reset_game()

    running = True
    while running:
        screen.blit(background_image, (0, 0))
        draw_grid(screen, game_font, guesses, current_guess, secret_word)
        timer.draw(screen, game_font)
        
        # Update feedback system and check if game should restart
        should_restart = feedback.update(screen, secret_word, game_font)
        if should_restart:
            reset_game()
            continue

        # Check timer warning
        if timer.should_show_warning():
            feedback.show_gif('time')

        # Check timer finished
        if timer.is_finished() and not game_over:
            game_over = True
            timer.stop()
            feedback.show_gif('lost')

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            if event.type == pygame.KEYDOWN:
                if not game_over:
                    if event.key == pygame.K_RETURN:
                        if len(current_guess) < WORD_LENGTH:
                            feedback.show_gif('short')
                        elif len(current_guess) == WORD_LENGTH:
                            guesses.append(current_guess)
                            if current_guess == secret_word or current_guess == "RUSSS":
                                won = True
                                game_over = True
                                timer.stop()
                                feedback.show_gif('won')
                            elif len(guesses) >= GRID_SIZE:
                                game_over = True
                                timer.stop()
                                feedback.show_gif('lost')
                            current_guess = ""
                    elif event.key == pygame.K_BACKSPACE:
                        current_guess = current_guess[:-1]
                    elif len(current_guess) < WORD_LENGTH and event.unicode.isalpha():
                        current_guess += event.unicode.upper()

        pygame.display.flip()

    pygame.quit()

if __name__ == "__main__":
    main()

================
File: FINAL_GAME3.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os
import time
import cv2
import numpy as np
import math
from datetime import datetime, timedelta

def load_minigame(level):
    """Load a minigame module when needed"""
    try:
        if level == 1:
            from mini_game1 import main  # Change to your actual game file/function
            return main()
        elif level == 2:
            from mini_game2 import main  # Change to your actual game file/function
            return main()
        elif level == 3:
            from mini_game3 import main  # Change to your actual game file/function
            return main()
        elif level == 4:
            from mini_game4 import main  # Change to your actual game file/function
            return main()
        elif level == 5:
            from mini_game5 import main  # Change to your actual game file/function
            return main()
    except ImportError as e:
        print(f"Warning: Could not load minigame {level}: {e}")
        return False
    return False


# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Set the desired resolution
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Decoding Island')

# Update these constants at the top of your file
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.17  # Reduced from 0.45
JUMP_SPEED = -7  # Reduced from -13
MOVE_SPEED = 3  # Reduced from 5
game_over = 0
current_level = 0  # 0 for start screen, 1-5 for levels
keys_collected = 0
game_start_time = None
level_times = []
dialogue_states = {}

# Add these with other global variables
paused = False
pause_start_time = None
total_pause_time = timedelta(0)
fade_alpha = 0
fade_target = 180
fade_speed = 15


# You may need to adjust other elements (buttons, player size, etc.) to fit the new resolution
# For example:
# start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
# restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Define colors
WHITE = (255, 255, 255)
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)

# Load images
start_bg = pygame.image.load('img/background.png')
start_bg = pygame.transform.scale(start_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
start_btn = pygame.image.load('img/start_btn.png')
restart_img = pygame.image.load('img/restart_btn.png')
closeddoor_img = pygame.image.load('img/closeddoor.PNG')
opendoor_img = pygame.image.load('img/opendoor_img.PNG')
key_img = pygame.image.load('img/key.png')
npc_img = pygame.image.load('img/WGhost.png')
key_frames = []
target_size = (25, 25)  # Your desired size

# Append Keys
for i in range(1, 13):
    image = pygame.image.load(f'img/AnimatedKey_{i}.png')
    scaled_image = pygame.transform.scale(image, target_size)
    key_frames.append(scaled_image)

# Scale images
closeddoor_img = pygame.transform.scale(closeddoor_img, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
key_img = pygame.transform.scale(key_img, (10, 25 ))
npc_img = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2)))

# Load sounds
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

LEVEL_TIME_LIMITS = {
    0: 60,  # Tutorial: 3 minutes
    1: 60,  # Level 1: 4 minutes
    2: 60,  # Level 2: 5 minutes
    3: 60,  # Level 3: 6 minutes
    4: 60,  # Level 4: 7 minutes
    5: 60   # Level 5: 8 minutes
}

LEVEL_NAMES = {
    0: "The Awakening Path",
    1: "Shadows of Deception",
    2: "Mystic Tower Ascent",
    3: "Cryptic Dominion",
    4: "Phantom's Labyrinth",
    5: "Undead King's Sanctum"
}

# Add new constant for blue platforms
LEVEL_BLUE_DATA = {
    0: [


    ],
    1: [

    ],
    2: [
        (23.2, 3.6, 3, 1.1),
        (26.4, 10.2, 4.8, 1.4),
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6),
    ],
    4: [
        (10, 23.4, 11.3, 1.3),
        (18.5, 23.4, 1, 7.6),
    ],
    5: [
        (26.2, 13.5, 1.7, 1.3),
        (26.4, 20, 4.8, 1.3),
        (19.6, 26.7, 5.3, 1.5),
        (41, 26.7, 5, 1.5),
        (31.1, 26.7, 3.3, 1.5),
    ]
}

# Level platform data (you'll need to adjust these coordinates based on your level designs)
LEVEL_PLATFORM_DATA = {
    0: [
            # Top platforms
            (5.2, 13.4, 6, 2.5),    
            (48, 13.4, 6, 2.5),   

            # small-top platform
            (13.3, 15.5, 1.4, 1.0), 
            (44.4, 15.5, 1.6, 1.0), 
            
            # semi-top platform
            (16.7, 16.6, 4.5, 1.0), 
            (38, 16.6, 4.5, 1.0), 

            # Middle platform
            (26.5, 18.3, 6.2, 2.5),  
            
            # Lower platforms
            (34.6, 23.2, 4.8, 2.5),
            (19.9, 23.2, 4.7, 2.5),
            
            # Bottom platforms
            (11.8, 28, 6.2, 2.5),
            (26.6, 28, 6.2, 2.5),
            (41.3, 28, 8, 1.),
            
            # Ground level
            (0, 33, 8, 3.0),
            (51, 33, 8.2, 3.0),
    ],
    1: [
            # 5th layer
            (23.1, 8.4, 4.8, 1.4),
            (44.5, 8.4, 4.8, 1.4),
            (15, 5.1, 6.2, 3),
            (0, 6.8, 9.8, 1.3),

            # 4th layer
            (28.1, 11.7, 6.4, 3),
            (51.2, 11.7, 6.3, 3),

            # 3rd layer
            (24.8, 15.5, 1.4, 1.7),
            (36.3, 16.6, 4.8, 1.3),
            (44.5, 16.6, 4.8, 1.3),

            # 2nd layer
            (51.1, 21.5, 6.4, 3),
            (36.3, 23.2, 6.4, 1),
            (18.3, 19.9, 9.6, 3),
            (31.3, 19.9, 3.3, 1.4),

            # Ground level
            (44.6, 26.4, 6.4, 3),
            (33, 29.7, 9.7, 3),
            (16.6, 28.1, 4.8, 1.4),
            (16.6, 34.7, 16, 12),

            # Ground Pillars
            (11.7, 23.2, 3.1, 12),
            (6.7, 26.4, 3.1, 9),
            (1.7, 29.8, 3.1, 6)
    ],
    2: [
            # 7th layer
            (13.5, 2, 7.6, 4),
            (10.1, 3.7, 3, 1),
            (0.3, 3.7, 4.6, 1),
            (5.2, 5.3, 1.3, 1),

            # 6th layer
            (51.3, 10.2, 7.5, 5.7),
            (5.2, 8.6, 4.6, 1),

            # 5th layer
            (43, 11.9, 6.3, 1),
            (11.8, 13.5, 4.6, 1),
            (0.2, 13.5, 4.6, 1),

            # 4th layer
            (31.7, 18.1, 1.8, 1.3),
            (42.3, 18.1, 1.8, 1.3),
            (33.3, 15.2, 9.2, 4),
            (0, 18.4, 9.5, 2.5),

            # 3rd layer
            (47.9, 20, 4.7, 1),
            (29.85, 20, 1.3, 1),
            (13.4, 21.7, 6.2, 1),
            (9.9, 20.1, 1.7, 1),

            # 2nd layer
            (48, 26.7, 6.2, 1),
            (41.4, 23.4, 4.6, 1),
            (26.7, 23.4, 7.6, 2.5),
            (7, 25, 14, 5),

            # Ground level
            (0.5, 28.4, 6.6, 8.0),
            (21, 28.4, 6.7, 8.0),
            (43.2, 31.7, 27, 5.0),

            # Ground Pillars
            (39.8, 31.7, 1.2, 3),
            (34.8, 31.7, 1.2, 3),
            (29.9, 31.7, 1.2, 3)
    ],
    3: [
            # 6th layer
            (3.5, 7, 6.2, 1),
            (0.3, 2, 4.3, 2.5),
            (20, 8.5, 3, 1),
            (46.4, 8.5, 11.4, 1),
            (57.8, 0.4, 1.3, 9),
            (29.9, 3.7, 9.5, 1),
            (48, 3.7, 4.6, 1),
            

            # 5th layer
            (26.4, 11.5, 2.8, 1.3),
            (25, 8.6, 1.4, 4.3),
            (11.5, 10.2, 5, 1),


            # 4th layer
            (18.1, 10.3, 1.7, 5.8),
            (7.1, 14.8, 10.9, 1.3),
            (31.5, 13.6, 3, 0.8),
            (36.5, 16.8, 7.8, 0.8),

            # 3rd layer
            (51.3, 20.1, 2.8, 5.7),
            (44.8, 20.1, 2.8, 5.7),
            (47.6, 24.8, 3.8, 1),
            (33.2, 23.4, 7.8, 1),
            (9.9, 25, 11.3, 1),
            (1.4, 20.1, 6.5, 5.8),
            (23.4, 18.5, 7.5, 4.2),
            (11.8, 21.8, 3, 0.8),
            (1.7, 13.6, 1.6, 1),
            (37.9, 11.9, 1.6, 1),
            (43, 10.3, 1.2, 2.7),
            (16.7, 13.5, 1.3, 1.3),
            

            # 2nd layer
            (34.8, 30, 2.9, 1),
            (26.7, 26.7, 5.9, 1),
            (31.3, 26.7, 1.4, 5.8),
            (23.6, 31.3, 7.7, 1.2),
            (10, 28.4, 4.8, 1),
            (21.6, 21.9, 1.4, 2.3),
            (19.8, 18.5, 1.6, 1),
            (8.3, 20, 1.6, 1),
            (0.1, 18.4, 1.6, 1),


            # Ground level
            (0.3, 35, 19, 6),
            (23.4, 35, 20.6, 6),
            (46.6, 35, 12.6, 6)
    ],
    4: [
            # 4th layer
            (33.2, 15.2, 7.8, 5.8),
            (31.3, 16.8, 2, 1),

            (6.8, 11.9, 5, 1),
            (10.2, 5.3, 3, 2.4),
            (15, 21.9, 1.2, 2),
            (13, 7, 1.8, 2.3),

            (19.9, 7, 1.2, 2.3),
            (21.4, 5.2, 1.3, 11),
            (22.6, 7, 1.8, 1),
            (11.9, 5.3, 1.1, 10.9),
            (13, 14.9, 8.4, 1.3),
            (16.4, 8.5, 1.7, 1),
            (14.9, 11.9, 5, 1),

            (24.8, 11.9, 3, 1),
            (46, 11.9, 5, 1),
            (44.4, 16.8, 6.6, 1),

            (51, 20, 8, 1),
            (38.1, 0, 1.3, 8),
            (39.3, 6.8, 6.3, 1.2),
            (39.3, 3.5, 1.7, 1),



            # 3rd layer
            (8.5, 21.8, 1.5, 1),
            (21.2, 21.8, 1.5, 1),
            (16.9, 29.5, 1.6, 1.5),
            (19.4, 29.5, 1.6, 1.5),
            (26.4, 20, 1.8, 1),
            (29.4, 20, 1.8, 1),
            (28.2, 15.2, 1.2, 9.3),
            (26.4, 23.4, 1.8, 1),
            (29.4, 23.4, 3.3, 1),
            

            # 2nd layer
            (6.9, 28.3, 4.3, 1),
            (1.7, 25, 6.3, 1),
            (0, 20, 8, 1),
            (0, 15.1, 5, 1),
            (11.9, 26.7, 1.3, 6),
            (13, 31.2, 1.3, 1.4),
            (11.9, 26.6, 6.7, 1),
            (23, 26.7, 5, 1),
            (33, 26.7, 3, 1),
            (39, 38.2, 5, 1),
            (29.8, 30, 3, 1),
            (56, 30, 3, 1),
            (41, 23.4, 5, 1),
            (52.9, 33.1, 2.9, 4),
            (38, 28.2, 5, 1),
            (46, 26.7, 6.7, 5.8),
            (44.7, 31.2, 1.5, 1.3),


            # Ground level
            (0, 33.3, 6.3, 6),
            (6.7, 34.9, 3, 6),
            (11.6, 34.9, 8.1, 6),
            (21.6, 34.9, 1.3, 6),
            (23, 33.2, 6.5, 0.9),
            (34.7, 33.3, 9.5, 6)
    ],
    5: [

            (0, 5.2, 9.5, 1),
            (0, 13.5, 11.4, 1),
            (0.2, 23.4, 1.1, 14),
            (3.5, 26.7, 1.4, 11),

            (6.8, 30, 3, 1),
            (6.7, 23.4, 3, 1),
            (10, 18.5, 4.6, 1),
            (10, 26.7, 8.2, 1.5),
            (26.3, 26.7, 5.3, 1.5),
            (36.1, 26.7, 3.7, 1.5), 

            (15, 13.5, 3, 1), 
            (18, 8.5, 5, 1),
            (49.3, 30, 3.3, 1.1), 
            (46, 23.3, 6.5, 1),
            (44.4, 18.5, 4.8, 1),

            (16.5, 20, 5, 1.3),
            (23, 20, 1.7, 1.3),
            (33, 20, 3.3, 1.3),
            (38, 20, 4.7, 1.3),
            (41.2, 13.5, 3.2, 1),
            (29.7, 7, 6.5, 1.1),
            (22.9, 7, 5, 1.2),

            (19.8, 13.5, 5, 1.3),
            (29.6, 13.5, 1.7, 1.3),
            (34.4, 13.5, 5.2, 1.3),
            (36.4, 8.5, 4.5, 1.2),
            (42.9, 5.3, 6.5, 1),
            (51, 15, 8, 1),

            (15.1, 26.8, 1, 8),
            (43.1, 26.8, 1, 8),
            (21.7, 13.6, 1.2, 7.7),
            (36.5, 13.6, 1.2, 7.7),
            (18.4, 20, 1, 8.1), 
            (39.9, 20, 1, 8.1),
            (25, 7, 1, 7.8),
            (33.3, 7, 1, 7.8),

            (54.5, 26.8, 1.2, 11),
            (57.9, 23.4, 1.2, 14),
            (51.3, 3.2, 1.5, 6.3),
            (53, 8.3, 4.4, 1.3),
            (57.6, 3.3, 1.5, 6),
            (54.3, 5, 1.7, 1.3),

            (28.2, 12, 1.2, 2.5), 
            (31.5, 18.5, 1.3, 2.5),
            (25, 25, 1, 3),
            (34.9, 31.7, 1, 3),
            (17.7, 31.5, 1.8, 1),

            (9.9, 33.2, 5, 1.3),
            (19.4, 33.2, 7.3, 1.3),
            (29.4, 33.2, 5.4, 1.3),
            (36, 33.2, 5.5, 1.3),
            (44, 33.2, 5.3, 1.3)
    ]
}

# 1. Fix the level_backgrounds initialization
level_backgrounds = {
    0: {'type': 'video', 'path': 'Level Data/Level Image/Level0_Background.mp4'},
    1: {'type': 'video', 'path': 'Level Data/Level Image/Level1_Background.mp4'},
    2: {'type': 'video', 'path': 'Level Data/Level Image/Level2_Background.mp4'},
    3: {'type': 'video', 'path': 'Level Data/Level Image/Level3_Background.mp4'},
    4: {'type': 'video', 'path': 'Level Data/Level Image/Level4_Background.mp4'},
    5: {'type': 'image', 'path': 'Level Data/Level Image/Level5.png'}
}

# Initialize video capture and load images
background_surfaces = {}
video_captures = {}

for level, bg_data in level_backgrounds.items():
    if bg_data['type'] == 'video':
        try:
            video_captures[level] = cv2.VideoCapture(bg_data['path'])
        except Exception as e:
            print(f"Error loading video for level {level}: {e}")
            # Fallback to a solid color or default image
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))
    else:
        try:
            img = pygame.image.load(bg_data['path']).convert()
            background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except Exception as e:
            print(f"Error loading image for level {level}: {e}")
            # Fallback to a solid color
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))

# Update collision tile creation (in World class):
def __init__(self, level_data, deadly_data):
    self.collision_tiles = []
    self.deadly_tiles = []

    for plat in level_data:
        # Adjust coordinates to align with background
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        height = int(plat[3] * TILE_SIZE)
        
        # Add small margin for better collision
        margin = 2
        collision_rect = pygame.Rect(
            x + margin,
            y + margin,
            width - margin * 2,
            height - margin * 2
        )
        self.collision_tiles.append(CollisionTile(x, y, width, height))

    for deadly in deadly_data:
        x = deadly[0] * TILE_SIZE
        y = deadly[1] * TILE_SIZE
        width = deadly[2] * TILE_SIZE
        height = int(deadly[3] * TILE_SIZE)
        
        # Add similar margin for deadly tiles
        margin = 2
        self.deadly_tiles.append(CollisionTile(
            x + margin, 
            y + margin, 
            width - margin * 2, 
            height - margin * 2
        ))

    
# Add Level 0 to LEVEL_REQUIREMENTS
LEVEL_REQUIREMENTS = {
    0: 3,  # For tutorial level
    1: 4,
    2: 5,
    3: 6,
    4: 8,
    5: 10
}

# Update STORYLINE dictionary to match story document
STORYLINE = {
    "intro": [
        "You remember the moment you stumbled upon the ancient artifact, half-buried in the basement of that old library.",
        "It was a stone box, covered in intricate, interlocking symbols that seemed to shift if you stared too long.",
        "As you worked, carefully pressing and turning parts of the stone, the symbols clicked into alignment.",
        "The box opened, releasing a chill that seeped straight to your bones.",
        "Inside was a brittle parchment with haunting words: 'Whoever unlocks these secrets is bound to us.'",
        "'Your presence is now required. The island awaits.'"
    ],
    "level0": [
        "The ghostly voice of Eralt lingers in the air as you begin.",
        '"Beware, young master. The island knows your fears, your weaknesses."',
        '"Solve the code, and move closer to your destiny."',
        '"Fail, and join the lost souls who could not decode the island\'s secrets."',
        '"Master?.." With your heart pounding, you take a deep breath and step forward,',
        "ready to solve the first of many mysteries in this shadowy realm."
    ],
    "level1": [
        "As you decipher the shifting symbols on the stone slab, a sudden flash of blinding light erupts.",
        "When it fades, a figure steps forward with silent, lethal grace.",
        "Dressed in dark, flowing robes and wielding twin daggers that glint in the moonlight,",
        "she introduces herself with a cold smile.",
        '"I am Palak, the Assassin, Guardian of the First Level."',
        '"To pass my challenge, you must prove you can see through deception and lies."',
        '"Codes are more than wordsthey\'re veils of truth and deceit. Decipher mine, or face the consequences."'
    ],
    "level2": [
        "The mist pulls you forward to a spiraling tower covered in ancient runes.",
        "At the top waits Russ, the Wizard. His eyes hold the gleam of forbidden knowledge.",
        '"Ah, the new champion has arrived."',
        "He gestures to a puzzle box floating in mid-air, surrounded by a shimmering aura.",
        '"This test is one of patience and intellect."',
        '"You must unlock this box without using brute force; the wrong twist will reset it."',
        '"Fail, and your mind will be trapped in an endless loop."'
    ],
    "level3": [
        "The scenery morphs into a grand, oppressive throne room.",
        "Seated on the throne is Geoff, the Autocrat, draped in black, a crown of thorns upon his brow.",
        '"So you\'ve passed the others. But codes are not just puzzles; they\'re tools of control, of power."',
        '"I rule through secrets."',
        "He gestures to an enormous map with encrypted marks scattered across it.",
        '"Your task is to decipher the locations on this map."',
        '"Fail, and you will be exiled into the barren lands."'
    ],
    "level4": [
        "The shadows deepen, and you're surrounded by a ghostly fog.",
        "From it, a figure in tattered, ethereal robes emergesJessica, the Wraith.",
        "Her eyes glow with an eerie, otherworldly light as she glides toward you.",
        '"You are brave, but bravery means nothing in the face of fear."',
        '"This trial is not of logic, but of your darkest nightmares."',
        "A mirror appears, showing twisted images of your deepest fears.",
        '"Face your fears, or be lost to them forever."'
    ],
    "level5": [
        "You arrive at a shadowy castle ruin where the final guardian awaits: Jacobo, the Undead King.",
        "His skeletal form radiates an unholy power, and his hollow eyes burn with a fierce light.",
        '"You stand before the final trial, mortal."',
        '"I am Jacobo, the Undead King, master of the lost and forgotten."',
        '"To claim victory, you must decipher the oldest code of all,"',
        '"the language of life and death itself."'
    ],
    "ending": [
        "The tome releases a blinding light. When it fades, you're back on the beach.",
        "The island seems quiet, as if holding its breath. But something is differentyou can feel it.",
        "As you touch the sand, it shifts, forming into a new message:",
        '"Congratulations, you have proven yourself. But know this:"',
        '"The title of decoding master is not a prize, but a burden."',
        '"The codes you hold now contain secrets that even the spirits dare not speak."',
        '"Guard them well, for they will change everything."'
    ]
}

# Update LEVEL_DIALOGUES dictionary to add Level 0
LEVEL_DIALOGUES = {
    0: [
        "Tutorial Level: Learning the Basics",
        "Master the art of movement and key collection.",
        "Collect 3 keys to proceed to your first real challenge.",
        "Press SPACE to continue..."
    ],
    1: [
        "Level 1: The Assassin's Trial",
        "Find 4 keys while avoiding deadly traps.",
        "Press SPACE to continue..."
    ],
    2: [
        "Level 2: The Wizard's Tower",
        "Collect 5 keys hidden by magical illusions.",
        "Press SPACE to continue..."
    ],
    3: [
        "Level 3: The Autocrat's Domain",
        "Gather 6 keys from this sprawling fortress.",
        "Press SPACE to continue..."
    ],
    4: [
        "Level 4: The Wraith's Nightmare",
        "Find 8 keys in this realm of shadows.",
        "Press SPACE to continue..."
    ],
    5: [
        "Final Level: The Undead King's Castle",
        "Collect all 10 keys to complete your journey.",
        "Press SPACE to continue..."
    ]
}

LEVEL_DEADLY_DATA = {
    0: [

        
    ],
    1: [
        
    ],
    2: [
        (23.2, 3.6, 3, 1),
        (26.4, 10.2, 4.8, 1.3),
        (28, 34, 15, 1)
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6),
    ],
    4: [
        (10, 22.4, 11.3, 1.3),
    ],
    5: [
        (0.2, 34, 59, 4),
        (15.4, 28, 2.2, 3),
        (22, 25.4, 2, 2),
        (25, 12, 2.4, 2.7),
        (28.4, 18.7, 2.4, 2.3),
        (31.8, 25.2,  2.3, 2),
        (26.9, 32, 2, 2),
        (40.2, 25.3, 2, 2),
        (41.7, 30.3, 2, 2),
    ]
}

# Update LEVEL_ENEMY_DATA to include boundary information:
LEVEL_ENEMY_DATA = {
    0: [

        
    ],
    1: [
        (17, 33.4, "horizontal", 17, 32),
        (0.2, 5.5, "horizontal", 0.2, 8.5),
        (36.2, 22, "horizontal", 36.2, 41.2),
        (50.5, 10.6, "horizontal", 50.5, 56),    # x, y, direction, boundary_start, boundary_end
        (18.5, 19, "horizontal", 18.5, 27.2)  # x, y, direction, boundary_start, boundary_end
    ],
    2: [
        (8.5, 24, "horizontal", 8.5, 20),
        (0.2, 17.2, "horizontal", 0.2, 8.7),
        (44.5, 30.5, "horizontal", 44, 58.5),
        (35, 14, "horizontal", 35, 41),
        (52.3, 9.1, "horizontal", 52.3, 58.5),
        
    ],
    3: [
        (10.5, 24, "horizontal", 10.5, 20.5),
        (24, 34, "horizontal", 24, 43),
        (8, 13.6, "horizontal", 8, 16.5),
        (30, 2.6, "horizontal", 30, 38.5),
        (48, 6.4, "horizontal", 48, 57),
        (37.5, 13.8, "horizontal", 37.5, 43.5),
    ],
    4: [

    ],
    5: [

        (0, 4.2, "horizontal", 0, 9.5),
        (0, 12.5, "horizontal", 0, 11.4),

        (10, 25.7, "horizontal", 10, 18.2),

        (41, 25.7, "horizontal", 41, 45),

        (16.5, 19, "horizontal", 16.5, 22.3),
        
        (38, 19, "horizontal", 38, 42),

        (19.8, 12.5, "horizontal", 19.8, 24),

        (34.4, 12.5, "horizontal", 34.4, 39.7),
        (42.9, 4.3, "horizontal", 42.9, 48.9),
        (51, 14, "horizontal", 51, 59),

        (44, 32.2, "horizontal", 44, 49),
        (10, 32.2, "horizontal", 10, 14)
    ]
}

class PauseButton:
    def __init__(self, screen):
        self.screen = screen
        # Create button in top right corner with padding
        self.rect = pygame.Rect(SCREEN_WIDTH - 120, 10, 100, 30)
        self.color = (0, 0, 0, 180)  # Semi-transparent black
        self.hover_color = (50, 50, 50, 180)
        self.font = pygame.font.SysFont('Bauhaus 93', 24)
        self.text = self.font.render('PAUSE', True, (255, 255, 255))
        self.text_rect = self.text.get_rect(center=self.rect.center)
        self.is_hovered = False

    def draw(self):
        # Create surface with alpha for transparency
        button_surface = pygame.Surface((self.rect.width, self.rect.height), pygame.SRCALPHA)
        
        # Draw button with hover effect
        color = self.hover_color if self.is_hovered else self.color
        pygame.draw.rect(button_surface, color, button_surface.get_rect(), border_radius=5)
        
        # Draw button on screen
        self.screen.blit(button_surface, self.rect)
        self.screen.blit(self.text, self.text_rect)

    def handle_event(self, event):
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1 and self.rect.collidepoint(event.pos):
                return True
        return False

class EnhancedGameStats:
    def __init__(self, screen):
        self.screen = screen
        
        # Load and scale icons with more reasonable size
        try:
            icon_size = (32, 32)  # Reduced from 40
            self.trophy_icon = pygame.transform.scale(pygame.image.load('img/trophy.png'), icon_size)
            self.key_icon = pygame.transform.scale(pygame.image.load('img/key_icon.png'), icon_size)
            self.clock_icon = pygame.transform.scale(pygame.image.load('img/clock.png'), icon_size)
        except Exception as e:
            print(f"Error loading game stats icons: {e}")
            self.trophy_icon = pygame.Surface(icon_size)
            self.trophy_icon.fill((255, 215, 0))
            self.key_icon = pygame.Surface(icon_size)
            self.key_icon.fill((255, 255, 255))
            self.clock_icon = pygame.Surface(icon_size)
            self.clock_icon.fill((100, 200, 255))
        
        # Fonts with better sizes
        self.title_font = pygame.font.SysFont('Bauhaus 93', 28)
        self.stats_font = pygame.font.SysFont('Bauhaus 93', 24)
        self.small_font = pygame.font.SysFont('Bauhaus 93', 20)

    def draw_stats_panel(self, level, keys_collected, required_keys, elapsed_time, time_limit):
        # Main panel dimensions
        panel_width = 600  # Fixed width
        panel_height = 40  # Reduced height
        panel_x = (SCREEN_WIDTH - panel_width) // 2  # Center horizontally
        panel_y = 10  # Top padding
        
        # Create semi-transparent panel
        panel_surface = pygame.Surface((panel_width, panel_height), pygame.SRCALPHA)
        pygame.draw.rect(panel_surface, (0, 0, 0, 150), (0, 0, panel_width, panel_height), border_radius=10)
        
        # Section widths
        section_width = panel_width // 3
        
        # Level name (left section)
        level_text = f"{LEVEL_NAMES[level]}"
        name_surface = self.stats_font.render(level_text, True, (255, 215, 0))
        name_x = 20  # Left padding
        name_y = (panel_height - name_surface.get_height()) // 2
        panel_surface.blit(name_surface, (name_x, name_y))
        
        # Time remaining (middle section)
        remaining_time = time_limit - elapsed_time
        minutes = int(remaining_time // 60)
        seconds = int(remaining_time % 60)
        timer_text = self.stats_font.render(f"{minutes:02}:{seconds:02}", True, (255, 255, 255))
        timer_x = section_width + (section_width - timer_text.get_width()) // 2
        timer_y = (panel_height - timer_text.get_height()) // 2
        panel_surface.blit(timer_text, (timer_x, timer_y))
        
        # Keys collected (right section)
        key_text = self.stats_font.render(f"{keys_collected}/{required_keys}", True, (255, 255, 255))
        key_x = section_width * 2 + (section_width - key_text.get_width() - self.key_icon.get_width() - 5) // 2
        key_y = (panel_height - key_text.get_height()) // 2
        panel_surface.blit(self.key_icon, (key_x, key_y))
        panel_surface.blit(key_text, (key_x + self.key_icon.get_width() + 5, key_y))
        
        # Draw the panel on screen
        self.screen.blit(panel_surface, (panel_x, panel_y))

class PauseMenu:
    def __init__(self, screen):
        self.screen = screen
        self.options = ['RESUME', 'RESTART LEVEL', 'QUIT TO MENU']
        
        # Button dimensions and styling
        self.button_width = 250
        self.button_height = 40
        self.button_spacing = 20
        
        # Create button rects centered on screen
        self.button_rects = []
        start_y = SCREEN_HEIGHT // 2
        for i in range(len(self.options)):
            rect = pygame.Rect(
                (SCREEN_WIDTH - self.button_width) // 2,
                start_y + (self.button_height + self.button_spacing) * i,
                self.button_width,
                self.button_height
            )
            self.button_rects.append(rect)
            
        # Fonts
        self.title_font = pygame.font.SysFont('Bauhaus 93', 50)
        self.option_font = pygame.font.SysFont('Bauhaus 93', 35)
        
        # Colors
        self.text_color = (255, 255, 255)
        self.button_color = (50, 50, 50, 180)
        self.hover_color = (70, 70, 70, 180)
        self.selected_color = (255, 215, 0)
        
        self.hovered = None

    def draw(self):
        # Draw dark overlay
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        
        # Draw PAUSED text
        pause_text = self.title_font.render('PAUSED', True, self.text_color)
        text_rect = pause_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//4))
        self.screen.blit(pause_text, text_rect)
        
        # Get mouse position
        mouse_pos = pygame.mouse.get_pos()
        
        # Draw buttons with hover effect
        for i, (option, rect) in enumerate(zip(self.options, self.button_rects)):
            # Check if mouse is hovering over button
            is_hovered = rect.collidepoint(mouse_pos)
            if is_hovered:
                self.hovered = i
                color = self.hover_color
            else:
                color = self.button_color
            
            # Create button surface with alpha
            button_surface = pygame.Surface((rect.width, rect.height), pygame.SRCALPHA)
            pygame.draw.rect(button_surface, color, button_surface.get_rect(), border_radius=5)
            self.screen.blit(button_surface, rect)
            
            # Draw button text
            text = self.option_font.render(option, True, self.selected_color if is_hovered else self.text_color)
            text_rect = text.get_rect(center=rect.center)
            self.screen.blit(text, text_rect)

    def handle_input(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            mouse_pos = pygame.mouse.get_pos()
            for i, rect in enumerate(self.button_rects):
                if rect.collidepoint(mouse_pos):
                    return self.options[i]
        return None

def handle_pause():
    """Handle pause menu state and actions"""
    global paused, running, current_state, keys_collected, game_over, total_pause_time, pause_start_time
    
    pause_menu.draw()
    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            return False
            
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                paused = False
                total_pause_time += datetime.now() - pause_start_time
                return True
                
        action = pause_menu.handle_input(event)
        if action:
            if action == 'RESUME':
                paused = False
                total_pause_time += datetime.now() - pause_start_time
            elif action == 'RESTART LEVEL':
                paused = False
                game_over = 0
                keys_collected = 0
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                camera.cleanup()
                camera.reset_zoom()
                keys_group, door, world, moving_enemies, player, ghost = init_level(current_level)
                camera.start_transition()
            elif action == 'QUIT TO MENU':
                paused = False
                current_state = "start_screen"
                game_over = 0
                keys_collected = 0
    
    pygame.display.update()
    return True

class DialogueBox:
    def __init__(self, screen):
        self.screen = screen
        self.animation_complete = False
        self.current_alpha = 0
        self.target_alpha = 230
        self.fade_speed = 10
        self.current_line = 0
        self.current_word = 0
        self.current_char = 0
        self.text_delay = 2  # Controls typing speed
        self.frame_counter = 0
        self.words_revealed = []  # List to store revealed words for each line
        
    def animate(self, dialogue_lines):
        # Create semi-transparent background
        dialogue_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        dialogue_surface.fill(BLACK)
        
        # Animate fade in
        if self.current_alpha < self.target_alpha:
            self.current_alpha = min(self.current_alpha + self.fade_speed, self.target_alpha)
        dialogue_surface.set_alpha(self.current_alpha)
        self.screen.blit(dialogue_surface, (0, 0))
        
        # Initialize words_revealed list if needed
        if not self.words_revealed:
            self.words_revealed = [[] for _ in dialogue_lines]
        
        # Calculate text position for centering
        total_height = len(dialogue_lines) * 60
        start_y = (SCREEN_HEIGHT - total_height) // 2
        
        # Update text animation
        self.frame_counter += 1
        if self.frame_counter >= self.text_delay:
            self.frame_counter = 0
            self.update_text(dialogue_lines)
        
        # Draw text
        for i, line in enumerate(dialogue_lines):
            # Split line into words
            words = line.split()
            revealed_text = ' '.join(self.words_revealed[i])
            
            text_surface = pygame.font.SysFont('Bauhaus 93', 40).render(
                revealed_text, True, WHITE)
            text_rect = text_surface.get_rect(center=(SCREEN_WIDTH // 2, start_y + i * 60))
            self.screen.blit(text_surface, text_rect)
        
        # Add "Press SPACE to continue" prompt when animation is complete
        if self.animation_complete:
            prompt = pygame.font.SysFont('Bauhaus 93', 30).render(
                "Press SPACE to continue...", True, (200, 200, 200))
            prompt_rect = prompt.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
            self.screen.blit(prompt, prompt_rect)
        
        return self.animation_complete
    
    def update_text(self, dialogue_lines):
        if self.current_line < len(dialogue_lines):
            words = dialogue_lines[self.current_line].split()
            
            if self.current_word < len(words):
                # Add next word
                self.words_revealed[self.current_line].append(words[self.current_word])
                self.current_word += 1
            else:
                # Move to next line
                self.current_line += 1
                self.current_word = 0
        else:
            self.animation_complete = True

# Update the show_dialogue function to properly handle space key:
def show_dialogue(dialogue_lines):
    dialogue_box = DialogueBox(screen)
    
    waiting = True
    space_pressed = False
    
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                    return True  # Always return True when space is pressed
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

class Ghost(pygame.sprite.Sprite):
    def __init__(self, screen_width, screen_height, player, level):
        super().__init__()
        # Load and scale ghost image
        self.image = pygame.image.load('img/sghost.png').convert_alpha()
        self.image = pygame.transform.scale(self.image, (60, 60))
        self.rect = self.image.get_rect()
        
        # Ghost properties - Make ghost slower in higher levels
        self.base_speed = 2.0
        # Decrease speed for each level instead of increasing
        self.level_speed_multiplier = -0.25  # Changed from 0.4 to -0.25
        # Set minimum speed to prevent ghost from becoming too slow
        self.speed = max(0.8, self.base_speed + (level * self.level_speed_multiplier))
        self.player = player
        
        # Decrease visibility range in higher levels
        self.visibility_range = max(400, 600 - (level * 50))  # Starts at 600, decreases by 50 each level
        
        # Set initial position
        self.spawn_position(screen_width, screen_height)
        
        # Floating movement properties
        self.float_offset = 0
        self.float_speed = 0.05
        self.float_amplitude = 8
        self.true_x = float(self.rect.x)
        self.true_y = float(self.rect.y)
        
        # Transparency properties - Make ghost more transparent in higher levels
        self.min_alpha = max(80, 120 - (level * 10))  # Starts at 120, decreases by 10 each level
        
        # Pulsing effect
        self.pulse_counter = 0
        self.pulse_speed = 0.05
        self.pulse_range = max(20, 40 - (level * 5))  # Reduced pulsing range in higher levels

    def spawn_position(self, screen_width, screen_height):
        """Spawn ghost at the farthest point from player"""
        corners = [
            (0, 0),
            (screen_width - self.rect.width, 0),
            (0, screen_height - self.rect.height),
            (screen_width - self.rect.width, screen_height - self.rect.height)
        ]
        
        max_distance = 0
        spawn_pos = corners[0]
        
        for corner in corners:
            distance = math.sqrt(
                (corner[0] - self.player.rect.x) ** 2 + 
                (corner[1] - self.player.rect.y) ** 2
            )
            if distance > max_distance:
                max_distance = distance
                spawn_pos = corner
        
        self.rect.x = spawn_pos[0]
        self.rect.y = spawn_pos[1]
        self.true_x = float(self.rect.x)
        self.true_y = float(self.rect.y)

    def update(self):
        if not movement_enabled or camera.door_zoom:
            return
            
        # Calculate direction to player
        dx = self.player.rect.centerx - self.rect.centerx
        dy = self.player.rect.centery - self.rect.centery
        
        # Normalize the direction
        distance = math.sqrt(dx ** 2 + dy ** 2)
        if distance > 0:
            dx = dx / distance
            dy = dy / distance
        
        # Update position with adjusted tracking
        distance_factor = min(1.0, distance / self.visibility_range)  # Reduced from 1.5 to 1.0
        actual_speed = self.speed * distance_factor
        
        self.true_x += dx * actual_speed
        self.true_y += dy * actual_speed
        
        # Add floating movement
        self.float_offset += self.float_speed
        float_y = math.sin(self.float_offset) * self.float_amplitude
        
        # Update rect position
        self.rect.x = int(self.true_x)
        self.rect.y = int(self.true_y + float_y)
        
        # Update pulsing effect
        self.pulse_counter += self.pulse_speed
        pulse_alpha = math.sin(self.pulse_counter) * self.pulse_range
        
        # Calculate alpha with reduced visibility range
        current_distance = math.sqrt(
            (self.player.rect.centerx - self.rect.centerx) ** 2 + 
            (self.player.rect.centery - self.rect.centery) ** 2
        )
        
        # Calculate alpha with pulsing effect
        base_alpha = max(self.min_alpha, min(255, (1 - current_distance / self.visibility_range) * 255))
        final_alpha = min(255, max(self.min_alpha, base_alpha + pulse_alpha))
        
        # Apply alpha
        self.image.set_alpha(int(final_alpha))

    def check_collision(self, player):
        """Check for collision with player using a larger collision margin in higher levels"""
        # Increase collision margin for higher levels to make it more forgiving
        collision_margin = 8 + (current_level * 2)  # Increases by 2 pixels per level
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)
    
def check_level_timer(elapsed_time, time_limit):
    """Check if the level time limit has been exceeded"""
    return elapsed_time >= time_limit

class Camera:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.scroll_x = 0
        self.scroll_y = 0
        self.zoom = 1
        self.target_zoom = 1
        self.base_zoom = 2.5
        self.zoom_out_level = 1.3
        self.zoom_speed = 0.04
        self.transitioning = False
        self.transition_start_time = 0
        self.transition_delay = 2000
        self.transition_duration = 2000
        self.transition_total_time = self.transition_delay + self.transition_duration
        self.transition_complete = False
        self.manual_zoom_active = False
        self.initial_zoom_done = False
        
        # Door zoom properties
        self.door_zoom = False
        self.door_zoom_target = None
        self.door_zoom_speed = 0.02
        self.door_target_zoom = 3.5
        self.door_transition_start = 0
        self.door_transition_duration = 1500
        self.post_open_delay = 1000
        self.door_opened_time = 0
        self.reset_on_death = False
        self.death_reset_time = 0
        self.death_reset_duration = 1000  # 1 second for reset animation
        
        # Sound properties
        self.wind_sound = pygame.mixer.Sound('img/Gust of Wind.mp3')
        self.jungle_music = pygame.mixer.Sound('img/Background Music.MP3')
        self.zoom_out_sound = pygame.mixer.Sound('img/zoom_out.mp3')  # Add this line
        self.wind_sound.set_volume(0.8)
        self.jungle_music.set_volume(0.4)
        self.zoom_out_sound.set_volume(0.5)  # Add this line
        self.wind_sound_playing = False
        self.jungle_music_playing = False
        self.wind_sound_start_time = 0
        self.wind_sound_duration = int(self.wind_sound.get_length() * 1000)
        
        self.visible_width = width
        self.visible_height = height

    def reset_zoom(self):
        """Reset camera zoom when player dies"""
        self.reset_on_death = True
        self.death_reset_time = pygame.time.get_ticks()
        self.zoom = self.base_zoom
        self.target_zoom = self.base_zoom
        self.manual_zoom_active = False
        self.door_zoom = False
        self.door_zoom_target = None
        self.transitioning = False
        self.initial_zoom_done = True

    def start_door_zoom(self, door):
        if not self.door_zoom and not self.manual_zoom_active:
            self.door_zoom = True
            self.door_zoom_target = door
            self.door_transition_start = pygame.time.get_ticks()
            self.door_target_zoom = 3.5
            # All entities will freeze due to the door_zoom check in their update methods
        
    def start_transition(self):
        # Stop any existing sounds before starting new ones
        self.stop_sounds()
        self.transitioning = True
        self.transition_complete = False
        self.zoom = 1
        self.transition_start_time = pygame.time.get_ticks()
        
        # Start wind sound and track its start time
        self.wind_sound.play()
        self.wind_sound_playing = True
        self.wind_sound_start_time = pygame.time.get_ticks()
        self.jungle_music_playing = False
    
    def update(self, target, keys_collected, door, required_keys):
        current_time = pygame.time.get_ticks()
        
        # Handle manual zoom control with Enter key
        keys = pygame.key.get_pressed()
        if keys[pygame.K_RETURN]:
            self.manual_zoom_active = True
            self.target_zoom = self.zoom_out_level
            self.zoom_out_sound.play()
        elif self.manual_zoom_active:
            self.manual_zoom_active = False
            self.target_zoom = self.base_zoom if self.transition_complete else 1
        
        # Handle initial transition
        if self.transitioning and not self.initial_zoom_done:
            elapsed = current_time - self.transition_start_time
            
            if elapsed >= self.transition_delay:
                zoom_elapsed = elapsed - self.transition_delay
                progress = min(zoom_elapsed / self.transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                if not self.manual_zoom_active:
                    self.zoom = 1 + (self.base_zoom - 1) * progress
                
                if progress >= 1:
                    self.transitioning = False
                    self.transition_complete = True
                    self.initial_zoom_done = True
                    if not self.manual_zoom_active:
                        self.zoom = self.base_zoom
                        self.target_zoom = self.base_zoom
        
        # Handle smooth zoom transition
        elif not self.door_zoom:
            if self.zoom != self.target_zoom:
                diff = self.target_zoom - self.zoom
                self.zoom += diff * self.zoom_speed
        
        # Handle door zoom if active
        if self.door_zoom and self.door_zoom_target:
            elapsed = current_time - self.door_transition_start
            
            if not self.door_zoom_target.is_open:
                progress = min(elapsed / self.door_transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                self.zoom = 1 + (self.door_target_zoom - 1) * progress
                
                # Calculate center position for the door
                target_x = self.door_zoom_target.rect.centerx - (SCREEN_WIDTH // (2 * self.zoom))
                target_y = self.door_zoom_target.rect.centery - (SCREEN_HEIGHT // (2 * self.zoom))
                
                # Smoothly move camera to center the door
                self.scroll_x += (target_x - self.scroll_x) * 0.1
                self.scroll_y += (target_y - self.scroll_y) * 0.1
                
                if progress >= 1.0:
                    self.door_zoom_target.open_door()
                    self.door_opened_time = current_time
            else:
                hold_time = current_time - self.door_opened_time
                if hold_time >= self.post_open_delay:
                    zoom_out_progress = min((hold_time - self.post_open_delay) / 1000, 1.0)
                    zoom_out_progress = self.ease_out_cubic(zoom_out_progress)
                    
                    target_zoom = self.target_zoom
                    self.zoom = self.door_target_zoom - (self.door_target_zoom - target_zoom) * zoom_out_progress
                    
                    if zoom_out_progress >= 1.0:
                        self.door_zoom = False
                        self.zoom = target_zoom
        
        # Handle death reset
        if self.reset_on_death:
            elapsed = current_time - self.death_reset_time
            if elapsed <= self.death_reset_duration:
                # Smoothly transition zoom back to base level
                progress = elapsed / self.death_reset_duration
                progress = self.ease_out_cubic(progress)
                self.zoom = 1 + (self.base_zoom - 1) * progress
            else:
                self.reset_on_death = False
                self.zoom = self.base_zoom
                self.target_zoom = self.base_zoom
        
        # Update sound behavior
        if (self.wind_sound_playing and 
            current_time - self.wind_sound_start_time >= self.wind_sound_duration and 
            not self.jungle_music_playing):
            self.wind_sound_playing = False
            self.jungle_music.play()
            self.jungle_music_playing = True
        
        # Update visible area and camera position
        self.visible_width = self.width // self.zoom
        self.visible_height = self.height // self.zoom
        
        # Normal camera follow behavior when not zooming to door
        if not self.door_zoom:
            target_x = target.rect.centerx - self.visible_width // 2
            target_y = target.rect.centery - self.visible_height // 2
            
            self.scroll_x += (target_x - self.scroll_x) * 0.1
            self.scroll_y += (target_y - self.scroll_y) * 0.1
        
        # Keep the camera within bounds
        self.scroll_x = max(0, min(self.scroll_x, SCREEN_WIDTH - self.visible_width))
        self.scroll_y = max(0, min(self.scroll_y, SCREEN_HEIGHT - self.visible_height))
    
    def stop_sounds(self):
        """Stop all sounds and reset sound states"""
        try:
            if pygame.mixer.get_init():  # Check if mixer is initialized
                self.wind_sound.stop()
                self.jungle_music.stop()
                self.zoom_out_sound.stop()  # Add this line
        except (AttributeError, pygame.error):
            pass
        self.wind_sound_playing = False
        self.jungle_music_playing = False

        
    # Update the Camera class cleanup method:
    def cleanup(self):
        """Clean up all audio resources and reset camera state"""
        self.stop_sounds()
        self.transitioning = False
        self.transition_complete = False
        self.zoom = 1
        self.wind_sound_start_time = 0
        self.door_zoom = False
        self.door_zoom_target = None
        
    def __del__(self):
        """Destructor to ensure sounds are stopped when the camera object is destroyed"""
        try:
            self.stop_sounds()
        except:
            pass  # Ignore any errors during cleanup

    def ease_out_cubic(self, x):
        return 1 - pow(1 - x, 3)

    def apply(self, surface, entity):
        return pygame.Rect(
            entity.rect.x - self.scroll_x,
            entity.rect.y - self.scroll_y,
            entity.rect.width,
            entity.rect.height
        )

    def apply_sprite(self, surface, sprite):
        # Return the position where the sprite should be drawn
        return (sprite.rect.x - self.scroll_x,
                sprite.rect.y - self.scroll_y)
                
    def apply_rect(self, rect):
        # Apply camera offset to a rect
        return pygame.Rect(
            rect.x - self.scroll_x,
            rect.y - self.scroll_y,
            rect.width,
            rect.height
        )

# Update the video background handling code
def update_video_background(level):
    """Update video frame for video backgrounds"""
    if level in video_captures and video_captures[level] is not None:
        ret, frame = video_captures[level].read()
        if not ret:
            # Reset video to beginning if we've reached the end
            video_captures[level].set(cv2.CAP_PROP_POS_FRAMES, 0)
            ret, frame = video_captures[level].read()
        
        if ret:
            # Convert frame from BGR to RGB and flip to match Pygame's format
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame = cv2.resize(frame, (SCREEN_WIDTH, SCREEN_HEIGHT))
            frame = np.rot90(frame)
            frame = np.flipud(frame)
            frame = pygame.surfarray.make_surface(frame)
            return frame
    return None

# Update the initialization of video captures
# Initialize game assets
def init_game():
    """Initialize video captures and background surfaces"""
    global video_captures, background_surfaces
    global game_stats, pause_menu
    video_captures = {}
    background_surfaces = {}
    # Update this line to use EnhancedGameStats instead of GameStats
    game_stats = EnhancedGameStats(screen)
    pause_menu = PauseMenu(screen)
    
    for level, bg_data in level_backgrounds.items():
        if bg_data['type'] == 'video':
            try:
                cap = cv2.VideoCapture(bg_data['path'])
                if not cap.isOpened():
                    print(f"Failed to open video file for level {level}")
                    cap = None
                video_captures[level] = cap
            except Exception as e:
                print(f"Error loading video for level {level}: {e}")
                video_captures[level] = None
        else:
            try:
                img = pygame.image.load(bg_data['path']).convert()
                background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
            except Exception as e:
                print(f"Error loading image for level {level}: {e}")
                fallback = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
                fallback.fill((0, 0, 0))
                background_surfaces[level] = fallback

def get_background(level):
    """Get the current background surface for the given level"""
    if level_backgrounds[level]['type'] == 'video':
        return update_video_background(level)
    else:
        return background_surfaces[level]

# Update the cleanup function
def cleanup_backgrounds():
    """Release all video captures properly"""
    global video_captures
    if 'video_captures' in globals():
        for cap in video_captures.values():
            if cap is not None:
                cap.release()
        video_captures.clear()


def create_zoomed_view(screen, camera, player, world, keys_group, door, moving_enemies, ghost):
    current_visible_width = int(SCREEN_WIDTH // camera.zoom)
    current_visible_height = int(SCREEN_HEIGHT // camera.zoom)
    
    view_surface = pygame.Surface((current_visible_width, current_visible_height))
    
    # Get and draw the current background
    current_background = get_background(current_level)
    if current_background:
        view_surface.blit(current_background, (-camera.scroll_x, -camera.scroll_y))
    
    # Draw game objects
    for key in keys_group:
        pos = camera.apply_sprite(view_surface, key)
        if (0 <= pos[0] < current_visible_width and 
            0 <= pos[1] < current_visible_height):
            view_surface.blit(key.image, pos)
    
    # Draw door
    door_pos = camera.apply_sprite(view_surface, door)
    if (0 <= door_pos[0] < current_visible_width and 
        0 <= door_pos[1] < current_visible_height):
        view_surface.blit(door.image, door_pos)
    
    # Draw ghost
    ghost_pos = camera.apply_sprite(view_surface, ghost)
    if (0 <= ghost_pos[0] < current_visible_width and 
        0 <= ghost_pos[1] < current_visible_height):
        view_surface.blit(ghost.image, ghost_pos)
    
    # Draw enemies
    for enemy in moving_enemies:
        enemy_pos = camera.apply_sprite(view_surface, enemy)
        if (0 <= enemy_pos[0] < current_visible_width and 
            0 <= enemy_pos[1] < current_visible_height):
            view_surface.blit(enemy.image, enemy_pos)
    
    # Draw player
    player_pos = camera.apply_sprite(view_surface, player)
    if (0 <= player_pos[0] < current_visible_width and 
        0 <= player_pos[1] < current_visible_height):
        view_surface.blit(player.image, player_pos)
    
    # Scale and draw the final view
    scaled_surface = pygame.transform.scale(view_surface, (SCREEN_WIDTH, SCREEN_HEIGHT))
    screen.blit(scaled_surface, (0, 0))
    
    """"
    # Draw HUD elements
    draw_text(f"Level {current_level}", 40, WHITE, 10, 10)
    draw_text(f"Keys: {keys_collected}/{LEVEL_REQUIREMENTS[current_level]}", 40, WHITE, 10, 60)
    """
    
class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Key(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.frames = key_frames  # Use the key_frames list we created earlier
        
        # Animation variables
        self.current_frame = 0
        self.animation_timer = 0
        self.animation_delay = 100  # Milliseconds between frame changes
        
        # Set initial image
        self.image = self.frames[self.current_frame] if self.frames else key_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        
        # Floating movement variables
        self.original_y = float(y)
        self.float_offset = 0
        self.float_speed = 0.03  # Slightly slower float speed
        
    def update(self):
        if self.frames:  # Only animate if we have frames
            # Update animation frame
            current_time = pygame.time.get_ticks()
            if current_time - self.animation_timer > self.animation_delay:
                self.animation_timer = current_time
                self.current_frame = (self.current_frame + 1) % len(self.frames)
                self.image = self.frames[self.current_frame]
        
        # Update floating movement with reduced amplitude (changed from 15 to 5)
        self.float_offset += self.float_speed
        self.rect.y = self.original_y + math.sin(self.float_offset) * 5  # Reduced from 15 to 5

# In the Door class, update the open_door method to handle the image transition properly:
class Door:
    def __init__(self, x, y):
        super().__init__()
        try:
            # Load closed portal image (using underscore instead of space)
            self.closed_image = pygame.image.load('img/closed_portal.png')
            self.closed_image = pygame.transform.scale(self.closed_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            
            # Load portal animation frames
            self.portal_frames = []
            for i in range(1, 6):
                frame = pygame.image.load(f'img/portal_frame_{i}.png')
                frame = pygame.transform.scale(frame, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
                self.portal_frames.append(frame)
                
        except FileNotFoundError as e:
            print(f"Error loading portal images: {e}")
            print("Falling back to default door images...")
            # Fallback to original door images if portal images aren't found
            self.closed_image = pygame.image.load('img/closeddoor.PNG')
            self.closed_image = pygame.transform.scale(self.closed_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            # Create a simple animation using the open door image
            self.portal_frames = []
            open_image = pygame.image.load('img/opendoor_img.PNG')
            open_image = pygame.transform.scale(open_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            self.portal_frames = [open_image] * 5  # Create 5 copies of the open door image
        
        # Animation properties
        self.current_frame = 0
        self.animation_timer = 0
        self.animation_delay = 50  # Milliseconds between frame changes
        self.is_animating = False
        
        # Initial setup
        self.image = self.closed_image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.is_open = False
        self.door_sound = pygame.mixer.Sound('img/electric_zap.MP3')
        self.door_sound.set_volume(0.5)
        self.sound_played = False
        self.collision_enabled = True
        self.entered = False

    def update(self):
        if self.is_animating:
            current_time = pygame.time.get_ticks()
            
            # Update animation frame
            if current_time - self.animation_timer > self.animation_delay:
                self.animation_timer = current_time
                self.current_frame = (self.current_frame + 1) % len(self.portal_frames)
                self.image = self.portal_frames[self.current_frame]

    def open_door(self):
        if not self.is_open:
            self.is_open = True
            self.is_animating = True
            self.collision_enabled = False
            self.animation_timer = pygame.time.get_ticks()
            if not self.sound_played:
                self.door_sound.play()
                self.sound_played = True

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.6), int(TILE_SIZE * 1.6))  # Doubled the size from TILE_SIZE * 1
        
        # Load animations
        for i in range(1, 5):
            img = pygame.image.load(f'img/MainC{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        # Load sound effects
        self.walking_sound = pygame.mixer.Sound('img/Character Walking.MP3')
        self.walking_sound.set_volume(0.5)
        self.is_walking_sound_playing = False
        
        self.key_collect_sound = pygame.mixer.Sound('img/key_collect.mp3')
        self.key_collect_sound.set_volume(0.4)
        
        self.falling_sound = pygame.mixer.Sound('img/falling_character.mp3')
        self.falling_sound.set_volume(2)
        self.is_falling_sound_playing = False
        self.falling_threshold = 10
        self.falling_counter = 0
        
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, player_size)
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def stop_sounds(self):
        """Stop all player sounds"""
        if self.is_walking_sound_playing:
            self.walking_sound.stop()
            self.is_walking_sound_playing = False
        if self.is_falling_sound_playing:
            self.falling_sound.stop()
            self.is_falling_sound_playing = False

    def cleanup(self):
        """Clean up player resources"""
        self.stop_sounds()
        self.is_walking_sound_playing = False
        self.is_falling_sound_playing = False
        self.falling_counter = 0

    def __del__(self):
        """Ensure sounds are stopped when player object is destroyed"""
        self.stop_sounds()

    def update(self, game_over, world, keys_group, camera):
        global keys_collected
        dx = 0
        dy = 0
        walk_cooldown = 12
        
        # In the game over state handling section
        if game_over == -1:
            # Game over state
            draw_text('GAME OVER!', 70, BLUE, (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
            if restart_button.draw(screen):
                # Reset all necessary variables
                game_over = 0
                keys_collected = 0
                # Reset the game start time to now
                game_start_time = time.time()
                total_pause_time = timedelta(0)
                
                # Stop any ongoing sounds
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                    
                # Reset camera state
                camera.cleanup()
                camera.reset_zoom()
                
                # Reinitialize level
                keys_group, door, world, moving_enemies, player, ghost = init_level(current_level)
                
                # Ensure camera starts fresh
                camera.start_transition()
            
        # Reset death handling flag when game is restarted
        self._death_handled = False
        
        # Normal movement code here
        if camera.transition_complete:
            key = pygame.key.get_pressed()
            
            # Handle walking sound
            is_moving = False
            
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
                # Reset falling counter when jumping
                self.falling_counter = 0
                if self.is_falling_sound_playing:
                    self.falling_sound.stop()
                    self.is_falling_sound_playing = False
            
            if not key[pygame.K_SPACE]:
                self.jumped = False

            # Check for movement keys and play sound
            if key[pygame.K_LEFT] or key[pygame.K_a]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
                is_moving = True
            if key[pygame.K_RIGHT] or key[pygame.K_d]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
                is_moving = True
            
            # Handle walking sound
            if is_moving and not self.in_air and not self.is_walking_sound_playing:
                self.walking_sound.play(-1)
                self.is_walking_sound_playing = True
            elif (not is_moving or self.in_air) and self.is_walking_sound_playing:
                self.walking_sound.stop()
                self.is_walking_sound_playing = False

            if not (key[pygame.K_LEFT] or key[pygame.K_RIGHT] or key[pygame.K_a] or key[pygame.K_d]):
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

        # Always apply gravity regardless of camera state
        self.vel_y += GRAVITY
        if self.vel_y > 10:
            self.vel_y = 10
        dy += self.vel_y

        if not movement_enabled or camera.door_zoom:
            return game_over
        
        # Handle falling sound
        if self.in_air and self.vel_y > 0:  # If falling
            self.falling_counter += 1
            if self.falling_counter >= self.falling_threshold and not self.is_falling_sound_playing:
                self.falling_sound.play()
                self.is_falling_sound_playing = True
        elif not self.in_air:  # When landing
            self.falling_counter = 0
            if self.is_falling_sound_playing:
                self.falling_sound.stop()
                self.is_falling_sound_playing = False

        # Check for collision with keys
        key_hits = pygame.sprite.spritecollide(self, keys_group, True)
        if key_hits:
            self.key_collect_sound.play()
            keys_collected += len(key_hits)

        # Assume we're in the air unless collision detection proves otherwise
        self.in_air = True

        # Check for collision
        result = world.check_collision(self, dx, dy)
        if result == "deadly":
            return -1  # Return game over state
        else:
            dx, dy = result

        # Update player position
        self.rect.x += dx
        self.rect.y += dy

        # Keep player on screen
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH:
            self.rect.right = SCREEN_WIDTH
            
        # Check if player has fallen off the map
        if self.rect.top > SCREEN_HEIGHT:
            return -1  # Return game over state
            
        return game_over

class World:
    def __init__(self, level_data, deadly_data):
        self.collision_tiles = []
        self.deadly_tiles = []
        self.blue_tiles = []  # Initialize blue_tiles list

        # Create collision tiles
        for plat in level_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            
            offset_x = 0
            offset_y = 0
            
            collision_rect = pygame.Rect(
                x + offset_x,
                y + offset_y,
                width,
                height
            )
            self.collision_tiles.append(CollisionTile(x + offset_x, y + offset_y, width, height))

        # Create deadly tiles
        for deadly in deadly_data:
            x = deadly[0] * TILE_SIZE
            y = deadly[1] * TILE_SIZE
            width = deadly[2] * TILE_SIZE
            height = int(deadly[3] * TILE_SIZE)
            
            self.deadly_tiles.append(CollisionTile(x, y, width, height))

        # Create blue tiles
        if current_level in LEVEL_BLUE_DATA:
            for blue in LEVEL_BLUE_DATA[current_level]:
                x = blue[0] * TILE_SIZE
                y = blue[1] * TILE_SIZE
                width = blue[2] * TILE_SIZE
                height = int(blue[3] * TILE_SIZE)
                
                self.blue_tiles.append(CollisionTile(x, y, width, height))

                '''    def draw(self, screen):
                        # Draw regular collision tiles in red
                        for tile in self.collision_tiles:
                            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)
                        
                        # Draw deadly tiles in green
                        for tile in self.deadly_tiles:
                            pygame.draw.rect(screen, (0, 255, 0), tile.rect, 2)
                        
                        # Draw blue tiles in blue
                        for tile in self.blue_tiles:
                            pygame.draw.rect(screen, (0, 0, 255), tile.rect, 1)'''

    def check_collision(self, player, dx, dy):
        # Check collision with both regular and blue tiles
        for tile in self.collision_tiles + self.blue_tiles:
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False
                    
        # Check deadly collisions
        for tile in self.deadly_tiles:
            if tile.rect.colliderect(player.rect):
                return "deadly"
                
        return dx, dy

def init_level(level_num):
    global keys_collected, game_start_time, current_level, player, camera, ghost, movement_enabled
    
    # Initialize variables first
    keys_collected = 0
    current_level = level_num
    
    if game_start_time is None:
        game_start_time = time.time()
    
    # Reset movement state
    movement_enabled = False
    
    # Clean up previous player if it exists
    if 'player' in globals():
        player.cleanup()
    
    # Reset camera state
    camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
    camera.transitioning = False
    camera.transition_complete = False
    camera.manual_zoom_active = False
    camera.door_zoom = False
    camera.door_zoom_target = None
    camera.reset_on_death = False
    
    if game_start_time is None:
        game_start_time = time.time()
    
    # Initialize level objects
    keys_group = pygame.sprite.Group()
    key_positions = generate_key_positions(level_num)
    for pos in key_positions:
        adjusted_y = pos[1] + TILE_SIZE - 20
        keys_group.add(Key(pos[0], adjusted_y))

    platforms = LEVEL_PLATFORM_DATA[level_num]
    suitable_platform = find_suitable_platform(platforms)
    platform_x = suitable_platform[0]
    platform_y = suitable_platform[1]
    platform_width = suitable_platform[2]
    
    door_x = (platform_x + platform_width - 2) * TILE_SIZE
    door_y = (platform_y - 2) * TILE_SIZE
    
    if door_x > SCREEN_WIDTH - 3 * TILE_SIZE:
        door_x = SCREEN_WIDTH - 3 * TILE_SIZE
    
    door = Door(door_x, door_y)
    
    deadly_tiles = LEVEL_DEADLY_DATA[level_num]
    world = World(platforms, deadly_tiles)
    
    # Set player spawn position
    spawn_x = 100
    spawn_y = 0
    
    # Find suitable ground platform for spawning
    ground_platforms = []
    for plat in platforms:
        if plat[1] > (SCREEN_HEIGHT / TILE_SIZE) * 0.7:  # Ground level platforms
            ground_platforms.append(plat)
    
    if ground_platforms:
        leftmost = sorted(ground_platforms, key=lambda p: p[0])[0]
        spawn_x = (leftmost[0] + 1) * TILE_SIZE
        # Adjust spawn height to be just above the platform
        player_height = int(TILE_SIZE * 1.5)  # Match the player's size
        spawn_y = (leftmost[1] * TILE_SIZE) - player_height
    
    # Create player first
    player = Player(spawn_x, spawn_y)
    
    # Create ghost after player
    ghost = Ghost(SCREEN_WIDTH, SCREEN_HEIGHT, player, level_num)
    
    # Initialize moving enemies
    moving_enemies = pygame.sprite.Group()
    for enemy_data in LEVEL_ENEMY_DATA[level_num]:
        x, y, direction, boundary_start, boundary_end = enemy_data
        enemy = MovingEnemy(x, y, direction, boundary_start, boundary_end)
        moving_enemies.add(enemy)
    
    return keys_group, door, world, moving_enemies, player, ghost


class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 0.8)))
        self.rect = self.image.get_rect()
        self.rect.x = x * TILE_SIZE
        self.rect.y = y * TILE_SIZE
        self.direction = direction
        self.speed = 1.2  # Reduced from 2
        self.moving_right = True
        self.moving_down = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE
        self.initial_pos = self.rect.x if direction == "horizontal" else self.rect.y

    def update(self):
        # Only update if movement is enabled and not during door zoom
        if not movement_enabled or camera.door_zoom:
            return
            
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)
        else:  # vertical movement
            if self.moving_down:
                self.rect.y += self.speed
                if self.rect.y >= self.boundary_end:
                    self.moving_down = False
            else:
                self.rect.y -= self.speed
                if self.rect.y <= self.boundary_start:
                    self.moving_down = True

    def draw_boundaries(self, screen):
        # Draw movement boundaries (for debugging)
        if self.direction == "horizontal":
            pygame.draw.line(screen, (255, 0, 0),
                           (self.boundary_start, self.rect.centery),
                           (self.boundary_end, self.rect.centery), 2)
        else:
            pygame.draw.line(screen, (255, 0, 0),
                           (self.rect.centerx, self.boundary_start),
                           (self.rect.centerx, self.boundary_end), 2)

    def check_collision(self, player):
        # Create a slightly smaller collision rect for more forgiving collisions
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button:
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self, screen):
        action = False
        # Get mouse position
        pos = pygame.mouse.get_pos()  # This gets the (x, y) position of the mouse

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and not self.clicked:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font_size, color, x, y):
    font = pygame.font.SysFont('Bauhaus 93', font_size)
    img = font.render(text, True, color)
    screen.blit(img, (x, y))

# Update the show_dialogue function:
def show_dialogue(dialogue_lines):
    dialogue_box = DialogueBox(screen)
    
    waiting = True
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

def find_suitable_platform(platforms):
    """
    Find a suitable platform for door placement using better criteria:
    1. Platform must be wide enough for door and NPC
    2. Platform should be reasonably high up but not necessarily the highest
    3. Platform should have enough space above it
    """
    # Sort platforms by height (y-coordinate), from top to bottom
    sorted_platforms = sorted(platforms, key=lambda p: p[1])
    
    # Required width for door and NPC (in tile units)
    required_width = 4  # Space for door and NPC
    
    # Check top 1/3 of platforms for a suitable spot
    top_third = len(sorted_platforms) // 3
    if top_third < 1:
        top_third = 1
    
    for platform in sorted_platforms[:top_third]:
        # Get platform dimensions
        x, y, width, height = platform
        
        # Check if platform is wide enough
        if width >= required_width:
            # Check if there's another platform directly above
            has_obstruction = False
            platform_top = y
            platform_left = x
            platform_right = x + width
            
            # Check for obstructions above
            for other_platform in platforms:
                other_x, other_y, other_width, other_height = other_platform
                other_left = other_x
                other_right = other_x + other_width
                other_bottom = other_y + other_height
                
                # Check if there's a platform directly above
                if (other_bottom > platform_top - 4 and  # Leave space for door height
                    other_y < platform_top and
                    other_right > platform_left and
                    other_left < platform_right):
                    has_obstruction = True
                    break
            
            if not has_obstruction:
                return platform
                
    # Fallback to the widest platform in the top half if no perfect match
    top_half = sorted_platforms[:len(sorted_platforms)//2]
    widest_platform = max(top_half, key=lambda p: p[2])
    return widest_platform

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    deadly_tiles = LEVEL_DEADLY_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Function to check if position is safe from deadly tiles
    def is_safe_position(x, y):
        SAFE_DISTANCE = TILE_SIZE * 3  # Minimum distance from deadly tiles
        
        for deadly in deadly_tiles:
            deadly_x = deadly[0] * TILE_SIZE
            deadly_y = deadly[1] * TILE_SIZE
            deadly_width = deadly[2] * TILE_SIZE
            deadly_height = deadly[3] * TILE_SIZE
            
            # Calculate boundaries of the deadly area with safety margin
            deadly_left = deadly_x - SAFE_DISTANCE
            deadly_right = deadly_x + deadly_width + SAFE_DISTANCE
            deadly_top = deadly_y - SAFE_DISTANCE
            deadly_bottom = deadly_y + deadly_height + SAFE_DISTANCE
            
            # Check if key position is within the danger zone
            if (deadly_left < x < deadly_right and 
                deadly_top < y < deadly_bottom):
                return False
        return True
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    attempts = 0
    max_attempts = 100  # Prevent infinite loop
    
    while len(positions) < required_keys and attempts < max_attempts:
        for plat in viable_platforms:
            if len(positions) >= required_keys:
                break
                
            # Try multiple positions on each platform
            for _ in range(5):  # Try 5 times per platform
                # Place key somewhere along the platform
                key_x = plat[0] + random.uniform(TILE_SIZE, plat[2] - TILE_SIZE * 2)
                key_y = plat[1] - TILE_SIZE * 1.5
                
                # Only add position if it's safe
                if is_safe_position(key_x, key_y):
                    positions.append((key_x, key_y))
                    break
            
            attempts += 1
    
    # If we couldn't find enough safe positions, fill remaining with positions farther from platforms
    while len(positions) < required_keys:
        plat = random.choice(viable_platforms)
        key_x = plat[0] + random.uniform(TILE_SIZE * 2, plat[2] - TILE_SIZE * 2)
        key_y = plat[1] - TILE_SIZE * 2  # Place keys higher above platform
        if is_safe_position(key_x, key_y):
            positions.append((key_x, key_y))
    
    return positions

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    
    for i in range(min(required_keys, len(viable_platforms))):
        plat = viable_platforms[i]
        # Place key somewhere along the platform
        key_x = plat[0] + random.uniform(0, plat[2] - TILE_SIZE)
        key_y = plat[1] - TILE_SIZE * 1.5  # Place key above platform
        positions.append((key_x, key_y))
    
    return positions

# Initialize game objects
start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)
camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
player = Player(100, SCREEN_HEIGHT - 130)
world = World(LEVEL_PLATFORM_DATA[1], LEVEL_DEADLY_DATA[1])
moving_enemies = pygame.sprite.Group()
keys_group = pygame.sprite.Group()
game_over = 0
current_state = "start_screen"
movement_enabled = False 
pause_button = PauseButton(screen)

# Initialize game resources
init_game()

# Game loop
clock = pygame.time.Clock()
fps = 60
running = True

while running:
    clock.tick(fps)
    
    keys = pygame.key.get_pressed()
    if keys[pygame.K_ESCAPE] and current_state == "playing" and not game_over:
        if not paused:
            paused = True
            pause_start_time = datetime.now()
        
    if paused:
        if not handle_pause():
            running = False
        continue
    
    # Single event handling section
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                running = False
                break

    if not running:
        break
        
    # State updates based on current_state
    if current_state == "start_screen":
        screen.blit(start_bg, (0, 0))
        current_state = "intro_dialogue"
        
    elif current_state == "intro_dialogue":
        if show_dialogue(STORYLINE["intro"]) and show_dialogue(STORYLINE["level0"]):
            current_state = "playing"
            current_level = 0
            keys_group, door, world, moving_enemies, player, ghost = init_level(current_level)
        else:
            current_state = "playing"
            current_level = 0
            keys_group, door, world, moving_enemies, player, ghost = init_level(current_level)
            
    elif current_state == "playing":
        # Handle dialogue states
        storyline_key = f'storyline_{current_level}'
        level_key = f'level_{current_level}'
        
        if not dialogue_states.get(storyline_key, False):
            if show_dialogue(STORYLINE[f"level{current_level}"]):
                dialogue_states[storyline_key] = True
                
        elif not dialogue_states.get(level_key, False):
            if show_dialogue(LEVEL_DIALOGUES[current_level]):
                dialogue_states[level_key] = True
                camera.start_transition()
        
        # Enable movement when camera transition is complete
        if camera.transition_complete and not movement_enabled:
            movement_enabled = True  # This ensures movement is enabled after transitions
        
        # Update game objects only when movement is enabled
        if movement_enabled:
            # Game updates
            camera.update(player, keys_collected, door, LEVEL_REQUIREMENTS[current_level])
            
            if not camera.door_zoom:
                # Update entities only when not zooming to door
                ghost.update()
                moving_enemies.update()
                game_over = player.update(game_over, world, keys_group, camera)
                
                # Check collisions
                if ghost.check_collision(player):
                    game_over = -1
                    game_over_fx.play()
                
                for enemy in moving_enemies:
                    if enemy.check_collision(player):
                        game_over = -1
                        game_over_fx.play()
                        break
        keys_group.update()
        door.update()
        camera.update(player, keys_collected, door, LEVEL_REQUIREMENTS[current_level])
        create_zoomed_view(screen, camera, player, world, keys_group, door, moving_enemies, ghost)
        
        # Draw pause button when not paused
        if not paused:
            pause_button.draw()
            
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            
            # Handle pause button click
            if not paused and pause_button.handle_event(event):
                paused = True
                pause_start_time = datetime.now()
                fade_alpha = 0

        if game_start_time:
            current_time = time.time()
            elapsed_time = current_time - game_start_time
            if total_pause_time:
                elapsed_time -= total_pause_time.total_seconds()
                
            # Check timer
            if check_level_timer(elapsed_time, LEVEL_TIME_LIMITS[current_level]):
                game_over = -1
                game_over_fx.play()
            
            # Draw enhanced game stats (keep only this one)
            game_stats.draw_stats_panel(
                current_level,
                keys_collected,
                LEVEL_REQUIREMENTS[current_level],
                elapsed_time,
                LEVEL_TIME_LIMITS[current_level]
            )

        # Handle collisions and game over
        if game_over == 0:
            # Check deadly collisions
            deadly_collision = world.check_collision(player, 0, 0)
            if deadly_collision == "deadly":
                game_over = -1
                game_over_fx.play()
            
            # Update game objects
            game_over = player.update(game_over, world, keys_group, camera)
            moving_enemies.update()
            keys_group.update()  # Add this line to animate the keys
            
            # Check enemy collisions
            for enemy in moving_enemies:
                if enemy.check_collision(player):
                    game_over = -1
                    game_over_fx.play()
                    break
                    
            # Level completion
            if keys_collected >= LEVEL_REQUIREMENTS[current_level]:
                if not door.is_open:
                    camera.start_door_zoom(door)
                elif pygame.sprite.collide_rect(player, door):
                    door.entered = True
                    camera.stop_sounds()
                    
                    if current_level == 0:
                        # Tutorial completion
                        if door.entered and show_dialogue([
                            "Tutorial Complete! ",
                            "You've mastered the basics! ",
                            "Press SPACE to begin your real journey..."
                        ]):
                            current_level = 1
                            storyline_key = f'storyline_{current_level}'
                            level_key = f'level_{current_level}'
                            dialogue_states[storyline_key] = False
                            dialogue_states[level_key] = False
                            camera.cleanup()
                            if game_start_time:
                                elapsed_time = int(time.time() - game_start_time)
                                level_times.append(elapsed_time)
                            keys_group, door, world, moving_enemies, player, ghost = init_level(current_level)
                            camera.start_transition()
                    else:
                        # Regular level completion
                        if door.entered:
                            if current_level < 5:
                                if show_dialogue([
                                    f"Level {current_level} Complete!",
                                    "Press SPACE to continue to next level..."
                                ]):
                                    current_level += 1
                                    storyline_key = f'storyline_{current_level}'
                                    level_key = f'level_{current_level}'
                                    dialogue_states[storyline_key] = False
                                    dialogue_states[level_key] = False
                                    camera.cleanup()
                                    if game_start_time:
                                        elapsed_time = int(time.time() - game_start_time)
                                        level_times.append(elapsed_time)
                                    keys_group, door, world, moving_enemies, player, ghost = init_level(current_level)
                                    camera.start_transition()
                            else:
                                camera.cleanup()
                                if show_dialogue(STORYLINE["ending"]):
                                    current_state = "game_complete"
            pass
        else:
            # Game over state
            draw_text('GAME OVER!', 70, BLUE, (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
            if restart_button.draw(screen):
                # Properly reset all necessary variables
                game_over = 0
                keys_collected = 0
                
                # Stop any ongoing sounds
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                    
                # Reset camera state
                camera.cleanup()
                camera.reset_zoom()
                
                # Reinitialize level
                keys_group, door, world, moving_enemies, player, ghost = init_level(current_level)
                
                # Ensure camera starts fresh
                camera.start_transition()
                
                
    elif current_state == "game_complete":
        screen.fill(BLACK)
        total_time = int(time.time() - game_start_time)
        minutes = total_time // 60
        seconds = total_time % 60
        
        draw_text("Congratulations!", 70, WHITE, SCREEN_WIDTH // 2 - 250, SCREEN_HEIGHT // 3)
        draw_text(f"You've completed Decoding Island!", 50, WHITE, SCREEN_WIDTH // 2 - 300, SCREEN_HEIGHT // 2)
        draw_text(f"Total Time: {minutes:02d}:{seconds:02d}", 50, WHITE, SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 100)
        
        if restart_button.draw(screen):
            current_state = "start_screen"
            game_start_time = None
            current_level = 0
            keys_collected = 0
            level_times = []
    
        # Calculate total play time excluding pauses
        if game_start_time:
            raw_total_time = datetime.now() - datetime.fromtimestamp(game_start_time)
            adjusted_total_time = raw_total_time - total_pause_time
            
            minutes = int(adjusted_total_time.total_seconds() // 60)
            seconds = int(adjusted_total_time.total_seconds() % 60)
            
            # Create completion stats card
            completion_card = pygame.Surface((600, 400))
            completion_card.fill((40, 40, 40))
            
            # Draw stats with improved styling
            title_font = pygame.font.SysFont('Bauhaus 93', 70)
            stats_font = pygame.font.SysFont('Bauhaus 93', 40)
            
            # Title
            title = title_font.render("GAME COMPLETE!", True, (255, 215, 0))
            completion_card.blit(title, (300 - title.get_width()//2, 40))
            
            # Stats
            stats = [
                f"Total Time: {minutes:02d}:{seconds:02d}",
                f"Keys Collected: {sum(LEVEL_REQUIREMENTS.values())}",
                f"Levels Completed: 5"
            ]
            
            for i, stat in enumerate(stats):
                text = stats_font.render(stat, True, WHITE)
                completion_card.blit(text, (300 - text.get_width()//2, 160 + i * 60))
            
            # Draw the card centered on screen
            screen.blit(completion_card, 
                    (SCREEN_WIDTH//2 - completion_card.get_width()//2,
                        SCREEN_HEIGHT//2 - completion_card.get_height()//2))
    
    pygame.display.update()

cleanup_backgrounds()
pygame.quit()

================
File: no_minigame.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os
import time
import cv2 
import numpy as np
import math
from datetime import datetime, timedelta
import subprocess
import sys


def load_minigame(level):
    """Load and run a minigame module when needed"""
    try:
        # Stop any ongoing sounds and music
        pygame.mixer.stop()
        pygame.mixer.music.stop()
        
        # Store current display settings
        current_display = pygame.display.get_surface().copy()
        
        result = False
        
        # Map levels to their corresponding minigame modules
        minigame_modules = {
            1: 'mini_game1',
            2: 'mini_game2',
            3: 'mini_game3',
            4: 'mini_game4',
            5: 'mini_game5'
        }
        
        if level in minigame_modules:
            try:
                # Import the corresponding minigame module
                minigame = __import__(minigame_modules[level])
                result = minigame.main()  # Run the minigame
            except ImportError as e:
                print(f"Could not load minigame module for level {level}: {e}")
                return False
            except Exception as e:
                print(f"Error running minigame {level}: {e}")
                return False
                
        # Reset display mode and caption
        pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption('Decoding Island')
        
        # Show message if minigame wasn't completed
        if not result:
            screen = pygame.display.get_surface()
            screen.blit(current_display, (0, 0))
            
            # Create semi-transparent overlay
            overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
            overlay.fill((0, 0, 0, 180))
            screen.blit(overlay, (0, 0))
            
            # Show message
            font = pygame.font.SysFont('Bauhaus 93', 32)
            text1 = font.render("You must complete the minigame to proceed!", True, (255, 255, 255))
            text2 = font.render("Press any key to try again...", True, (255, 255, 255))
            
            text1_rect = text1.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 - 20))
            text2_rect = text2.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2 + 20))
            
            screen.blit(text1, text1_rect)
            screen.blit(text2, text2_rect)
            pygame.display.flip()
            
            # Wait for keypress
            waiting = True
            while waiting:
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        return False
                    if event.type == pygame.KEYDOWN:
                        waiting = False
                pygame.time.wait(100)
            
            # Try the minigame again
            return load_minigame(level)
            
        return result
        
    except Exception as e:
        print(f"Error in load_minigame: {e}")
        return False



# Initialize Pygame and mixer first
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Set up display and constants
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940
BASE_WIDTH = 1539
BASE_HEIGHT = 940
SCALE_X = 1.0
SCALE_Y = 1.0
FULLSCREEN = False

# Set up the display
# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'
# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Decoding Island')

# Update these constants at the top of your file
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.47  # Reduced from 0.45
JUMP_SPEED = -12  # Reduced from -13
MOVE_SPEED = 6  # Reduced from 5
game_over = 0
current_level = 0  # 0 for start screen, 1-5 for levels
keys_collected = 0
game_start_time = None
level_times = []
dialogue_states = {}
walk_cooldown = 12

# Add these with other global variables
paused = False
pause_start_time = None
total_pause_time = timedelta(0)
fade_alpha = 0
fade_target = 180
fade_speed = 15


# You may need to adjust other elements (buttons, player size, etc.) to fit the new resolution
# For example:
# start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
# restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Define colors
WHITE = (255, 255, 255)
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)

# Load images
start_bg = pygame.image.load('img/background.png')
start_bg = pygame.transform.scale(start_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
start_btn = pygame.image.load('img/start_btn.png')
restart_img = pygame.image.load('img/restart_btn.png')
closeddoor_img = pygame.image.load('img/closeddoor.PNG')
opendoor_img = pygame.image.load('img/opendoor_img.PNG')
key_img = pygame.image.load('img/key.png')
npc_img = pygame.image.load('img/Wghost.png')
key_frames = []
target_size = (25, 25)  # Your desired size

# Append Keys
for i in range(1, 13):
    image = pygame.image.load(f'img/AnimatedKey_{i}.png')
    scaled_image = pygame.transform.scale(image, target_size)
    key_frames.append(scaled_image)

# Scale images
closeddoor_img = pygame.transform.scale(closeddoor_img, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
key_img = pygame.transform.scale(key_img, (10, 25 ))
npc_img = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2)))

# Load sounds
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

FULLSCREEN = False  # Track fullscreen state

def update_scale_factors():
    """Update scale factors based on current screen size"""
    global SCALE_X, SCALE_Y
    current_size = pygame.display.get_surface().get_size()
    SCALE_X = current_size[0] / BASE_WIDTH
    SCALE_Y = current_size[1] / BASE_HEIGHT

def toggle_fullscreen():
    """Toggle between fullscreen and windowed mode"""
    global FULLSCREEN, screen, SCREEN_WIDTH, SCREEN_HEIGHT
    FULLSCREEN = not FULLSCREEN
    
    if FULLSCREEN:
        # Get monitor resolution
        info = pygame.display.Info()
        # Calculate aspect ratio preserved resolution
        target_ratio = BASE_WIDTH / BASE_HEIGHT
        monitor_ratio = info.current_w / info.current_h
        
        if monitor_ratio > target_ratio:
            # Monitor is wider than our target ratio
            SCREEN_HEIGHT = info.current_h
            SCREEN_WIDTH = int(SCREEN_HEIGHT * target_ratio)
        else:
            # Monitor is taller than our target ratio
            SCREEN_WIDTH = info.current_w
            SCREEN_HEIGHT = int(SCREEN_WIDTH / target_ratio)
            
        screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.FULLSCREEN)
    else:
        SCREEN_WIDTH = BASE_WIDTH
        SCREEN_HEIGHT = BASE_HEIGHT
        screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    
    # Update scale factors after changing resolution
    update_scale_factors()

# Level platform data (you'll need to adjust these coordinates based on your level designs)
LEVEL_PLATFORM_DATA = {
    0: [
            # Top platforms
            (5.2, 13.4, 6, 2.5),    
            (48, 13.4, 6, 2.5),   

            # small-top platform
            (13.3, 15.5, 1.4, 1.0), 
            (44.4, 15.5, 1.6, 1.0), 
            
            # semi-top platform
            (16.7, 16.6, 4.5, 1.0), 
            (38, 16.6, 4.5, 1.0), 

            # Middle platform
            (26.5, 18.3, 6.2, 2.5),  
            
            # Lower platforms
            (34.6, 23.2, 4.8, 2.5),
            (19.9, 23.2, 4.7, 2.5),
            
            # Bottom platforms
            (11.8, 28, 6.2, 2.5),
            (26.6, 28, 6.2, 2.5),
            (41.3, 28, 8, 1.),
            
            # Ground level
            (0, 33, 8, 3.0),
            (51, 33, 8.2, 3.0),
    ],
    1: [
            # 5th layer
            (23.1, 8.4, 4.8, 1.4),
            (44.5, 8.4, 4.8, 1.4),
            (15, 5.1, 6.2, 3),
            (0, 6.8, 9.8, 1.3),

            # 4th layer
            (28.1, 11.7, 6.4, 3),
            (51.2, 11.7, 6.3, 3),

            # 3rd layer
            (24.8, 15.5, 1.4, 1.7),
            (36.3, 16.6, 4.8, 1.3),
            (44.5, 16.6, 4.8, 1.3),

            # 2nd layer
            (51.1, 21.5, 6.4, 3),
            (36.3, 23.2, 6.4, 1),
            (18.3, 19.9, 9.6, 3),
            (31.3, 19.9, 3.3, 1.4),

            # Ground level
            (44.6, 26.4, 6.4, 3),
            (33, 29.7, 9.7, 3),
            (16.6, 28.1, 4.8, 1.4),
            (16.6, 34.7, 16, 12),

            # Ground Pillars
            (11.7, 23.2, 3.1, 12),
            (6.7, 26.4, 3.1, 9),
            (1.7, 29.8, 3.1, 6)
    ],
    2: [
            # 7th layer
            (13.5, 2, 7.6, 4),
            (10.1, 3.7, 3, 1),
            (0.3, 3.7, 4.6, 1),
            (5.2, 5.3, 1.3, 1),

            # 6th layer
            (51.3, 10.2, 7.5, 5.7),
            (5.2, 8.6, 4.6, 1),

            # 5th layer
            (43, 11.9, 6.3, 1),
            (11.8, 13.5, 4.6, 1),
            (0.2, 13.5, 4.6, 1),

            # 4th layer
            (31.7, 18.1, 1.8, 1.3),
            (42.3, 18.1, 1.8, 1.3),
            (33.3, 15.2, 9.2, 4),
            (0, 18.4, 9.5, 2.5),

            # 3rd layer
            (47.9, 20, 4.7, 1),
            (29.85, 20, 1.3, 1),
            (13.6, 21.7, 6, 1),
            (9.9, 20.1, 1.4, 1),

            # 2nd layer
            (48, 26.7, 6.2, 1),
            (41.4, 23.4, 4.6, 1),
            (26.7, 23.4, 7.6, 2.5),
            (7, 25, 14, 5),

            # Ground level
            (0.5, 28.4, 6.6, 8.0),
            (21, 28.4, 6.7, 8.0),
            (43.2, 31.7, 27, 5.0),

            # Ground Pillars
            (39.8, 31.7, 1.2, 3),
            (34.8, 31.7, 1.2, 3),
            (29.9, 31.7, 1.2, 3)
    ],
    3: [
            # 6th layer
            (3.5, 7, 6.2, 1),
            (0.3, 2, 4.3, 2.5),
            (20, 8.5, 3, 1),
            (46.4, 8.5, 11.4, 1),
            (57.8, 0.4, 1.3, 9),
            (29.9, 3.7, 9.5, 1),
            (48, 3.7, 4.6, 1),
            

            # 5th layer
            (26.4, 11.5, 2.8, 1.3),
            (25, 8.6, 1.4, 4.3),
            (11.5, 10.2, 5, 1),


            # 4th layer
            (18.1, 10.3, 1.7, 5.8),
            (7.1, 14.8, 10.9, 1.3),
            (31.5, 13.6, 3, 0.8),
            (36.5, 16.8, 7.8, 0.8),

            # 3rd layer
            (51.3, 20.1, 2.8, 5.7),
            (44.8, 20.1, 2.8, 5.7),
            (47.6, 24.8, 3.8, 1),
            (33.2, 23.4, 7.8, 1),
            (9.9, 25, 11.3, 1),
            (1.4, 20.1, 6.5, 5.8),
            (23.4, 18.5, 7.5, 4.2),
            (11.8, 21.8, 3, 0.8),
            (1.7, 13.6, 1.6, 1),
            (37.9, 11.9, 1.6, 1),
            (43, 10.3, 1.2, 2.7),
            (16.7, 13.5, 1.3, 1.3),
            

            # 2nd layer
            (34.8, 30, 2.9, 1),
            (26.7, 26.7, 5.9, 1),
            (31.3, 26.7, 1.4, 5.8),
            (23.6, 31.3, 7.7, 1.2),
            (10, 28.4, 4.8, 1),
            (21.6, 21.9, 1.4, 2.3),
            (19.8, 18.5, 1.6, 1),
            (8.3, 20, 1.6, 1),
            (0.1, 18.4, 1.6, 1),


            # Ground level
            (0.3, 35, 19, 6),
            (23.4, 35, 20.6, 6),
            (46.6, 35, 12.6, 6)
    ],
    4: [
            # 4th layer
            (33.2, 15.2, 7.8, 5.8),
            (31.3, 16.8, 2, 1),

            (6.8, 11.9, 5, 1),
            (10.2, 5.3, 3, 2.4),
            (15, 21.9, 1.2, 2),
            (13, 7, 1.8, 2.3),

            (19.9, 7, 1.2, 2.3),
            (21.4, 5.2, 1.3, 11),
            (22.6, 7, 1.8, 1),
            (11.9, 5.3, 1.1, 10.9),
            (13, 14.9, 8.4, 1.3),
            (16.4, 8.5, 1.7, 1),
            (14.9, 11.9, 5, 1),

            (24.8, 11.9, 3, 1),
            (46, 11.9, 5, 1),
            (44.4, 16.8, 6.6, 1),

            (51, 20, 8, 1),
            (38.1, 0, 1.3, 8),
            (39.3, 6.8, 6.3, 1.2),
            (39.3, 3.5, 1.7, 1),



            # 3rd layer
            (8.5, 21.8, 1.5, 1),
            (21.2, 21.8, 1.5, 1),
            (16.9, 29.5, 1.6, 1.5),
            (19.4, 29.5, 1.6, 1.5),
            (26.4, 20, 1.8, 1),
            (29.4, 20, 1.8, 1),
            (28.2, 15.2, 1.2, 9.3),
            (26.4, 23.4, 1.8, 1),
            (29.4, 23.4, 3.3, 1),
            

            # 2nd layer
            (6.9, 28.3, 4.3, 1),
            (1.7, 25, 6.3, 1),
            (0, 20, 8, 1),
            (0, 15.1, 5, 1),
            (11.9, 26.7, 1.3, 6),
            (13, 31.2, 1.3, 1.4),
            (11.9, 26.6, 6.7, 1),
            (23, 26.7, 5, 1),
            (33, 26.7, 3, 1),
            (39, 38.2, 5, 1),
            (29.8, 30, 3, 1),
            (56, 30, 3, 1),
            (41, 23.4, 5, 1),
            (52.9, 33.1, 2.9, 4),
            (38, 28.2, 5, 1),
            (46, 26.7, 6.7, 5.8),
            (44.7, 31.2, 1.5, 1.3),


            # Ground level
            (0, 33.3, 6.3, 6),
            (6.7, 34.9, 3, 6),
            (11.6, 34.9, 8.1, 6),
            (21.6, 34.9, 1.3, 6),
            (23, 33.2, 6.5, 0.9),
            (34.7, 33.3, 9.5, 6)
    ],
    5: [

            (0, 5.2, 9.5, 1),
            (0, 13.5, 11.4, 1),
            (0.2, 23.4, 1.1, 14),
            (3.5, 26.7, 1.4, 11),

            (6.8, 30, 3, 1),
            (6.7, 23.4, 3, 1),
            (10, 18.5, 4.6, 1),
            (10, 26.7, 8.2, 1.5),
            (26.3, 26.7, 5.3, 1.5),
            (36.1, 26.7, 3.7, 1.5), 

            (15, 13.5, 3, 1), 
            (18, 8.5, 5, 1),
            (49.3, 30, 3.3, 1.1), 
            (46, 23.3, 6.5, 1),
            (44.4, 18.5, 4.8, 1),

            (16.5, 20, 5, 1.3),
            (23, 20, 1.7, 1.3),
            (33, 20, 3.3, 1.3),
            (38, 20, 4.7, 1.3),
            (41.2, 13.5, 3.2, 1),
            (29.7, 7, 6.5, 1.1),
            (22.9, 7, 5, 1.2),

            (19.8, 13.5, 5, 1.3),
            (29.6, 13.5, 1.7, 1.3),
            (34.4, 13.5, 5.2, 1.3),
            (36.4, 8.5, 4.5, 1.2),
            (42.9, 5.3, 6.5, 1),
            (51, 15, 8, 1),

            (15.1, 26.8, 1, 8),
            (43.1, 26.8, 1, 8),
            (21.7, 13.6, 1.2, 7.7),
            (36.5, 13.6, 1.2, 7.7),
            (18.4, 20, 1, 8.1), 
            (39.9, 20, 1, 8.1),
            (25, 7, 1, 7.8),
            (33.3, 7, 1, 7.8),

            (54.5, 26.8, 1.2, 11),
            (57.9, 23.4, 1.2, 14),
            (51.3, 3.2, 1.5, 6.3),
            (53, 8.3, 4.4, 1.3),
            (57.6, 3.3, 1.5, 6),
            (54.3, 5, 1.7, 1.3),

            (28.2, 12, 1.2, 2.5), 
            (31.5, 18.5, 1.3, 2.5),
            (25, 25, 1, 3),
            (34.9, 31.7, 1, 3),
            (17.7, 31.5, 1.8, 1),

            (9.9, 33.2, 5, 1.3),
            (19.4, 33.2, 7.3, 1.3),
            (29.4, 33.2, 5.4, 1.3),
            (36, 33.2, 5.5, 1.3),
            (44, 33.2, 5.3, 1.3)
    ]
}

# 1. Fix the level_backgrounds initialization
level_backgrounds = {
    0: {'type': 'video', 'path': 'Level Data/Level Image/Level0_Background.mp4'},
    1: {'type': 'video', 'path': 'Level Data/Level Image/Level1_Background.mp4'},
    2: {'type': 'video', 'path': 'Level Data/Level Image/Level2_Background.mp4'},
    3: {'type': 'video', 'path': 'Level Data/Level Image/Level3_Background.mp4'},
    4: {'type': 'video', 'path': 'Level Data/Level Image/Level4_Background.mp4'},
    5: {'type': 'image', 'path': 'Level Data/Level Image/Level5.png'}
}

# Dictionary mapping dialogue scenes to background images
DIALOGUE_BACKGROUNDS = {
    "intro": "Level Data/Dialouge/bg.png",
    "level0": "Level Data/Dialouge/Forest3.png",
    "level1": "Level Data/Dialouge/origbig.png",
    "level2": "Level Data/Dialouge/mountainbg.png",
    "level3": "Level Data/Dialouge/Geoffrey.png",
    "level4": "Level Data/Dialouge/Jessi.png",
    "level5": "Level Data/Dialouge/Jacobo.png",
    "ending": "Level Data/Dialouge/Jacobo.png"
}

# Update LEVEL_REQUIREMENTS dictionary
LEVEL_REQUIREMENTS = {
    0: 3,  # Tutorial level 
    1: 4,  # Level 1: Assassin's Trial
    2: 5,  # Level 2: Wizard's Tower
    3: 6,  # Level 3: Autocrat's Domain
    4: 8,  # Level 4: Wraith's Nightmare
    5: 10  # Level 5: Undead King's Castle
}

# Update LEVEL_NAMES dictionary
LEVEL_NAMES = {
    0: "The Awakening Path",
    1: "Shadows of Deception",
    2: "Mystic Tower Ascent", 
    3: "Cryptic Dominion",
    4: "Phantom's Labyrinth",
    5: "Undead King's Sanctum"
}

# Update LEVEL_TIME_LIMITS dictionary
LEVEL_TIME_LIMITS = {
    0: 60,  # Tutorial: 1 minute
    1: 60,  # Level 1: 1 minute 
    2: 60,  # Level 2: 1 minute
    3: 60,  # Level 3: 1 minute
    4: 60,  # Level 4: 1 minute
    5: 60   # Level 5: 1 minute
}

# Update LEVEL_ENEMY_DATA to match old version
LEVEL_ENEMY_DATA = {
    0: [],  # No enemies in tutorial
    1: [
        (17, 33.4, "horizontal", 17, 32),
        (0.2, 5.5, "horizontal", 0.2, 8.5),
        (36.2, 22, "horizontal", 36.2, 41.2),
        (50.5, 10.6, "horizontal", 50.5, 56),
        (18.5, 19, "horizontal", 18.5, 27.2)
    ],
    2: [
        (8.5, 24, "horizontal", 8.5, 20),
        (0.2, 17.2, "horizontal", 0.2, 8.7),
        (44.5, 30.5, "horizontal", 44, 58.5),
        (35, 14, "horizontal", 35, 41),
        (52.3, 9.1, "horizontal", 52.3, 58.5),
    ],
    3: [
        (10.5, 24, "horizontal", 10.5, 20.5),
        (24, 34, "horizontal", 24, 43),
        (7, 13.6, "horizontal", 7, 15.5),
        (30, 2.6, "horizontal", 30, 38.5),
        (48, 7.5, "horizontal", 48, 57),
        (37.5, 15.8, "horizontal", 37.5, 43.5),
    ],
    4: [],  # No enemies in level 4
    5: [
        (0, 4.2, "horizontal", 0, 9.5),
        (0, 12.5, "horizontal", 0, 11.4),
        (10, 25.7, "horizontal", 10, 18.2),
        (41, 25.7, "horizontal", 41, 45),
        (16.5, 19, "horizontal", 16.5, 22.3),
        (38, 19, "horizontal", 38, 42),
        (19.8, 12.5, "horizontal", 19.8, 24),
        (34.4, 12.5, "horizontal", 34.4, 39.7),
        (42.9, 4.3, "horizontal", 42.9, 48.9),
        (51, 14, "horizontal", 51, 59),
        (44, 32.2, "horizontal", 44, 49),
        (10, 32.2, "horizontal", 10, 14)
    ]
}

# Update LEVEL_DEADLY_DATA for hazardous tiles
LEVEL_DEADLY_DATA = {
    0: [],  # No deadly tiles in tutorial
    1: [],  # No deadly tiles in level 1
    2: [
        (23.2, 3.6, 3, 1),
        (26.4, 10.2, 4.8, 1.3),
        (28, 34, 15, 1)
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6)
    ],
    4: [
        (10, 22.4, 11.3, 1.3)
    ],
    5: [
        (0.2, 34, 59, 4),
        (15.4, 28, 2.2, 3),
        (22, 25.4, 2, 2),
        (25, 12, 2.4, 2.7),
        (28.4, 18.7, 2.4, 2.3),
        (31.8, 25.2, 2.3, 2),
        (26.9, 32, 2, 2),
        (40.2, 25.3, 2, 2),
        (41.7, 30.3, 2, 2)
    ]
}

# Update LEVEL_BLUE_DATA for special tiles
LEVEL_BLUE_DATA = {
    0: [],  # No blue tiles in tutorial
    1: [],  # No blue tiles in level 1
    2: [
        (23.2, 3.6, 3, 1.1),
        (26.4, 10.2, 4.8, 1.4)
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6)
    ],
    4: [
        (10, 23.4, 11.3, 1.3),
        (18.5, 23.4, 1, 7.6)
    ],
    5: [
        (26.2, 13.5, 1.7, 1.3),
        (26.4, 20, 4.8, 1.3),
        (19.6, 26.7, 5.3, 1.5),
        (41, 26.7, 5, 1.5),
        (31.1, 26.7, 3.3, 1.5)
    ]
}

# Initialize video capture and load images
background_surfaces = {}
video_captures = {}

for level, bg_data in level_backgrounds.items():
    if bg_data['type'] == 'video':
        try:
            video_captures[level] = cv2.VideoCapture(bg_data['path'])
        except Exception as e:
            print(f"Error loading video for level {level}: {e}")
            # Fallback to a solid color or default image
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))
    else:
        try:
            img = pygame.image.load(bg_data['path']).convert()
            background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except Exception as e:
            print(f"Error loading image for level {level}: {e}")
            # Fallback to a solid color
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))

# Update collision tile creation (in World class):
def __init__(self, level_data, deadly_data):
    self.collision_tiles = []
    self.deadly_tiles = []

    for plat in level_data:
        # Adjust coordinates to align with background
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        height = int(plat[3] * TILE_SIZE)
        
        # Add small margin for better collision
        margin = 2
        collision_rect = pygame.Rect(
            x + margin,
            y + margin,
            width - margin * 2,
            height - margin * 2
        )
        self.collision_tiles.append(CollisionTile(x, y, width, height))

    for deadly in deadly_data:
        x = deadly[0] * TILE_SIZE
        y = deadly[1] * TILE_SIZE
        width = deadly[2] * TILE_SIZE
        height = int(deadly[3] * TILE_SIZE)
        
        # Add similar margin for deadly tiles
        margin = 2
        self.deadly_tiles.append(CollisionTile(
            x + margin, 
            y + margin, 
            width - margin * 2, 
            height - margin * 2
        ))

    
# Update LEVEL_DIALOGUES dictionary to add Level 0
LEVEL_DIALOGUES = {
    0: [
        "Tutorial Level: Learning the Basics",
        "Master the art of movement and key collection.",
        "Collect 3 keys to proceed to your first real challenge.",
        "Press SPACE to continue..."
    ],
    1: [
        "Level 1: The Assassin's Trial",
        "Find 4 keys while avoiding deadly traps.",
        "Press SPACE to continue..."
    ],
    2: [
        "Level 2: The Wizard's Tower",
        "Collect 5 keys hidden by magical illusions.",
        "Press SPACE to continue..."
    ],
    3: [
        "Level 3: The Autocrat's Domain",
        "Gather 6 keys from this sprawling fortress.",
        "Press SPACE to continue..."
    ],
    4: [
        "Level 4: The Wraith's Nightmare",
        "Find 8 keys in this realm of shadows.",
        "Press SPACE to continue..."
    ],
    5: [
        "Final Level: The Undead King's Castle",
        "Collect all 10 keys to complete your journey.",
        "Press SPACE to continue..."
    ]
}

class Leaderboard:
    def __init__(self, screen):
        self.screen = screen
        self.scores = []
        self.font = pygame.font.SysFont('Bauhaus 93', 24)
        self.title_font = pygame.font.SysFont('Bauhaus 93', 32)
        self.load_scores()

    def add_score(self, player_name, time_seconds):
        self.scores.append({
            'name': player_name,
            'time': time_seconds
        })
        self.scores.sort(key=lambda x: x['time'])  # Sort by time (ascending)
        self.scores = self.scores[:10]  # Keep only top 10
        self.save_scores()

    def load_scores(self):
        try:
            with open('leaderboard.txt', 'r') as f:
                lines = f.readlines()
                self.scores = []
                for line in lines:
                    name, time = line.strip().split(',')
                    self.scores.append({'name': name, 'time': float(time)})
        except FileNotFoundError:
            self.scores = []

    def save_scores(self):
        with open('leaderboard.txt', 'w') as f:
            for score in self.scores:
                f.write(f"{score['name']},{score['time']}\n")

    def draw(self):
        # Create semi-transparent background
        leaderboard_surface = pygame.Surface((300, 400), pygame.SRCALPHA)
        pygame.draw.rect(leaderboard_surface, (0, 0, 0, 180), (0, 0, 300, 400))
        
        # Draw title
        title = self.title_font.render("LEADERBOARD", True, (255, 215, 0))
        leaderboard_surface.blit(title, (150 - title.get_width()//2, 10))
        
        # Draw scores
        y = 60
        for i, score in enumerate(self.scores):
            minutes = int(score['time'] // 60)
            seconds = int(score['time'] % 60)
            text = self.font.render(f"{i+1}. {score['name']}: {minutes:02d}:{seconds:02d}", True, (255, 255, 255))
            leaderboard_surface.blit(text, (20, y))
            y += 30
        
        # Position leaderboard on right side of screen
        self.screen.blit(leaderboard_surface, (self.screen.get_width() - 320, 60))


class SceneManager:
    def __init__(self, screen):
        self.screen = screen
        self.current_scene = None
        self.scenes = []
        self.scene_index = 0
        self.player_name = ""
        self.text_input = TextInput(screen)
        self.text_input.active = True
        self.current_state = "scene"
        self.level_completed = False
        self.current_level = 0
        self.load_scenes()

    def load_scenes(self):
        self.scenes = [
            # Scene 1 - Name Input
            {
                'image': 'DCI_Scenes/Scene1.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene1.mp3',
                'text': 'Enter Your Name: input()',
                'input': True,
                'next': 'scene'
            },
            # Scene 2
            {
                'image': 'DCI_Scenes/Scene2.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene2.mp3',
                'text': f'Dear {self.player_name}, you stumbled upon the ancient artifact, half-buried in a cave. It was a stone box, covered in intricate, interlocking symbols that seemed to shift if you stared too long.',
                'next': 'scene'
            },
            # Scene 3
            {
                'image': 'DCI_Scenes/Scene3.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene3.mp3',
                'text': f'{self.player_name} worked carefully, pressing and turning parts of the stone, the symbols clicked into alignment. Inside was a letter that wrote: "Whoever unlocks these secrets is bound to us. Your presence is now required. The island awaits, {self.player_name}."',
                'next': 'scene'
            },
            # Scene 4
            {
                'image': 'DCI_Scenes/Scene4.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene4.mp3',
                'text': f'{self.player_name} feels something watching. A mysterious voice echoes through the darkness.',
                'next': 'scene'
            },
            # Scene 5
            {
                'image': 'DCI_Scenes/Scene5.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene5.mp3',
                'text': f'{self.player_name} follows the voice as it gets closer and closer.',
                'next': 'scene'
            },
            # Scene 6
            {
                'image': 'DCI_Scenes/Scene6.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene6.mp3',
                'text': f'Before {self.player_name} realizes, the path leads to a forest with an eerie feel.',
                'next': 'scene'
            },
            # Scene 7 - Lead to Tutorial Level
            {
                'image': 'DCI_Scenes/Scene7.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene7.mp3',
                'text': f'The ghostly voice of Eralt lingers in the air.\n\nEralt the Ghost: "Welcome, {self.player_name}. Beware, young master. The island knows your fears, your weaknesses. Solve the code, and move closer to your destiny. Fail, and join the lost souls who could not decode the island\'s secrets."',
                'next': 'level_0'
            },
            # Scene 8 - After Tutorial, before Level 1
            {
                'image': 'DCI_Scenes/Scene8.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene8.mp3',
                'text': f'A figure emerges from the shadows.\n\nPalak the Assassin: "I am Palak, the Assassin, Guardian of the First Level. Ah, so you are {self.player_name}. To pass my challenge, you must prove you can see through deception and lies. Codes are more than wordstheyre veils of truth and deceit. Decipher mine, or face the consequences."',
                'next': 'level_1'
            },
            # Scene 9 - After Level 1 completion
            {
                'image': 'DCI_Scenes/Scene9.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene9.mp3',
                'text': f'{self.player_name} completes the code with determination.\n\nPalak the Assassin: "Impressive, {self.player_name}. You may pass for now. Your journey has only begun."',
                'next': 'scene'
            },
            # Scene 10 - Lead to Level 2
            {
                'image': 'DCI_Scenes/Scene10.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene10.mp3',
                'text': f'Russ the Wizard: "Ah, so the prophecy speaks true. {self.player_name}, the new champion, has arrived." He gestures to a puzzle box floating in mid-air, surrounded by a shimmering aura.',
                'next': 'level_2'
            },
            # Scene 11 - After Level 2 completion
            {
                'image': 'DCI_Scenes/Scene11.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene11.mp3',
                'text': f'The Wizard smiles approvingly, nodding.\n\nRuss the Wizard: "Well done, {self.player_name}. You\'ve earned the right to advance. Your wisdom grows stronger with each challenge."',
                'next': 'scene'
            },
            # Scene 12 - Lead to Level 3
            {
                'image': 'DCI_Scenes/Scene12.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene12.mp3',
                'text': f'Geoff the Autocrat: "So, {self.player_name}, you\'ve passed the others. But codes are not just puzzles; they\'re tools of control, of power. I rule through secrets, and now you shall learn their true weight."',
                'next': 'level_3'
            },
            # Scene 13 - After Level 3 completion
            {
                'image': 'DCI_Scenes/Scene13.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene13.mp3',
                'text': f'Autocrat inclines his head, a dark smile on his lips.\n\nGeoff the Autocrat: "Impressive, {self.player_name}. Remember, only those who understand power can control it. Your mastery grows. Proceed."',
                'next': 'scene'
            },
            # Scene 14 - Lead to Level 4
            {
                'image': 'DCI_Scenes/Scene14.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene14.mp3',
                'text': f'Jessica the Wraith materializes from the mist.\n\nJessica: "Ah, {self.player_name}, you are brave, but bravery means nothing in the face of fear. This trial is not of logic, but of your darkest nightmares. Let us see what lies in the depths of your soul."',
                'next': 'level_4'
            },
            # Scene 15 - After Level 4 completion
            {
                'image': 'DCI_Scenes/Scene15.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene15.mp3',
                'text': f'Jessica the Wraith: "You surprise me, {self.player_name}. Few have faced their fears with such resolve. You may go on, though many are lost here Remember this strength in the trials ahead."',
                'next': 'scene'
            },
            # Scene 16 - Lead to Final Level
            {
                'image': 'DCI_Scenes/Scene16.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene16.mp3',
                'text': f'The Undead King\'s voice resonates through the chamber.\n\nJacobo: "At last, {self.player_name}, you stand before the final trial. I am Jacobo, the Undead King, master of the lost and forgotten. To claim victory, you must decipher the oldest code of all, the language of life and death itself."',
                'next': 'level_5'
            },
            # Scene 17 - After Final Level completion
            {
                'image': 'DCI_Scenes/Scene17.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene17.mp3',
                'text': f'Jacobo the Undead King: "Remarkable, {self.player_name}. You have proven yourself beyond all expectations. But know that this accomplishment is not a prize, but a burden. The codes you now possess contain secrets that even the spirits dare not speak. Guard them well, for they will change everything."',
                'next': 'scene'
            },
            # Scene 18 - Exit scene
            {
                'image': 'DCI_Scenes/Scene18.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene18.mp3',
                'text': f'{self.player_name} emerges from the cave, forever changed by the journey.',
                'next': 'scene'
            },
            # Scene 19 - Final scene and credits
            {
                'image': 'DCI_Scenes/Scene19.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene19.mp3',
                'text': f'Congratulations, {self.player_name}. You are free, but the knowledge you carry will be your eternal companion.',
                'next': 'game_complete',
                'show_credits': True
            }
        ]
        
        # Initialize first scene
        self.current_scene = Scene(self.screen, self.scenes[0])

    def update_scenes_with_name(self):
        """Update all scenes with the player's name"""
        for i in range(1, len(self.scenes)):
            if 'text' in self.scenes[i]:
                self.scenes[i]['text'] = self.scenes[i]['text'].format(
                    player_name=self.player_name)
        
        # Update current scene if not on first scene
        if self.scene_index > 0:
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index], self.player_name)

    def next_scene(self):
        self.scene_index += 1
        if self.scene_index < len(self.scenes):
            self.current_scene = Scene(
                self.screen, 
                self.scenes[self.scene_index],
                self.player_name  # Add this parameter
            )
        else:
            self.scene_index = len(self.scenes) - 1  # Stay on last scene

    def handle_level_completion(self, level):
        self.level_completed = True
        self.current_level = level + 1
        level_to_scene = {
            0: 6,  # After tutorial, go to Scene 7
            1: 7,  # After Level 1, go to Scene 8
            2: 10, # After Level 2, go to Scene 11
            3: 12, # After Level 3, go to Scene 13
            4: 14, # After Level 4, go to Scene 15
            5: 16  # After Level 5, go to Scene 17
        }
        if level in level_to_scene:
            self.scene_index = level_to_scene[level]
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index], self.player_name)
            return 'scene'
        return 'playing'

    def update(self, dt):
        # Handle current scene update
        if self.current_scene:
            scene_complete = self.current_scene.update(dt)
            if scene_complete:
                next_state = self.scenes[self.scene_index].get('next', 'scene')
                if next_state.startswith('level_'):
                    level_num = int(next_state.split('_')[1])
                    self.current_level = level_num
                    return 'playing'
                elif next_state == 'scene':
                    self.next_scene()
        return self.current_state

    def next_scene(self):
        self.scene_index += 1
        if self.scene_index < len(self.scenes):
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index])
        else:
            self.scene_index = len(self.scenes) - 1  # Stay on last scene

    def draw(self):
        """Draw the current scene"""
        if self.current_scene:
            self.current_scene.draw()
            
            # Draw text input if active and in name input state
            if self.text_input.active:
                self.text_input.draw(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        

class TextInput:
    def __init__(self, screen, font_size=32):
        self.screen = screen
        self.font = pygame.font.SysFont('Bauhaus 93', font_size)
        self.input_text = ""
        self.active = True
        self.cursor_visible = True
        self.cursor_timer = pygame.time.get_ticks()
        self.cursor_blink_speed = 500  # Blink every 500ms
        self.max_length = 20
        
        # Visual styling
        self.box_width = 300
        self.box_height = 50
        self.text_color = (255, 255, 255)
        self.box_color = (0, 0, 0, 180)
        self.border_color = (100, 100, 100)
        self.active_border_color = (200, 200, 200)
        self.prompt_text = "Enter your name:"
        
        # Create prompt surface once
        self.prompt_surface = self.font.render(self.prompt_text, True, self.text_color)

    def handle_event(self, event):
        if not self.active:
            return None

        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RETURN:
                if self.input_text.strip():  # Only accept if there's actual text
                    result = self.input_text.strip()
                    self.active = False
                    return result
            elif event.key == pygame.K_BACKSPACE:
                self.input_text = self.input_text[:-1]
            else:
                if len(self.input_text) < self.max_length and event.unicode.isprintable():
                    self.input_text += event.unicode
        return None

    def draw(self, x, y):
        if not self.active:
            return

        # Center the input box
        box_x = x - self.box_width // 2
        box_y = y

        # Draw the prompt text centered above the input box
        prompt_x = x - self.prompt_surface.get_width() // 2
        prompt_y = box_y - 40
        self.screen.blit(self.prompt_surface, (prompt_x, prompt_y))

        # Draw input box background
        s = pygame.Surface((self.box_width, self.box_height), pygame.SRCALPHA)
        pygame.draw.rect(s, self.box_color, (0, 0, self.box_width, self.box_height))
        self.screen.blit(s, (box_x, box_y))

        # Draw border
        border_color = self.active_border_color if self.active else self.border_color
        pygame.draw.rect(self.screen, border_color, 
                        (box_x, box_y, self.box_width, self.box_height), 2)

        # Draw input text
        if self.input_text:
            text_surface = self.font.render(self.input_text, True, self.text_color)
            text_x = box_x + 10
            text_y = box_y + (self.box_height - text_surface.get_height()) // 2
            self.screen.blit(text_surface, (text_x, text_y))

        # Draw blinking cursor
        current_time = pygame.time.get_ticks()
        if current_time - self.cursor_timer > self.cursor_blink_speed:
            self.cursor_visible = not self.cursor_visible
            self.cursor_timer = current_time

        if self.cursor_visible:
            cursor_x = box_x + 10 + (self.font.size(self.input_text)[0] if self.input_text else 0)
            cursor_y = box_y + 10
            pygame.draw.line(self.screen, self.text_color,
                           (cursor_x, cursor_y),
                           (cursor_x, cursor_y + self.box_height - 20),
                           2)

        # Draw instruction text
        instruction_text = "Press ENTER to confirm"
        instruction_surface = pygame.font.SysFont('Bauhaus 93', 20).render(
            instruction_text, True, (200, 200, 200))
        instruction_x = x - instruction_surface.get_width() // 2
        instruction_y = box_y + self.box_height + 10
        self.screen.blit(instruction_surface, (instruction_x, instruction_y))

class Scene:
    def __init__(self, screen: pygame.Surface, scene_data: dict, player_name=""):  # Add player_name parameter
        self.screen = screen
        self.scene_data = scene_data.copy()
        self.bg_image = None
        self.audio = None
        self.text_box = None
        self.text_font = pygame.font.SysFont('Bauhaus 93', 32)
        self.fade_alpha = 0
        self.fade_speed = 5
        self.fading_in = True
        self.fading_out = False
        self.completed = False
        self.is_name_input = scene_data.get('input', False)
        
        # Format the text with the player's name if available
        if 'text' in self.scene_data and player_name:
            self.scene_data['text'] = self.scene_data['text'].replace('{self.player_name}', player_name)
            self.scene_data['text'] = self.scene_data['text'].replace('{player_name}', player_name)
                
        self.load_assets()
                
    def load_assets(self):
        # Load background image
        if 'image' in self.scene_data:
            try:
                self.bg_image = pygame.image.load(self.scene_data['image'])
                self.bg_image = pygame.transform.scale(self.bg_image, self.screen.get_size())
            except pygame.error:
                print(f"Could not load image: {self.scene_data['image']}")
                self.bg_image = pygame.Surface(self.screen.get_size())
                self.bg_image.fill((0, 0, 0))
        
        # Load audio
        if 'audio' in self.scene_data:
            try:
                self.audio = pygame.mixer.Sound(self.scene_data['audio'])
                self.audio.play()
            except pygame.error:
                print(f"Could not load audio: {self.scene_data['audio']}")
    
    def update(self, dt: float) -> bool:
        if self.fading_in:
            self.fade_alpha = min(255, self.fade_alpha + self.fade_speed)
            if self.fade_alpha >= 255:
                self.fading_in = False
        elif self.fading_out:
            self.fade_alpha = max(0, self.fade_alpha - self.fade_speed)
            if self.fade_alpha <= 0:
                self.cleanup()  # Stop audio when fade out completes
                self.completed = True
        
        # Only return completed if we're not in the middle of a fade effect
        return self.completed
    
    def draw(self):
        # Always draw background image first
        if self.bg_image:
            self.screen.blit(self.bg_image, (0, 0))
        
        # Draw text box if there's text and not a name input scene
        if not self.is_name_input and 'text' in self.scene_data:
            self.draw_text_box(self.scene_data['text'])
        
        # Show prompt when ready for input
        if not self.fading_in and not self.fading_out and not self.is_name_input:
            prompt_font = pygame.font.SysFont('Bauhaus 93', 24)
            prompt = prompt_font.render("Press SPACE to continue...", True, (200, 200, 200))
            prompt_rect = prompt.get_rect(
                right=self.screen.get_width() - 20,
                bottom=self.screen.get_height() - 20
            )
            self.screen.blit(prompt, prompt_rect)
        
        # Apply fade effect last
        fade_surface = pygame.Surface(self.screen.get_size(), pygame.SRCALPHA)
        fade_surface.fill((0, 0, 0, 255 - self.fade_alpha))
        self.screen.blit(fade_surface, (0, 0))
    
    def draw_text_box(self, text: str):
        # Create semi-transparent text box
        box_height = 150
        box_surface = pygame.Surface((self.screen.get_width(), box_height), pygame.SRCALPHA)
        box_surface.fill((0, 0, 0, 180))
        
        # Draw text
        lines = self.wrap_text(text, self.screen.get_width() - 40)
        y_offset = 20
        for line in lines:
            text_surface = self.text_font.render(line, True, (255, 255, 255))
            box_surface.blit(text_surface, (20, y_offset))
            y_offset += 40
        
        # Draw box at bottom of screen
        self.screen.blit(box_surface, (0, self.screen.get_height() - box_height))
    
    def wrap_text(self, text: str, max_width: int):
        words = text.split()
        lines = []
        current_line = []
        current_width = 0
        
        for word in words:
            word_surface = self.text_font.render(word + " ", True, (255, 255, 255))
            word_width = word_surface.get_width()
            
            if current_width + word_width <= max_width:
                current_line.append(word)
                current_width += word_width
            else:
                lines.append(" ".join(current_line))
                current_line = [word]
                current_width = word_width
        
        if current_line:
            lines.append(" ".join(current_line))
        
        return lines
    
    def cleanup(self):
        """Stop audio playback and cleanup resources"""
        if hasattr(self, 'audio') and self.audio:
            try:
                self.audio.stop()
            except (pygame.error, AttributeError):
                pass  # Ignore errors during cleanup
        self.audio = None

    def __del__(self):
        """Ensure audio is stopped when the scene is destroyed"""
        self.cleanup()

    def handle_input(self, event: pygame.event.Event):
        if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
            if not self.fading_in and not self.fading_out:
                self.fading_out = True

def load_minigame(level):
    """Load and run a minigame module when needed"""
    try:
        # Stop any ongoing sounds and music
        pygame.mixer.stop()
        pygame.mixer.music.stop()
        
        # Store current display settings
        current_display = pygame.display.get_surface().copy()
        
        result = False
        
        if level == 1:
            from mini_game1 import main
            result = main()
        elif level == 2:
            from mini_game2 import main
            result = main()
        elif level == 3:
            from mini_game3 import main
            result = main()
        elif level == 4:
            from mini_game4 import main
            result = main()
        elif level == 5:
            from mini_game5 import main
            result = main()
        else:
            print(f"No minigame defined for level {level}")
            return False
            
        # Reset display mode and caption
        pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
        pygame.display.set_caption('Decoding Island')
        
        # Restore previous display if minigame wasn't completed
        if not result:
            screen.blit(current_display, (0, 0))
            pygame.display.flip()
            
            # Show message to player
            font = pygame.font.SysFont('Bauhaus 93', 32)
            text = font.render("You must complete the minigame to proceed!", True, (255, 0, 0))
            text_rect = text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//2))
            screen.blit(text, text_rect)
            pygame.display.flip()
            
            # Wait a moment so player can read the message
            pygame.time.wait(2000)
            
        # Re-initialize game sounds
        init_game()
        
        return result
        
    except ImportError as e:
        print(f"Warning: Could not load minigame {level}: {e}")
        return False
    except Exception as e:
        print(f"Error running minigame {level}: {e}")
        return False

class PauseButton:
    def __init__(self, screen):
        self.screen = screen
        # Create button in top right corner with padding
        self.rect = pygame.Rect(SCREEN_WIDTH - 120, 10, 100, 30)
        self.color = (0, 0, 0, 180)  # Semi-transparent black
        self.hover_color = (50, 50, 50, 180)
        self.font = pygame.font.SysFont('Bauhaus 93', 24)
        self.text = self.font.render('PAUSE', True, (255, 255, 255))
        self.text_rect = self.text.get_rect(center=self.rect.center)
        self.is_hovered = False

    def draw(self):
        # Create surface with alpha for transparency
        button_surface = pygame.Surface((self.rect.width, self.rect.height), pygame.SRCALPHA)
        
        # Draw button with hover effect
        color = self.hover_color if self.is_hovered else self.color
        pygame.draw.rect(button_surface, color, button_surface.get_rect(), border_radius=5)
        
        # Draw button on screen
        self.screen.blit(button_surface, self.rect)
        self.screen.blit(self.text, self.text_rect)

    def handle_event(self, event):
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1 and self.rect.collidepoint(event.pos):
                return True
        return False

class EnhancedGameStats:
    def __init__(self, screen):
        self.screen = screen
        
        # Load and scale icons with more reasonable size
        try:
            icon_size = (32, 32)  # Reduced from 40
            self.trophy_icon = pygame.transform.scale(pygame.image.load('img/trophy.png'), icon_size)
            self.key_icon = pygame.transform.scale(pygame.image.load('img/key_icon.png'), icon_size)
            self.clock_icon = pygame.transform.scale(pygame.image.load('img/clock.png'), icon_size)
        except Exception as e:
            print(f"Error loading game stats icons: {e}")
            self.trophy_icon = pygame.Surface(icon_size)
            self.trophy_icon.fill((255, 215, 0))
            self.key_icon = pygame.Surface(icon_size)
            self.key_icon.fill((255, 255, 255))
            self.clock_icon = pygame.Surface(icon_size)
            self.clock_icon.fill((100, 200, 255))
        
        # Fonts with better sizes
        self.title_font = pygame.font.SysFont('Bauhaus 93', 28)
        self.stats_font = pygame.font.SysFont('Bauhaus 93', 24)
        self.small_font = pygame.font.SysFont('Bauhaus 93', 20)

    def draw_stats_panel(self, level, keys_collected, required_keys, elapsed_time, time_limit):
        # Main panel dimensions
        panel_width = 600  # Fixed width
        panel_height = 40  # Reduced height
        panel_x = (SCREEN_WIDTH - panel_width) // 2  # Center horizontally
        panel_y = 10  # Top padding
        
        # Create semi-transparent panel
        panel_surface = pygame.Surface((panel_width, panel_height), pygame.SRCALPHA)
        pygame.draw.rect(panel_surface, (0, 0, 0, 150), (0, 0, panel_width, panel_height), border_radius=10)
        
        # Section widths
        section_width = panel_width // 3
        
        # Level name (left section)
        level_text = f"{LEVEL_NAMES[level]}"
        name_surface = self.stats_font.render(level_text, True, (255, 215, 0))
        name_x = 20  # Left padding
        name_y = (panel_height - name_surface.get_height()) // 2
        panel_surface.blit(name_surface, (name_x, name_y))
        
        # Time remaining (middle section)
        remaining_time = time_limit - elapsed_time
        minutes = int(remaining_time // 60)
        seconds = int(remaining_time % 60)
        timer_text = self.stats_font.render(f"{minutes:02}:{seconds:02}", True, (255, 255, 255))
        timer_x = section_width + (section_width - timer_text.get_width()) // 2
        timer_y = (panel_height - timer_text.get_height()) // 2
        panel_surface.blit(timer_text, (timer_x, timer_y))
        
        # Keys collected (right section)
        key_text = self.stats_font.render(f"{keys_collected}/{required_keys}", True, (255, 255, 255))
        key_x = section_width * 2 + (section_width - key_text.get_width() - self.key_icon.get_width() - 5) // 2
        key_y = (panel_height - key_text.get_height()) // 2
        panel_surface.blit(self.key_icon, (key_x, key_y))
        panel_surface.blit(key_text, (key_x + self.key_icon.get_width() + 5, key_y))
        
        # Draw the panel on screen
        self.screen.blit(panel_surface, (panel_x, panel_y))

class PauseMenu:
    def __init__(self, screen):
        self.screen = screen
        self.options = ['RESUME', 'RESTART LEVEL', 'QUIT TO MENU']
        
        # Button dimensions and styling
        self.button_width = 250
        self.button_height = 40
        self.button_spacing = 20
        
        # Create button rects centered on screen
        self.button_rects = []
        start_y = SCREEN_HEIGHT // 2
        for i in range(len(self.options)):
            rect = pygame.Rect(
                (SCREEN_WIDTH - self.button_width) // 2,
                start_y + (self.button_height + self.button_spacing) * i,
                self.button_width,
                self.button_height
            )
            self.button_rects.append(rect)
            
        # Fonts
        self.title_font = pygame.font.SysFont('Bauhaus 93', 50)
        self.option_font = pygame.font.SysFont('Bauhaus 93', 35)
        
        # Colors
        self.text_color = (255, 255, 255)
        self.button_color = (50, 50, 50, 180)
        self.hover_color = (70, 70, 70, 180)
        self.selected_color = (255, 215, 0)
        
        self.hovered = None

    def draw(self):
        # Draw dark overlay
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        
        # Draw PAUSED text
        pause_text = self.title_font.render('PAUSED', True, self.text_color)
        text_rect = pause_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//4))
        self.screen.blit(pause_text, text_rect)
        
        # Get mouse position
        mouse_pos = pygame.mouse.get_pos()
        
        # Draw buttons with hover effect
        for i, (option, rect) in enumerate(zip(self.options, self.button_rects)):
            # Check if mouse is hovering over button
            is_hovered = rect.collidepoint(mouse_pos)
            if is_hovered:
                self.hovered = i
                color = self.hover_color
            else:
                color = self.button_color
            
            # Create button surface with alpha
            button_surface = pygame.Surface((rect.width, rect.height), pygame.SRCALPHA)
            pygame.draw.rect(button_surface, color, button_surface.get_rect(), border_radius=5)
            self.screen.blit(button_surface, rect)
            
            # Draw button text
            text = self.option_font.render(option, True, self.selected_color if is_hovered else self.text_color)
            text_rect = text.get_rect(center=rect.center)
            self.screen.blit(text, text_rect)

    def handle_input(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            mouse_pos = pygame.mouse.get_pos()
            for i, rect in enumerate(self.button_rects):
                if rect.collidepoint(mouse_pos):
                    return self.options[i]
        return None

def handle_level_completion(current_level, door, player):
    """Handle level completion and transitions"""
    if not door.entered and keys_collected >= LEVEL_REQUIREMENTS[current_level]:
        # Start door zoom if we have enough keys
        if not door.is_open:
            camera.start_door_zoom(door)
        elif pygame.sprite.collide_rect(player, door):
            door.entered = True
            camera.stop_sounds()
            return True
    return False

def transition_to_next_level():
    """Handle transition to the next level"""
    global current_level, movement_enabled
    
    # Store completion time
    if game_start_time:
        elapsed_time = int(time.time() - game_start_time)
        level_times.append(elapsed_time)
    
    # Determine next level
    next_level = current_level + 1 if current_level < 5 else None
    
    if next_level is not None:
        # Initialize next level
        result = init_level(next_level)
        if result is not None:
            keys_group, door, world, moving_enemies, player, ghost = result
            camera.start_transition()
            movement_enabled = False
            return "playing"
        else:
            print(f"Failed to initialize level {next_level}")
            return "error"
    else:
        # Game completed
        return "game_complete"

def handle_pause():
    """Handle pause menu state and actions"""
    global paused, running, current_state, keys_collected, game_over, total_pause_time, pause_start_time
    
    pause_menu.draw()
    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
            
        if current_state in ["intro_scenes", "level_transition"]:
            scene_manager.handle_input(event)
        
        # Handle pause button click
        if current_state == "playing" and not paused and pause_button.handle_event(event):
            paused = True
            pause_start_time = datetime.now()
            fade_alpha = 0
            
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                paused = False
                total_pause_time += datetime.now() - pause_start_time
                return True
                
        action = pause_menu.handle_input(event)
        if action:
            if action == 'RESUME':
                paused = False
                total_pause_time += datetime.now() - pause_start_time
            elif action == 'RESTART LEVEL':
                paused = False
                game_over = 0
                keys_collected = 0
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                camera.cleanup()
                camera.reset_zoom()
                keys_group, door, world, moving_enemies, player, ghost = init_level(current_level)
                camera.start_transition()
            elif action == 'QUIT TO MENU':
                # Cleanup current game resources
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                cleanup_backgrounds()
                pygame.mixer.stop()  # Stop all sound channels
                pygame.mixer.music.stop()  # Stop background music
                pygame.quit()

                # Import and run main menu
                try:
                    import MAINMENU
                    MAINMENU.main()
                    sys.exit()
                except ImportError as e:
                    print(f"Error returning to main menu: {e}")
                    return False
    
    pygame.display.update()
    return True

def cleanup_game():
    """Cleanup all game resources"""
    if hasattr(player, 'stop_sounds'):
        player.stop_sounds()
    if hasattr(camera, 'stop_sounds'):
        camera.stop_sounds()
    if hasattr(scene_manager, 'cleanup'):
        scene_manager.cleanup()
    cleanup_backgrounds()
    pygame.mixer.stop()
    pygame.mixer.music.stop()
    pygame.quit()

class DialogueBox:
    def __init__(self, screen):
        self.screen = screen
        self.animation_complete = False
        self.current_alpha = 0
        self.target_alpha = 180
        self.fade_speed = 10
        self.current_line = 0
        self.current_word = 0
        self.text_delay = 2
        self.frame_counter = 0
        self.words_revealed = []
        
        # Dialogue box dimensions and position
        self.box_height = 200
        self.box_padding = 20
        self.box_y = SCREEN_HEIGHT - self.box_height - 30
        
        # Text formatting
        self.line_height = 40
        self.max_width = SCREEN_WIDTH - (self.box_padding * 2)
        self.font = pygame.font.SysFont('Bauhaus 93', 32)
        
    def wrap_text(self, text):
        """Split text into lines that fit within the dialogue box"""
        words = text.split()
        lines = []
        current_line = []
        current_width = 0
        
        for word in words:
            word_surface = self.font.render(word + ' ', True, (255, 255, 255))
            word_width = word_surface.get_width()
            
            if current_width + word_width <= self.max_width:
                current_line.append(word)
                current_width += word_width
            else:
                lines.append(' '.join(current_line))
                current_line = [word]
                current_width = word_width
        
        if current_line:
            lines.append(' '.join(current_line))
            
        return lines
        
    def animate(self, dialogue_lines, background_image=None):
        # Draw background image if provided
        if background_image:
            try:
                bg_img = pygame.image.load(background_image).convert()
                bg_img = pygame.transform.scale(bg_img, (SCREEN_WIDTH, SCREEN_HEIGHT))
                self.screen.blit(bg_img, (0, 0))
            except (pygame.error, FileNotFoundError) as e:
                print(f"Error loading background image: {e}")
                self.screen.fill((0, 0, 0))
        
        # Create semi-transparent dialogue box
        dialogue_surface = pygame.Surface((SCREEN_WIDTH, self.box_height), pygame.SRCALPHA)
        box_color = (0, 0, 0, self.current_alpha)
        pygame.draw.rect(dialogue_surface, box_color, (0, 0, SCREEN_WIDTH, self.box_height))
        
        # Animate fade in
        if self.current_alpha < self.target_alpha:
            self.current_alpha = min(self.current_alpha + self.fade_speed, self.target_alpha)
        
        self.screen.blit(dialogue_surface, (0, self.box_y))
        
        # Initialize words_revealed if needed
        if not self.words_revealed:
            # Wrap each dialogue line
            wrapped_lines = []
            for line in dialogue_lines:
                wrapped_lines.extend(self.wrap_text(line))
            self.words_revealed = [[] for _ in wrapped_lines]
        
        # Update text animation
        self.frame_counter += 1
        if self.frame_counter >= self.text_delay:
            self.frame_counter = 0
            self.update_text(dialogue_lines)
        
        # Draw text
        y_offset = self.box_y + self.box_padding
        line_spacing = 40
        
        for i, revealed_words in enumerate(self.words_revealed):
            if revealed_words:  # Only draw lines that have revealed words
                text = ' '.join(revealed_words)
                text_surface = self.font.render(text, True, (255, 255, 255))
                text_rect = text_surface.get_rect(
                    left=self.box_padding,
                    top=y_offset + i * line_spacing
                )
                self.screen.blit(text_surface, text_rect)
        
        # Add "Press SPACE to continue" prompt when animation is complete
        if self.animation_complete:
            prompt = pygame.font.SysFont('Bauhaus 93', 24).render(
                "Press SPACE to continue...", True, (200, 200, 200))
            prompt_rect = prompt.get_rect(
                right=SCREEN_WIDTH - self.box_padding,
                bottom=SCREEN_HEIGHT - self.box_padding
            )
            self.screen.blit(prompt, prompt_rect)
        
        return self.animation_complete
    
    def update_text(self, dialogue_lines):
        if self.current_line < len(dialogue_lines):
            wrapped_lines = []
            for line in dialogue_lines:
                wrapped_lines.extend(self.wrap_text(line))
            
            if self.current_line < len(wrapped_lines):
                words = wrapped_lines[self.current_line].split()
                if self.current_word < len(words):
                    self.words_revealed[self.current_line].append(words[self.current_word])
                    self.current_word += 1
                else:
                    self.current_line += 1
                    self.current_word = 0
            else:
                self.animation_complete = True
        else:
            self.animation_complete = True

def show_dialogue(dialogue_lines, background_key=None):
    """
    Show dialogue with background image based on the dialogue section.
    
    Args:
        dialogue_lines (list): List of strings containing dialogue text
        background_key (str): Key for background image from DIALOGUE_BACKGROUNDS
    """
    dialogue_box = DialogueBox(screen)
    background_path = None
    
    if background_key and background_key in DIALOGUE_BACKGROUNDS:
        background_path = DIALOGUE_BACKGROUNDS[background_key]
        try:
            background = pygame.image.load(background_path).convert()
            background = pygame.transform.scale(background, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except (pygame.error, FileNotFoundError) as e:
            print(f"Error loading background image {background_path}: {e}")
            background = None
    else:
        background = None

    waiting = True
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                    return True
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        # Clear screen
        screen.fill((0, 0, 0))
        
        # Draw background if available
        if background:
            screen.blit(background, (0, 0))
            
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

class Ghost(pygame.sprite.Sprite):
    def __init__(self, screen_width, screen_height, player, level):
        super().__init__()
        # Load and scale ghost image
        self.image = pygame.image.load('img/sghost.png').convert_alpha()
        self.image = pygame.transform.scale(self.image, (60, 60))
        self.rect = self.image.get_rect()
        
        # Ghost properties - Make ghost slower in higher levels
        self.base_speed = 2.0
        # Decrease speed for each level instead of increasing
        self.level_speed_multiplier = -0.25  # Changed from 0.4 to -0.25
        # Set minimum speed to prevent ghost from becoming too slow
        self.speed = max(0.8, self.base_speed + (level * self.level_speed_multiplier))
        self.player = player
        
        # Decrease visibility range in higher levels
        self.visibility_range = max(400, 600 - (level * 50))  # Starts at 600, decreases by 50 each level
        
        # Set initial position
        self.spawn_position(screen_width, screen_height)
        
        # Floating movement properties
        self.float_offset = 0
        self.float_speed = 0.05
        self.float_amplitude = 8
        self.true_x = float(self.rect.x)
        self.true_y = float(self.rect.y)
        
        # Transparency properties - Make ghost more transparent in higher levels
        self.min_alpha = max(80, 120 - (level * 10))  # Starts at 120, decreases by 10 each level
        
        # Pulsing effect
        self.pulse_counter = 0
        self.pulse_speed = 0.05
        self.pulse_range = max(20, 40 - (level * 5))  # Reduced pulsing range in higher levels

    def spawn_position(self, screen_width, screen_height):
        """Spawn ghost at the farthest point from player"""
        corners = [
            (0, 0),
            (screen_width - self.rect.width, 0),
            (0, screen_height - self.rect.height),
            (screen_width - self.rect.width, screen_height - self.rect.height)
        ]
        
        max_distance = 0
        spawn_pos = corners[0]
        
        for corner in corners:
            distance = math.sqrt(
                (corner[0] - self.player.rect.x) ** 2 + 
                (corner[1] - self.player.rect.y) ** 2
            )
            if distance > max_distance:
                max_distance = distance
                spawn_pos = corner
        
        self.rect.x = spawn_pos[0]
        self.rect.y = spawn_pos[1]
        self.true_x = float(self.rect.x)
        self.true_y = float(self.rect.y)

    def update(self):
        if not movement_enabled or camera.door_zoom:
            return
            
        # Calculate direction to player
        dx = self.player.rect.centerx - self.rect.centerx
        dy = self.player.rect.centery - self.rect.centery
        
        # Normalize the direction
        distance = math.sqrt(dx ** 2 + dy ** 2)
        if distance > 0:
            dx = dx / distance
            dy = dy / distance
        
        # Update position with adjusted tracking
        distance_factor = min(1.0, distance / self.visibility_range)  # Reduced from 1.5 to 1.0
        actual_speed = self.speed * distance_factor
        
        self.true_x += dx * actual_speed
        self.true_y += dy * actual_speed
        
        # Add floating movement
        self.float_offset += self.float_speed
        float_y = math.sin(self.float_offset) * self.float_amplitude
        
        # Update rect position
        self.rect.x = int(self.true_x)
        self.rect.y = int(self.true_y + float_y)
        
        # Update pulsing effect
        self.pulse_counter += self.pulse_speed
        pulse_alpha = math.sin(self.pulse_counter) * self.pulse_range
        
        # Calculate alpha with reduced visibility range
        current_distance = math.sqrt(
            (self.player.rect.centerx - self.rect.centerx) ** 2 + 
            (self.player.rect.centery - self.rect.centery) ** 2
        )
        
        # Calculate alpha with pulsing effect
        base_alpha = max(self.min_alpha, min(255, (1 - current_distance / self.visibility_range) * 255))
        final_alpha = min(255, max(self.min_alpha, base_alpha + pulse_alpha))
        
        # Apply alpha
        self.image.set_alpha(int(final_alpha))

    def check_collision(self, player):
        """Check for collision with player using a larger collision margin in higher levels"""
        # Increase collision margin for higher levels to make it more forgiving
        collision_margin = 8 + (current_level * 2)  # Increases by 2 pixels per level
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)
    
def check_level_timer(elapsed_time, time_limit):
    """Check if the level time limit has been exceeded"""
    return elapsed_time >= time_limit

class Camera:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.scroll_x = 0
        self.scroll_y = 0
        self.zoom = 1
        self.target_zoom = 1
        self.base_zoom = 2.5
        self.zoom_out_level = 1.3
        self.zoom_speed = 0.04
        self.transitioning = False
        self.transition_start_time = 0
        self.transition_delay = 2000
        self.transition_duration = 2000
        self.transition_total_time = self.transition_delay + self.transition_duration
        self.transition_complete = False
        self.manual_zoom_active = False
        self.initial_zoom_done = False
        
        # Door zoom properties
        self.door_zoom = False
        self.door_zoom_target = None
        self.door_zoom_speed = 0.02
        self.door_target_zoom = 3.5
        self.door_transition_start = 0
        self.door_transition_duration = 1500
        self.post_open_delay = 1000
        self.door_opened_time = 0
        self.reset_on_death = False
        self.death_reset_time = 0
        self.death_reset_duration = 1000  # 1 second for reset animation
        
        # Sound properties
        self.wind_sound = pygame.mixer.Sound('img/Gust of Wind.mp3')
        self.jungle_music = pygame.mixer.Sound('img/Background Music.MP3')
        self.zoom_out_sound = pygame.mixer.Sound('img/zoom_out.mp3')  # Add this line
        self.wind_sound.set_volume(0.8)
        self.jungle_music.set_volume(0.4)
        self.zoom_out_sound.set_volume(0.5)  # Add this line
        self.wind_sound_playing = False
        self.jungle_music_playing = False
        self.wind_sound_start_time = 0
        self.wind_sound_duration = int(self.wind_sound.get_length() * 1000)
        
        self.visible_width = width
        self.visible_height = height

    def apply(self, surface, entity):
        scaled_rect = scale_rect(entity.rect)
        return pygame.Rect(
            scaled_rect.x - self.scroll_x,
            scaled_rect.y - self.scroll_y,
            scaled_rect.width,
            scaled_rect.height
        )

    def apply_sprite(self, surface, sprite):
        scaled_pos = scale_position(
            sprite.rect.x - self.scroll_x,
            sprite.rect.y - self.scroll_y
        )
        return scaled_pos

    def reset_zoom(self):
        """Reset camera zoom when player dies"""
        self.reset_on_death = True
        self.death_reset_time = pygame.time.get_ticks()
        self.zoom = self.base_zoom
        self.target_zoom = self.base_zoom
        self.manual_zoom_active = False
        self.door_zoom = False
        self.door_zoom_target = None
        self.transitioning = False
        self.initial_zoom_done = True

    def start_door_zoom(self, door):
        if not self.door_zoom and not self.manual_zoom_active:
            self.door_zoom = True
            self.door_zoom_target = door
            self.door_transition_start = pygame.time.get_ticks()
            self.door_target_zoom = 3.5
            # All entities will freeze due to the door_zoom check in their update methods
        
    def start_transition(self):
        # Stop any existing sounds before starting new ones
        self.stop_sounds()
        self.transitioning = True
        self.transition_complete = False
        self.zoom = 1
        self.transition_start_time = pygame.time.get_ticks()
        
        # Start wind sound and track its start time
        self.wind_sound.play()
        self.wind_sound_playing = True
        self.wind_sound_start_time = pygame.time.get_ticks()
        self.jungle_music_playing = False
    
    def update(self, target, keys_collected, door, required_keys):
        current_time = pygame.time.get_ticks()
        
        # Handle manual zoom control with Enter key
        keys = pygame.key.get_pressed()
        if keys[pygame.K_RETURN]:
            self.manual_zoom_active = True
            self.target_zoom = self.zoom_out_level
            self.zoom_out_sound.play()
        elif self.manual_zoom_active:
            self.manual_zoom_active = False
            self.target_zoom = self.base_zoom if self.transition_complete else 1
        
        # Handle initial transition
        if self.transitioning and not self.initial_zoom_done:
            elapsed = current_time - self.transition_start_time
            
            if elapsed >= self.transition_delay:
                zoom_elapsed = elapsed - self.transition_delay
                progress = min(zoom_elapsed / self.transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                if not self.manual_zoom_active:
                    self.zoom = 1 + (self.base_zoom - 1) * progress
                
                if progress >= 1:
                    self.transitioning = False
                    self.transition_complete = True
                    self.initial_zoom_done = True
                    global movement_enabled, game_start_time
                    movement_enabled = True
                    
                    # Only start the timer when the initial zoom is complete
                    if game_start_time is None:
                        game_start_time = time.time()
                    
                    if not self.manual_zoom_active:
                        self.zoom = self.base_zoom
                        self.target_zoom = self.base_zoom
        
        # Handle smooth zoom transition
        elif not self.door_zoom:
            if self.zoom != self.target_zoom:
                diff = self.target_zoom - self.zoom
                self.zoom += diff * self.zoom_speed
        
        # Handle door zoom if active
        if self.door_zoom and self.door_zoom_target:
            elapsed = current_time - self.door_transition_start
            
            if not self.door_zoom_target.is_open:
                progress = min(elapsed / self.door_transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                self.zoom = 1 + (self.door_target_zoom - 1) * progress
                
                # Calculate center position for the door
                target_x = self.door_zoom_target.rect.centerx - (SCREEN_WIDTH // (2 * self.zoom))
                target_y = self.door_zoom_target.rect.centery - (SCREEN_HEIGHT // (2 * self.zoom))
                
                # Smoothly move camera to center the door
                self.scroll_x += (target_x - self.scroll_x) * 0.1
                self.scroll_y += (target_y - self.scroll_y) * 0.1
                
                if progress >= 1.0:
                    self.door_zoom_target.open_door()
                    self.door_opened_time = current_time
            else:
                hold_time = current_time - self.door_opened_time
                if hold_time >= self.post_open_delay:
                    zoom_out_progress = min((hold_time - self.post_open_delay) / 1000, 1.0)
                    zoom_out_progress = self.ease_out_cubic(zoom_out_progress)
                    
                    target_zoom = self.target_zoom
                    self.zoom = self.door_target_zoom - (self.door_target_zoom - target_zoom) * zoom_out_progress
                    
                    if zoom_out_progress >= 1.0:
                        self.door_zoom = False
                        self.zoom = target_zoom
        
        # Handle death reset
        if self.reset_on_death:
            elapsed = current_time - self.death_reset_time
            if elapsed <= self.death_reset_duration:
                # Smoothly transition zoom back to base level
                progress = elapsed / self.death_reset_duration
                progress = self.ease_out_cubic(progress)
                self.zoom = 1 + (self.base_zoom - 1) * progress
            else:
                self.reset_on_death = False
                self.zoom = self.base_zoom
                self.target_zoom = self.base_zoom
        
        # Update sound behavior
        if (self.wind_sound_playing and 
            current_time - self.wind_sound_start_time >= self.wind_sound_duration and 
            not self.jungle_music_playing):
            self.wind_sound_playing = False
            self.jungle_music.play()
            self.jungle_music_playing = True
        
        # Update visible area and camera position
        self.visible_width = self.width // self.zoom
        self.visible_height = self.height // self.zoom
        
        # Normal camera follow behavior when not zooming to door
        if not self.door_zoom:
            target_x = target.rect.centerx - self.visible_width // 2
            target_y = target.rect.centery - self.visible_height // 2
            
            self.scroll_x += (target_x - self.scroll_x) * 0.1
            self.scroll_y += (target_y - self.scroll_y) * 0.1
        
        # Keep the camera within bounds
        self.scroll_x = max(0, min(self.scroll_x, SCREEN_WIDTH - self.visible_width))
        self.scroll_y = max(0, min(self.scroll_y, SCREEN_HEIGHT - self.visible_height))
    
    def stop_sounds(self):
        """Stop all sounds and reset sound states"""
        try:
            if pygame.mixer.get_init():  # Check if mixer is initialized
                self.wind_sound.stop()
                self.jungle_music.stop()
                self.zoom_out_sound.stop()  # Add this line
        except (AttributeError, pygame.error):
            pass
        self.wind_sound_playing = False
        self.jungle_music_playing = False

        
    # Update the Camera class cleanup method:
    def cleanup(self):
        """Clean up all audio resources and reset camera state"""
        self.stop_sounds()
        self.transitioning = False
        self.transition_complete = False
        self.zoom = 1
        self.wind_sound_start_time = 0
        self.door_zoom = False
        self.door_zoom_target = None
        
    def __del__(self):
        """Destructor to ensure sounds are stopped when the camera object is destroyed"""
        try:
            self.stop_sounds()
        except:
            pass  # Ignore any errors during cleanup

    def ease_out_cubic(self, x):
        return 1 - pow(1 - x, 3)

    def apply(self, surface, entity):
        return pygame.Rect(
            entity.rect.x - self.scroll_x,
            entity.rect.y - self.scroll_y,
            entity.rect.width,
            entity.rect.height
        )

    def apply_sprite(self, surface, sprite):
        # Return the position where the sprite should be drawn
        return (sprite.rect.x - self.scroll_x,
                sprite.rect.y - self.scroll_y)
                
    def apply_rect(self, rect):
        # Apply camera offset to a rect
        return pygame.Rect(
            rect.x - self.scroll_x,
            rect.y - self.scroll_y,
            rect.width,
            rect.height
        )

def reset_level():
    """Properly reset the level state and reinitialize all game components"""
    global game_over, keys_collected, movement_enabled, game_start_time
    global player, world, moving_enemies, keys_group, door, ghost, camera
    global total_pause_time, current_level

    # Reset game state
    game_over = 0
    keys_collected = 0
    movement_enabled = False
    game_start_time = None
    total_pause_time = timedelta(0)

    # Stop all sounds
    if hasattr(player, 'stop_sounds'):
        player.stop_sounds()
    if hasattr(camera, 'stop_sounds'):
        camera.stop_sounds()

    # Cleanup camera
    camera.cleanup()
    camera.reset_zoom()

    try:
        # Get fresh level data
        platforms = LEVEL_PLATFORM_DATA[current_level]
        deadly_tiles = LEVEL_DEADLY_DATA[current_level]
        enemy_data = LEVEL_ENEMY_DATA[current_level]

        # Create new world instance
        world = World(platforms, deadly_tiles)

        # Get spawn position
        spawn_pos = find_spawn_position(platforms)

        # Create new player at spawn position
        player = Player(spawn_pos[0], spawn_pos[1])
        player.dead = False  # Ensure player is not dead

        # Create fresh ghost
        ghost = Ghost(SCREEN_WIDTH, SCREEN_HEIGHT, player, current_level)

        # Get door position and create new door
        door_pos = find_door_position(platforms)
        door = Door(door_pos[0], door_pos[1])
        door.entered = False
        door.is_open = False

        # Create fresh key group with new key positions
        keys_group = pygame.sprite.Group()
        key_positions = generate_key_positions(current_level)
        for pos in key_positions:
            keys_group.add(Key(pos[0], pos[1]))

        # Create fresh enemies
        moving_enemies = pygame.sprite.Group()
        for enemy_info in enemy_data:
            x, y, direction, boundary_start, boundary_end = enemy_info
            enemy = MovingEnemy(x * TILE_SIZE, y * TILE_SIZE, direction, boundary_start, boundary_end)
            moving_enemies.add(enemy)

        # Reset camera and start transition
        camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
        camera.start_transition()

        return True

    except Exception as e:
        print(f"Error resetting level: {e}")
        return False


def generate_key_positions(level):
    """Improved key position generation with better boundary checking"""
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    
    # Screen boundaries with margin
    MARGIN = TILE_SIZE * 2
    screen_bounds = {
        'left': MARGIN,
        'right': SCREEN_WIDTH - MARGIN,
        'top': MARGIN,
        'bottom': SCREEN_HEIGHT - MARGIN
    }
    
    def is_within_bounds(x, y):
        """Check if position is within screen bounds"""
        return (screen_bounds['left'] <= x <= screen_bounds['right'] and
                screen_bounds['top'] <= y <= screen_bounds['bottom'])
    
    # Get viable platform positions
    viable_platforms = []
    for plat in platforms:
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip ground level platforms
        if y < SCREEN_HEIGHT * 0.8:
            # Adjust platform boundaries to ensure keys stay within screen
            plat_left = max(x + MARGIN, screen_bounds['left'])
            plat_right = min(x + width - MARGIN, screen_bounds['right'])
            
            if plat_right > plat_left:  # Only add if there's valid space
                viable_platforms.append((plat_left, y, plat_right - plat_left))
    
    import random
    random.shuffle(viable_platforms)
    
    # Keep trying until we have all required keys
    attempts = 0
    max_attempts = required_keys * 10  # Generous attempt limit
    
    while len(positions) < required_keys and attempts < max_attempts:
        if not viable_platforms:
            break
            
        plat = random.choice(viable_platforms)
        
        # Generate position on platform
        key_x = random.uniform(plat[0], plat[0] + plat[2])
        key_y = plat[1] - TILE_SIZE * 1.5  # Place above platform
        
        # Verify position is within bounds
        if is_within_bounds(key_x, key_y):
            positions.append((key_x, key_y))
        
        attempts += 1
    
    # If we still need more keys, place them on the most suitable platforms
    while len(positions) < required_keys:
        if not viable_platforms:
            break
            
        # Use the widest platform available
        plat = max(viable_platforms, key=lambda p: p[2])
        
        # Calculate safe position
        key_x = plat[0] + (plat[2] / 2)  # Center of platform
        key_y = plat[1] - TILE_SIZE * 1.5
        
        if is_within_bounds(key_x, key_y):
            positions.append((key_x, key_y))
        viable_platforms.remove(plat)
    
    return positions

# Update the video background handling code
def update_video_background(level):
    """Update video frame for video backgrounds"""
    if level in video_captures and video_captures[level] is not None:
        ret, frame = video_captures[level].read()
        if not ret:
            # Reset video to beginning if we've reached the end
            video_captures[level].set(cv2.CAP_PROP_POS_FRAMES, 0)
            ret, frame = video_captures[level].read()
        
        if ret:
            # Convert frame from BGR to RGB and flip to match Pygame's format
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame = cv2.resize(frame, (SCREEN_WIDTH, SCREEN_HEIGHT))
            frame = np.rot90(frame)
            frame = np.flipud(frame)
            frame = pygame.surfarray.make_surface(frame)
            return frame
    return None

# Update the initialization of video captures
# Initialize game assets
def init_game():
    """Initialize video captures and background surfaces"""
    global video_captures, background_surfaces, game_stats, pause_menu
    update_scale_factors()  # Update scaling factors
    video_captures = {}
    background_surfaces = {}
    # Update this line to use EnhancedGameStats instead of GameStats
    game_stats = EnhancedGameStats(screen)
    pause_menu = PauseMenu(screen)
    
    for level, bg_data in level_backgrounds.items():
        if bg_data['type'] == 'video':
            try:
                cap = cv2.VideoCapture(bg_data['path'])
                if not cap.isOpened():
                    print(f"Failed to open video file for level {level}")
                    cap = None
                video_captures[level] = cap
            except Exception as e:
                print(f"Error loading video for level {level}: {e}")
                video_captures[level] = None
        else:
            try:
                img = pygame.image.load(bg_data['path']).convert()
                background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
            except Exception as e:
                print(f"Error loading image for level {level}: {e}")
                fallback = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
                fallback.fill((0, 0, 0))
                background_surfaces[level] = fallback

def get_background(level):
    """Get the current background surface for the given level"""
    if level_backgrounds[level]['type'] == 'video':
        return update_video_background(level)
    else:
        return background_surfaces[level]

# Update the cleanup function
def cleanup_backgrounds():
    """Release all video captures properly"""
    global video_captures
    if 'video_captures' in globals():
        for cap in video_captures.values():
            if cap is not None:
                cap.release()
        video_captures.clear()


def create_zoomed_view(screen, camera, player, world, keys_group, door, moving_enemies, ghost):
    current_visible_width = int(SCREEN_WIDTH // camera.zoom)
    current_visible_height = int(SCREEN_HEIGHT // camera.zoom)
    
    view_surface = pygame.Surface((current_visible_width, current_visible_height))
    
    # Get and draw the current background
    current_background = get_background(current_level)
    if current_background:
        view_surface.blit(current_background, (-camera.scroll_x, -camera.scroll_y))
    
    # Draw platforms (if you want them visible)
    # for tile in world.collision_tiles:
    #     pygame.draw.rect(view_surface, (255, 0, 0), camera.apply_rect(tile.rect), 1)
    
    # Draw keys
    for key in keys_group:
        pos = camera.apply_sprite(view_surface, key)
        if (0 <= pos[0] < current_visible_width and 
            0 <= pos[1] < current_visible_height):
            view_surface.blit(key.image, pos)
    
    # Draw door
    door_pos = camera.apply_sprite(view_surface, door)
    if (0 <= door_pos[0] < current_visible_width and 
        0 <= door_pos[1] < current_visible_height):
        view_surface.blit(door.image, door_pos)
    
    # Draw moving enemies
    for enemy in moving_enemies:
        enemy_pos = camera.apply_sprite(view_surface, enemy)
        if (0 <= enemy_pos[0] < current_visible_width and 
            0 <= enemy_pos[1] < current_visible_height):
            view_surface.blit(enemy.image, enemy_pos)
    
    # Draw ghost
    ghost_pos = camera.apply_sprite(view_surface, ghost)
    if (0 <= ghost_pos[0] < current_visible_width and 
        0 <= ghost_pos[1] < current_visible_height):
        view_surface.blit(ghost.image, ghost_pos)
    
    # Draw player last
    player_pos = camera.apply_sprite(view_surface, player)
    if (0 <= player_pos[0] < current_visible_width and 
        0 <= player_pos[1] < current_visible_height):
        view_surface.blit(player.image, player_pos)
    
    # Scale and draw the final view
    scaled_surface = pygame.transform.scale(view_surface, (SCREEN_WIDTH, SCREEN_HEIGHT))
    screen.blit(scaled_surface, (0, 0))
    
    """"
    # Draw HUD elements
    draw_text(f"Level {current_level}", 40, WHITE, 10, 10)
    draw_text(f"Keys: {keys_collected}/{LEVEL_REQUIREMENTS[current_level]}", 40, WHITE, 10, 60)
    """
    
class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Key(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.frames = key_frames  # Use the key_frames list we created earlier
        
        # Animation variables
        self.current_frame = 0
        self.animation_timer = 0
        self.animation_delay = 100  # Milliseconds between frame changes
        
        # Set initial image
        self.image = self.frames[self.current_frame] if self.frames else key_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        
        # Floating movement variables
        self.original_y = float(y)
        self.float_offset = 0
        self.float_speed = 0.03  # Slightly slower float speed
        
    def update(self):
        if self.frames:  # Only animate if we have frames
            # Update animation frame
            current_time = pygame.time.get_ticks()
            if current_time - self.animation_timer > self.animation_delay:
                self.animation_timer = current_time
                self.current_frame = (self.current_frame + 1) % len(self.frames)
                self.image = self.frames[self.current_frame]
        
        # Update floating movement with reduced amplitude (changed from 15 to 5)
        self.float_offset += self.float_speed
        self.rect.y = self.original_y + math.sin(self.float_offset) * 5  # Reduced from 15 to 5

# In the Door class, update the open_door method to handle the image transition properly:
class Door:
    def __init__(self, x, y):
        super().__init__()
        try:
            # Load closed portal image (using underscore instead of space)
            self.closed_image = pygame.image.load('img/closed_portal.png')
            self.closed_image = pygame.transform.scale(self.closed_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            
            # Load portal animation frames
            self.portal_frames = []
            for i in range(1, 6):
                frame = pygame.image.load(f'img/portal_frame_{i}.png')
                frame = pygame.transform.scale(frame, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
                self.portal_frames.append(frame)
                
        except FileNotFoundError as e:
            print(f"Error loading portal images: {e}")
            print("Falling back to default door images...")
            # Fallback to original door images if portal images aren't found
            self.closed_image = pygame.image.load('img/closeddoor.PNG')
            self.closed_image = pygame.transform.scale(self.closed_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            # Create a simple animation using the open door image
            self.portal_frames = []
            open_image = pygame.image.load('img/opendoor_img.PNG')
            open_image = pygame.transform.scale(open_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            self.portal_frames = [open_image] * 5  # Create 5 copies of the open door image
        
        # Animation properties
        self.current_frame = 0
        self.animation_timer = 0
        self.animation_delay = 50  # Milliseconds between frame changes
        self.is_animating = False
        
        # Initial setup
        self.image = self.closed_image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.is_open = False
        self.door_sound = pygame.mixer.Sound('img/electric_zap.MP3')
        self.door_sound.set_volume(0.5)
        self.sound_played = False
        self.collision_enabled = True
        self.entered = False

    def update(self):
        if self.is_animating:
            current_time = pygame.time.get_ticks()
            
            # Update animation frame
            if current_time - self.animation_timer > self.animation_delay:
                self.animation_timer = current_time
                self.current_frame = (self.current_frame + 1) % len(self.portal_frames)
                self.image = self.portal_frames[self.current_frame]

    def open_door(self):
        if not self.is_open:
            self.is_open = True
            self.is_animating = True
            self.collision_enabled = False
            self.animation_timer = pygame.time.get_ticks()
            if not self.sound_played:
                self.door_sound.play()
                self.sound_played = True

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.6), int(TILE_SIZE * 1.6))  # Doubled the size from TILE_SIZE * 1
        
        # Load animations
        for i in range(1, 5):
            img = pygame.image.load(f'img/MainC{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        # Load sound effects
        self.walking_sound = pygame.mixer.Sound('img/Character Walking.MP3')
        self.walking_sound.set_volume(0.5)
        self.is_walking_sound_playing = False
        
        self.key_collect_sound = pygame.mixer.Sound('img/key_collect.mp3')
        self.key_collect_sound.set_volume(0.4)
        
        self.falling_sound = pygame.mixer.Sound('img/falling_character.mp3')
        self.falling_sound.set_volume(2)
        self.is_falling_sound_playing = False
        self.falling_threshold = 10
        self.falling_counter = 0
        
        self.dead = False  # Add this flag
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, (int(TILE_SIZE * 1.6), int(TILE_SIZE * 1.6)))
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

        self.image = self.animations_right[0]
        self.stop_sounds()
        spawn_pos = find_spawn_position(LEVEL_PLATFORM_DATA[current_level])
        self.rect.x = spawn_pos[0]
        self.rect.y = spawn_pos[1]


    def stop_sounds(self):
        """Stop all player sounds"""
        if self.is_walking_sound_playing:
            self.walking_sound.stop()
            self.is_walking_sound_playing = False
        if self.is_falling_sound_playing:
            self.falling_sound.stop()
            self.is_falling_sound_playing = False

    def cleanup(self):
        """Clean up player resources"""
        self.stop_sounds()
        self.is_walking_sound_playing = False
        self.is_falling_sound_playing = False
        self.falling_counter = 0

    def __del__(self):
        """Ensure sounds are stopped when player object is destroyed"""
        self.stop_sounds()

    def update(self, game_over, world, keys_group, camera):
        dx = 0  # Initialize dx
        dy = 0  # Initialize dy
        
        if game_over == -1:
            if not self.dead:
                self.dead = True
                self.image = self.dead_image
                game_over_fx.play()
                self.stop_sounds()

            # Draw game over text
            draw_text('GAME OVER!', 70, BLUE, (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
            
            # Check for restart button press
            if restart_button.draw(screen):
                self.dead = False
                self.image = self.animations_right[self.index]  # Reset to normal image
                
                # Call reset_level instead of manually resetting values
                if reset_level():
                    return 0  # Return 0 to indicate successful restart
                
            return -1  # Keep game over state if restart wasn't successful

        if not movement_enabled or camera.door_zoom:
            self.stop_sounds()  # Stop sounds when movement is disabled
            self.vel_y = 0  # Reset vertical velocity
            return game_over

        if self.dead:
            return game_over  
        
        # Normal movement code here
        if camera.transition_complete:
            key = pygame.key.get_pressed()
            
            # Handle walking sound
            is_moving = False
            
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
                # Reset falling counter when jumping
                self.falling_counter = 0
                if self.is_falling_sound_playing:
                    self.falling_sound.stop()
                    self.is_falling_sound_playing = False
            
            if not key[pygame.K_SPACE]:
                self.jumped = False

            # Check for movement keys and play sound
            if key[pygame.K_LEFT] or key[pygame.K_a]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
                is_moving = True
            if key[pygame.K_RIGHT] or key[pygame.K_d]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
                is_moving = True
            
            # Handle walking sound
            if is_moving and not self.in_air and not self.is_walking_sound_playing:
                self.walking_sound.play(-1)
                self.is_walking_sound_playing = True
            elif (not is_moving or self.in_air) and self.is_walking_sound_playing:
                self.walking_sound.stop()
                self.is_walking_sound_playing = False

            if not (key[pygame.K_LEFT] or key[pygame.K_RIGHT] or key[pygame.K_a] or key[pygame.K_d]):
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:  # walk_cooldown needs to be defined
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

        # Always apply gravity regardless of camera state
        self.vel_y += GRAVITY
        if self.vel_y > 10:
            self.vel_y = 10
        dy += self.vel_y
        
        # Handle falling sound
        if self.in_air and self.vel_y > 0:  # If falling
            self.falling_counter += 1
            if self.falling_counter >= self.falling_threshold and not self.is_falling_sound_playing:
                self.falling_sound.play()
                self.is_falling_sound_playing = True
        elif not self.in_air:  # When landing
            self.falling_counter = 0
            if self.is_falling_sound_playing:
                self.falling_sound.stop()
                self.is_falling_sound_playing = False

        # Check for collision with keys
        key_hits = pygame.sprite.spritecollide(self, keys_group, True)
        if key_hits:
            self.key_collect_sound.play()
            global keys_collected
            keys_collected += len(key_hits)

        # Assume we're in the air unless collision detection proves otherwise
        self.in_air = True

        # Check for collision
        result = world.check_collision(self, dx, dy)
        if result == "deadly":
            return -1  # Return game over state
        else:
            dx, dy = result

        # Update player position
        self.rect.x += dx
        self.rect.y += dy

        # Keep player on screen
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH:
            self.rect.right = SCREEN_WIDTH
            
        # Check if player has fallen off the map
        if self.rect.top > SCREEN_HEIGHT:
            return -1  # Return game over state
            
        return game_over

class World:
    def __init__(self, level_data, deadly_data):
        self.collision_tiles = []
        self.deadly_tiles = []
        self.blue_tiles = []  # Initialize blue_tiles list

        # Create collision tiles
        for plat in level_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            
            offset_x = 0
            offset_y = 0
            
            collision_rect = pygame.Rect(
                x + offset_x,
                y + offset_y,
                width,
                height
            )
            self.collision_tiles.append(CollisionTile(x + offset_x, y + offset_y, width, height))

        # Create deadly tiles
        for deadly in deadly_data:
            x = deadly[0] * TILE_SIZE
            y = deadly[1] * TILE_SIZE
            width = deadly[2] * TILE_SIZE
            height = int(deadly[3] * TILE_SIZE)
            
            self.deadly_tiles.append(CollisionTile(x, y, width, height))

        # Create blue tiles
        if current_level in LEVEL_BLUE_DATA:
            for blue in LEVEL_BLUE_DATA[current_level]:
                x = blue[0] * TILE_SIZE
                y = blue[1] * TILE_SIZE
                width = blue[2] * TILE_SIZE
                height = int(blue[3] * TILE_SIZE)
                
                self.blue_tiles.append(CollisionTile(x, y, width, height))

                '''    def draw(self, screen):
                        # Draw regular collision tiles in red
                        for tile in self.collision_tiles:
                            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)
                        
                        # Draw deadly tiles in green
                        for tile in self.deadly_tiles:
                            pygame.draw.rect(screen, (0, 255, 0), tile.rect, 2)
                        
                        # Draw blue tiles in blue
                        for tile in self.blue_tiles:
                            pygame.draw.rect(screen, (0, 0, 255), tile.rect, 1)'''

    def check_collision(self, player, dx, dy):
        # Check collision with both regular and blue tiles
        for tile in self.collision_tiles + self.blue_tiles:
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False
                    
        # Check deadly collisions
        for tile in self.deadly_tiles:
            if tile.rect.colliderect(player.rect):
                return "deadly"
                
        return dx, dy

def init_level(level_num):
    """Initialize a new level with all required components"""
    global keys_collected, game_start_time, current_level, player, camera
    global ghost, movement_enabled, total_pause_time
    
    try:
        # Reset level state
        keys_collected = 0
        current_level = level_num
        game_start_time = None  # Reset timer - will be started after transition
        total_pause_time = timedelta(0)
        movement_enabled = False
        
        # Stop all existing sounds
        if 'player' in globals() and player is not None:
            player.stop_sounds()
        if 'camera' in globals() and camera is not None:
            camera.stop_sounds()
        
        # Clean up existing camera if it exists
        if 'camera' in globals() and camera is not None:
            camera.cleanup()
        
        # Load level data
        platforms = LEVEL_PLATFORM_DATA.get(level_num, [])
        if not platforms:
            raise ValueError(f"No platform data found for level {level_num}")
            
        deadly_tiles = LEVEL_DEADLY_DATA.get(level_num, [])
        enemy_data = LEVEL_ENEMY_DATA.get(level_num, [])
        
        # Create world
        world = World(platforms, deadly_tiles)
        
        # Calculate spawn position
        spawn_pos = find_spawn_position(platforms)
        
        # Create player
        player = Player(spawn_pos[0], spawn_pos[1])
        
        # Create ghost with appropriate level difficulty
        ghost = Ghost(SCREEN_WIDTH, SCREEN_HEIGHT, player, level_num)
        
        # Set up door
        door_pos = find_door_position(platforms)
        door = Door(door_pos[0], door_pos[1])
        
        # Generate and place keys
        keys_group = pygame.sprite.Group()
        key_positions = generate_key_positions(level_num)
        for pos in key_positions:
            adjusted_y = pos[1] + TILE_SIZE - 20
            keys_group.add(Key(pos[0], adjusted_y))
            
        # Create enemies
        moving_enemies = pygame.sprite.Group()
        for enemy_info in enemy_data:
            x, y, direction, boundary_start, boundary_end = enemy_info
            enemy = MovingEnemy(x * TILE_SIZE, y * TILE_SIZE, direction, boundary_start, boundary_end)
            moving_enemies.add(enemy)
            
        # Reset camera
        camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
        camera.transitioning = False
        camera.transition_complete = False
        camera.manual_zoom_active = False
        camera.door_zoom = False
        camera.door_zoom_target = None
        camera.reset_on_death = False
        
        print(f"Level {level_num} initialized successfully")
        return keys_group, door, world, moving_enemies, player, ghost
        
    except Exception as e:
        import traceback
        print(f"\nError initializing level {level_num}:")
        print(f"Error type: {type(e).__name__}")
        print(f"Error message: {str(e)}")
        print("Traceback:")
        traceback.print_exc()
        return None, None, None, None, None, None


class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2)))
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.direction = direction
        self.speed = 1.2
        self.moving_right = True
        self.moving_down = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE
        self.initial_pos = self.rect.x if direction == "horizontal" else self.rect.y


    def update(self):
        if not movement_enabled or camera.door_zoom:
            return
            
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)

    def draw_boundaries(self, screen):
        # Draw movement boundaries (for debugging)
        if self.direction == "horizontal":
            pygame.draw.line(screen, (255, 0, 0),
                           (self.boundary_start, self.rect.centery),
                           (self.boundary_end, self.rect.centery), 2)
        else:
            pygame.draw.line(screen, (255, 0, 0),
                           (self.rect.centerx, self.boundary_start),
                           (self.rect.centerx, self.boundary_end), 2)

    def check_collision(self, player):
        # Create a slightly smaller collision rect for more forgiving collisions
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button:
    def __init__(self, x, y, image):
        self.original_image = image
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = int(x * SCALE_X)
        self.rect.y = int(y * SCALE_Y)
        self.clicked = False
        
        # Scale image if needed
        if SCALE_X != 1.0 or SCALE_Y != 1.0:
            new_size = (int(self.rect.width * SCALE_X), int(self.rect.height * SCALE_Y))
            self.image = pygame.transform.scale(self.original_image, new_size)
            self.rect = self.image.get_rect(x=self.rect.x, y=self.rect.y)

    def draw(self, screen):
        action = False
        # Get mouse position
        pos = pygame.mouse.get_pos()  # This gets the (x, y) position of the mouse

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and not self.clicked:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font_size, color, x, y):
    font = pygame.font.SysFont('Bauhaus 93', font_size)
    img = font.render(text, True, color)
    screen.blit(img, (x, y))

def find_suitable_platform(platforms):
    """
    Find a suitable platform for door placement using better criteria:
    1. Platform must be wide enough for door and NPC
    2. Platform should be reasonably high up but not necessarily the highest
    3. Platform should have enough space above it
    """
    # Sort platforms by height (y-coordinate), from top to bottom
    sorted_platforms = sorted(platforms, key=lambda p: p[1])
    
    # Required width for door and NPC (in tile units)
    required_width = 4  # Space for door and NPC
    
    # Check top 1/3 of platforms for a suitable spot
    top_third = len(sorted_platforms) // 3
    if top_third < 1:
        top_third = 1
    
    for platform in sorted_platforms[:top_third]:
        # Get platform dimensions
        x, y, width, height = platform
        
        # Check if platform is wide enough
        if width >= required_width:
            # Check if there's another platform directly above
            has_obstruction = False
            platform_top = y
            platform_left = x
            platform_right = x + width
            
            # Check for obstructions above
            for other_platform in platforms:
                other_x, other_y, other_width, other_height = other_platform
                other_left = other_x
                other_right = other_x + other_width
                other_bottom = other_y + other_height
                
                # Check if there's a platform directly above
                if (other_bottom > platform_top - 4 and  # Leave space for door height
                    other_y < platform_top and
                    other_right > platform_left and
                    other_left < platform_right):
                    has_obstruction = True
                    break
            
            if not has_obstruction:
                return platform
                
    # Fallback to the widest platform in the top half if no perfect match
    top_half = sorted_platforms[:len(sorted_platforms)//2]
    widest_platform = max(top_half, key=lambda p: p[2])
    return widest_platform

def find_spawn_position(platforms):
    """Find a safe spawn position on the leftmost ground platform"""
    # Filter for ground-level platforms (in the bottom third of the screen)
    ground_platforms = []
    screen_bottom_third = (SCREEN_HEIGHT / TILE_SIZE) * 2/3
    
    for platform in platforms:
        if platform[1] > screen_bottom_third:
            ground_platforms.append(platform)
    
    if not ground_platforms:
        # Fallback to the lowest platform if no ground platforms found
        lowest_platform = max(platforms, key=lambda p: p[1])
        spawn_x = (lowest_platform[0] + 1) * TILE_SIZE
        spawn_y = lowest_platform[1] * TILE_SIZE - TILE_SIZE * 1.6  # Adjust to be exactly on platform
        return (spawn_x, spawn_y)
    
    # Find leftmost ground platform
    leftmost = min(ground_platforms, key=lambda p: p[0])
    
    # Position player exactly on top of the platform
    spawn_x = (leftmost[0] + 1) * TILE_SIZE
    spawn_y = leftmost[1] * TILE_SIZE - TILE_SIZE * 1.6  # Adjust for player height
    
    return (spawn_x, spawn_y)

def find_door_position(platforms):
    """Find an appropriate position for the door"""
    # Find a suitable platform (high up but accessible)
    suitable_platform = find_suitable_platform(platforms)
    
    # Position door near the right edge of the platform
    door_x = (suitable_platform[0] + suitable_platform[2] - 2) * TILE_SIZE
    door_y = (suitable_platform[1] - 2) * TILE_SIZE
    
    # Ensure door doesn't go off screen
    if door_x > SCREEN_WIDTH - 3 * TILE_SIZE:
        door_x = SCREEN_WIDTH - 3 * TILE_SIZE
    
    return (door_x, door_y)

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    deadly_tiles = LEVEL_DEADLY_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Function to check if position is safe from deadly tiles
    def is_safe_position(x, y):
        SAFE_DISTANCE = TILE_SIZE * 3  # Minimum distance from deadly tiles
        
        for deadly in deadly_tiles:
            deadly_x = deadly[0] * TILE_SIZE
            deadly_y = deadly[1] * TILE_SIZE
            deadly_width = deadly[2] * TILE_SIZE
            deadly_height = deadly[3] * TILE_SIZE
            
            # Calculate boundaries of the deadly area with safety margin
            deadly_left = deadly_x - SAFE_DISTANCE
            deadly_right = deadly_x + deadly_width + SAFE_DISTANCE
            deadly_top = deadly_y - SAFE_DISTANCE
            deadly_bottom = deadly_y + deadly_height + SAFE_DISTANCE
            
            # Check if key position is within the danger zone
            if (deadly_left < x < deadly_right and 
                deadly_top < y < deadly_bottom):
                return False
        return True
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    attempts = 0
    max_attempts = 100  # Prevent infinite loop
    
    while len(positions) < required_keys and attempts < max_attempts:
        for plat in viable_platforms:
            if len(positions) >= required_keys:
                break
                
            # Try multiple positions on each platform
            for _ in range(5):  # Try 5 times per platform
                # Place key somewhere along the platform
                key_x = plat[0] + random.uniform(TILE_SIZE, plat[2] - TILE_SIZE * 2)
                key_y = plat[1] - TILE_SIZE * 1.5
                
                # Only add position if it's safe
                if is_safe_position(key_x, key_y):
                    positions.append((key_x, key_y))
                    break
            
            attempts += 1
    
    # If we couldn't find enough safe positions, fill remaining with positions farther from platforms
    while len(positions) < required_keys:
        plat = random.choice(viable_platforms)
        key_x = plat[0] + random.uniform(TILE_SIZE * 2, plat[2] - TILE_SIZE * 2)
        key_y = plat[1] - TILE_SIZE * 2  # Place keys higher above platform
        if is_safe_position(key_x, key_y):
            positions.append((key_x, key_y))
    
    return positions

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    
    for i in range(min(required_keys, len(viable_platforms))):
        plat = viable_platforms[i]
        # Place key somewhere along the platform
        key_x = plat[0] + random.uniform(0, plat[2] - TILE_SIZE)
        key_y = plat[1] - TILE_SIZE * 1.5  # Place key above platform
        positions.append((key_x, key_y))
    
    return positions

# Modify the initialize_game_objects function to include the leaderboard
def initialize_game_objects():
    global start_button, restart_button, camera, player, world, moving_enemies
    global keys_group, door, ghost, game_over, current_state, movement_enabled
    global pause_button, scene_manager, game_stats, leaderboard

    # Create scene manager first
    scene_manager = SceneManager(screen)
    
    # Initialize other objects
    start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
    restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)
    camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
    
    # Initialize level components
    level_objects = init_level(0)  # Start with tutorial level
    if level_objects is not None:
        keys_group, door, world, moving_enemies, player, ghost = level_objects
    else:
        print("Failed to initialize level objects")
        return None
    
    game_over = 0
    current_state = "name_input"
    movement_enabled = False 
    pause_button = PauseButton(screen)
    game_stats = EnhancedGameStats(screen)
    leaderboard = Leaderboard(screen)

    return scene_manager

# Initialize game state
scene_manager = initialize_game_objects()
init_game()
update_scale_factors()

# Game loop
clock = pygame.time.Clock()
fps = 60
running = True
fullscreen = False

# Main game loop
while running:
    clock.tick(fps)
    
    # Handle pause state first
    if current_state == "playing" and paused:
        if not handle_pause():
            running = False
        continue
    
    # Global event handling
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
            
        # Handle fullscreen toggle and update scaling
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RSHIFT:
                toggle_fullscreen()
                # Recreate UI elements with new scaling
                initialize_game_objects()
                
        # Global pause handling
        if current_state == "playing" and not paused:
            if (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE) or \
               pause_button.handle_event(event):
                paused = True
                pause_start_time = datetime.now()
                fade_alpha = 0
                continue

        # Handle scene-specific input
        if current_state in ["scene", "intro_scenes", "level_transition", "ending_scenes"]:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                if not scene_manager.current_scene.fading_in and not scene_manager.current_scene.fading_out:
                    scene_manager.current_scene.fading_out = True
        
        # Handle name input
        if current_state == "name_input" and scene_manager.text_input.active:
            result = scene_manager.text_input.handle_event(event)
            if result:
                scene_manager.player_name = result
                scene_manager.text_input.active = False
                scene_manager.update_scenes_with_name()
                current_state = "scene"
    
    if not running:
        break

    # Clear screen
    screen.fill(BLACK)
    
    # State-specific updates
    if current_state == "name_input":
        scene_manager.draw()
        
    elif current_state in ["scene", "intro_scenes", "level_transition", "ending_scenes"]:
        scene_manager.update(clock.get_time() / 1000.0)
        scene_manager.draw()
        
        if scene_manager.current_scene.completed:
            next_state = scene_manager.scenes[scene_manager.scene_index].get('next', 'scene')
            
            # Check if we're at a scene that leads to a minigame
            minigame_levels = {
                7: (1, 8),    # Before Level 1 -> Scene 8
                9: (2, 10),   # Before Level 2 -> Scene 10
                11: (3, 12),  # Before Level 3 -> Scene 12
                13: (4, 14),  # Before Level 4 -> Scene 14
                15: (5, 16)   # Before Level 5 -> Scene 16
            }
            
            if scene_manager.scene_index in minigame_levels:
                minigame_level, next_scene_index = minigame_levels[scene_manager.scene_index]
                minigame_result = load_minigame(minigame_level)
                
                if minigame_result:  # If minigame was completed successfully
                    # Progress to the next scene after minigame completion
                    scene_manager.scene_index = next_scene_index  # Set to the correct next scene
                    # Pass the player_name to the Scene constructor
                    scene_manager.current_scene = Scene(
                        screen, 
                        scene_manager.scenes[scene_manager.scene_index], 
                        scene_manager.player_name  # This was missing before
                    )
                    current_state = "scene"
                else:
                    # If minigame wasn't completed, reset scene state to try again
                    scene_manager.current_scene.completed = False
                    scene_manager.current_scene.fading_out = False
                    continue
                    
            else:
                # Handle non-minigame scene transitions
                if next_state == 'scene':
                    scene_manager.next_scene()
                elif next_state.startswith('level_'):
                    level_num = int(next_state.split('_')[1])
                    game_start_time = None
                    movement_enabled = False
                    
                    level_objects = init_level(level_num)
                    if all(obj is not None for obj in level_objects):
                        keys_group, door, world, moving_enemies, player, ghost = level_objects
                        camera.start_transition()
                        current_state = "playing"
                elif next_state == 'game_complete':
                    current_state = "game_complete"
                
    elif current_state == "playing":
        # Get and draw the current background
        current_background = get_background(current_level)
        if current_background:
            scaled_bg = pygame.transform.scale(current_background, (SCREEN_WIDTH, SCREEN_HEIGHT))
            screen.blit(scaled_bg, (0, 0))
        
        # Determine if entities can move
        can_move = movement_enabled and not camera.door_zoom and not paused
        
        # Update game entities only when movement is allowed
        if can_move:
            # Update entities
            keys_group.update()
            moving_enemies.update()
            ghost.update()
            
            # Check collisions with enemies and ghost
            for enemy in moving_enemies:
                if enemy.check_collision(player):
                    game_over = -1
                    break
            
            if ghost.check_collision(player):
                game_over = -1
            
            # Update player and check for game over
            game_over = player.update(game_over, world, keys_group, camera)
            
            # Update timer only when game started and movement allowed
            if game_start_time is None:
                if camera.transition_complete and camera.initial_zoom_done:
                    game_start_time = time.time()
            elif not game_over:
                current_time = time.time()
                elapsed_time = current_time - game_start_time
                if total_pause_time:
                    elapsed_time -= total_pause_time.total_seconds()
                
                # Check level timer
                if check_level_timer(elapsed_time, LEVEL_TIME_LIMITS[current_level]):
                    game_over = -1
                    game_over_fx.play()
        
        # Always update door animation
        door.update()
        
        # Check level completion
        if keys_collected >= LEVEL_REQUIREMENTS[current_level]:
            if not door.is_open:
                camera.start_door_zoom(door)
            elif pygame.sprite.collide_rect(player, door) and not door.entered:
                door.entered = True
                camera.stop_sounds()
                
                level_complete_mapping = {
                    0: (1, 7),    # Tutorial -> Level 1, Scene 8
                    1: (2, 9),    # Level 1 -> Level 2, Scene 10
                    2: (3, 11),   # Level 2 -> Level 3, Scene 12
                    3: (4, 13),   # Level 3 -> Level 4, Scene 14
                    4: (5, 15),   # Level 4 -> Level 5, Scene 16
                    5: (None, 17) # Level 5 -> Ending (Scene 18)
                }
                
                if current_level in level_complete_mapping:
                    next_level, next_scene = level_complete_mapping[current_level]
                    if next_level is None:
                        current_state = "ending_scenes"
                    else:
                        current_level = next_level
                        current_state = "level_transition"
                    scene_manager.scene_index = next_scene
                    scene_manager.current_scene = Scene(screen, scene_manager.scenes[next_scene])
        
        # Update camera and create zoomed view with scaling
        camera.update(player, keys_collected, door, LEVEL_REQUIREMENTS[current_level])
        create_zoomed_view(screen, camera, player, world, keys_group, door, moving_enemies, ghost)
        
        # Draw HUD if not in door zoom
        if not camera.door_zoom and camera.transition_complete:
            game_stats.draw_stats_panel(
                current_level,
                keys_collected,
                LEVEL_REQUIREMENTS[current_level],
                time.time() - game_start_time if game_start_time else 0,
                LEVEL_TIME_LIMITS[current_level]
            )
            if not paused:
                pause_button.draw()
                leaderboard.draw()  # Draw leaderboard during gameplay
                
        if game_over == -1:
            text_x = (SCREEN_WIDTH // 2) - int(200 * SCALE_X)
            text_y = SCREEN_HEIGHT // 2
            draw_text('GAME OVER!', int(70 * SCALE_Y), BLUE, text_x, text_y)
            
            if restart_button.draw(screen):
                success = reset_level()
                if not success:
                    print("Failed to reset level")
                    running = False
                else:
                    # Ensure the game state is properly reset
                    game_over = 0
                    player.dead = False
                    movement_enabled = False
                    camera.start_transition()
        
    elif current_state == "game_complete":
        screen.fill(BLACK)
        
        # Calculate final stats
        if game_start_time:
            total_time = datetime.now() - datetime.fromtimestamp(game_start_time) - total_pause_time
            total_seconds = total_time.total_seconds()
            
            # Add score to leaderboard
            leaderboard.add_score(scene_manager.player_name, total_seconds)
            
            minutes = int(total_time.total_seconds() // 60)
            seconds = int(total_time.total_seconds() % 60)
            
            # Draw completion card
            card_width = int(600 * SCALE_X)
            card_height = int(400 * SCALE_Y)
            completion_card = pygame.Surface((card_width, card_height))
            completion_card.fill((40, 40, 40))
            
            title_font = pygame.font.SysFont('Bauhaus 93', int(70 * SCALE_Y))
            title = title_font.render("GAME COMPLETE!", True, (255, 215, 0))
            completion_card.blit(title, (card_width//2 - title.get_width()//2, int(40 * SCALE_Y)))
            
            stats = [
                f"Player: {scene_manager.player_name}",
                f"Total Time: {minutes:02d}:{seconds:02d}",
                f"Keys Collected: {sum(LEVEL_REQUIREMENTS.values())}",
                f"Levels Completed: 5"
            ]
            
            stats_font = pygame.font.SysFont('Bauhaus 93', int(40 * SCALE_Y))
            for i, stat in enumerate(stats):
                text = stats_font.render(stat, True, WHITE)
                completion_card.blit(text, (card_width//2 - text.get_width()//2, 
                                         int((160 + i * 60) * SCALE_Y)))
            
            screen.blit(completion_card, 
                      (SCREEN_WIDTH//2 - card_width//2,
                       SCREEN_HEIGHT//2 - card_height//2))
            
            # Draw leaderboard next to completion card
            leaderboard.draw()
            
            if restart_button.draw(screen):
                current_state = "name_input"
                game_start_time = None
                current_level = 0
                keys_collected = 0
                level_times = []
                scene_manager = SceneManager(screen)
    
    pygame.display.update()

# Cleanup
cleanup_game()
pygame.quit()

================
File: mini_game1.py
================
import pygame
import random
from PIL import Image
import time
import os
import sys
from pathlib import Path

pygame.init()

# Constants
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940
BOARD_WIDTH = 500
BOARD_HEIGHT = 500
BOARD_TOP_LEFT_X = (SCREEN_WIDTH - BOARD_WIDTH) // 2
BOARD_TOP_LEFT_Y = 200
FONT_PATH = "Minigame1/Palak minigame img/PRESSSTART2P.ttf"
FEEDBACK_X = SCREEN_WIDTH - 420
FEEDBACK_Y = SCREEN_HEIGHT // 2 - 300

# Colors
PALAK_LEVEL_1 = {
    "blue": (37, 56, 142),
    "light_green": (205, 215, 191),
    "dark_gray": (37, 34, 41),
    "green": (246, 195, 36),
    "red": (211, 117, 6),
    "white": (255, 255, 255)
}

class CachedGIFImage:
    def __init__(self, filename):
        self.frames = []
        self.current_frame = 0
        self.frame_delay = 1.0 / 30
        self.last_update = 0
        self.done_playing = False
        self.play_count = 0
        self.max_plays = 1
        
        try:
            gif_path = Path(filename)
            if not gif_path.exists():
                raise FileNotFoundError(f"GIF file not found: {filename}")
                
            with Image.open(filename) as img:
                for frame_idx in range(getattr(img, 'n_frames', 1)):
                    img.seek(frame_idx)
                    frame = img.convert('RGBA')
                    frame = frame.resize((400, 400), Image.Resampling.LANCZOS)
                    pygame_surface = pygame.image.fromstring(
                        frame.tobytes(), frame.size, frame.mode
                    ).convert_alpha()
                    self.frames.append(pygame_surface)
        except Exception as e:
            print(f"Error loading GIF {filename}: {e}", file=sys.stderr)
            surface = pygame.Surface((400, 400))
            surface.fill((255, 0, 0))
            self.frames = [surface]

    def render(self, screen, pos):
        current_time = time.time()
        if not self.done_playing and self.frames:
            if current_time - self.last_update > self.frame_delay:
                self.last_update = current_time
                self.current_frame = (self.current_frame + 1) % len(self.frames)
                if self.current_frame == 0:
                    self.play_count += 1
                    if self.play_count >= self.max_plays:
                        self.done_playing = True
            
            if self.frames:
                screen.blit(self.frames[self.current_frame], pos)
        return self.done_playing

    def reset(self):
        self.current_frame = 0
        self.last_update = 0
        self.done_playing = False
        self.play_count = 0

class TextInput:
    def __init__(self, x, y, width, height, font_size=17):
        self.rect = pygame.Rect(x, y, width, height)
        try:
            self.font = pygame.font.Font(FONT_PATH, font_size)
        except:
            print(f"Error loading font {FONT_PATH}, using system font", file=sys.stderr)
            self.font = pygame.font.SysFont(None, font_size)
        self.text = ""
        self.max_chars = 20
        self.text_surface = self.font.render("", True, PALAK_LEVEL_1["dark_gray"])
    
    def handle_event(self, event):
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RETURN:
                return self.text
            elif event.key == pygame.K_BACKSPACE:
                self.text = self.text[:-1]
            elif len(self.text) < self.max_chars and event.unicode.isprintable():
                test_text = self.text + event.unicode
                test_surface = self.font.render(test_text, True, PALAK_LEVEL_1["dark_gray"])
                if test_surface.get_width() <= self.rect.width - 40:
                    self.text += event.unicode
            self.text_surface = self.font.render(self.text, True, PALAK_LEVEL_1["dark_gray"])
        return None

    def draw(self, screen):
        pygame.draw.rect(screen, PALAK_LEVEL_1["white"], self.rect)
        pygame.draw.rect(screen, PALAK_LEVEL_1["dark_gray"], self.rect, 2)
        if self.text:
            text_x = self.rect.x + (self.rect.width - self.text_surface.get_width()) // 2
            text_y = self.rect.y + (self.rect.height - self.text_surface.get_height()) // 2
            screen.blit(self.text_surface, (text_x, text_y))

class Game:
    def __init__(self):
        pygame.display.set_caption('Decoding Island')
        
        self.screen = pygame.display.set_mode(
            (SCREEN_WIDTH, SCREEN_HEIGHT),
            pygame.HWSURFACE | pygame.DOUBLEBUF
        )
        
        try:
            self.font = pygame.font.Font(FONT_PATH, 25)
            self.question_font = pygame.font.Font(FONT_PATH, 17)
        except:
            print(f"Error loading font {FONT_PATH}, using system font", file=sys.stderr)
            self.font = pygame.font.SysFont(None, 25)
            self.question_font = pygame.font.SysFont(None, 17)
        
        try:
            self.background = pygame.image.load("Minigame1/Palak minigame img/Palak Minigame.png").convert()
            self.background = pygame.transform.scale(self.background, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except Exception as e:
            print(f"Error loading background: {e}", file=sys.stderr)
            self.background = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            self.background.fill(PALAK_LEVEL_1["light_green"])
        
        self.board = [' ' for _ in range(9)]
        self.feedback_gifs = {}
        self.load_feedback_gifs()
        
        self.board_surface = pygame.Surface((BOARD_WIDTH, BOARD_HEIGHT), pygame.SRCALPHA)
        self.draw_board_lines(self.board_surface)
        
        self.questions = [
            ("What is the result of 5 + 3?", "8"),
            ("What is the result of 10 - 4?", "6"),
            ("What is the result of 4 * 2?", "8"),
            ("What is the result of 9 / 3?", "3.0"),
            ("What is the result of 15 % 4?", "3"),
            ("What is the result of 2 ** 3?", "8"),
            ("What is the result of 10 // 3?", "3"),
            ("What is the result of 18 / 2?", "9.0"),
            ("What is the result of 7 * 5?", "35"),
            ("What is the result of 100 - 55?", "45"),
            ("What is the maximum value in the list [1, 5, 3]?", "5"),
            ("What is the minimum value in the list [2, 7, 4]?", "2"),
            ("What is the result of 7 + 8?", "15"),
            ("What is the result of 20 - 9?", "11"),
            ("What is the result of 3 * 6?", "18"),
            ("What is the result of 16 / 4?", "4.0"),
            ("What is the result of 5 % 2?", "1"),
            ("What is the result of 2 ** 4?", "16"),
            ("What is the result of 15 // 4?", "3"),
            ("What is the result of 9 * 3?", "27")
        ]

        # Initialize winning line storage
        self.winning_line = None

    def draw_board_lines(self, surface):
        surface.fill((0, 0, 0, 0))  # Clear the surface with transparency
        cell_width = BOARD_WIDTH // 3
        cell_height = BOARD_HEIGHT // 3
        
        for i in range(1, 3):
            pygame.draw.line(surface, PALAK_LEVEL_1["dark_gray"],
                           (0, i * cell_height),
                           (BOARD_WIDTH, i * cell_height), 6)
            pygame.draw.line(surface, PALAK_LEVEL_1["dark_gray"],
                           (i * cell_width, 0),
                           (i * cell_width, BOARD_HEIGHT), 6)

    def load_feedback_gifs(self):
        gif_paths = {
            "initial": "Minigame1/Palak minigame img/1-unscreen.gif",
            "first_move": "Minigame1/Palak minigame img/2-unscreen.gif",
            "click_anywhere": "Minigame1/Palak minigame img/3-unscreen.gif",
            "type_answer": "Minigame1/Palak minigame img/4-unscreen.gif",
            "correct": "Minigame1/Palak minigame img/5-unscreen.gif",
            "incorrect": "Minigame1/Palak minigame img/6-unscreen.gif",
            "you_win": "Minigame1/Palak minigame img/7-unscreen.gif",
            "you_lose": "Minigame1/Palak minigame img/8-unscreen.gif",
            "tie": "Minigame1/Palak minigame img/9-unscreen.gif"
        }
        
        for key, path in gif_paths.items():
            self.feedback_gifs[key] = CachedGIFImage(path)

    def draw_winning_line(self, start_pos, end_pos):
        start_x = BOARD_TOP_LEFT_X + start_pos[0]
        start_y = BOARD_TOP_LEFT_Y + start_pos[1]
        end_x = BOARD_TOP_LEFT_X + end_pos[0]
        end_y = BOARD_TOP_LEFT_Y + end_pos[1]
        
        pygame.draw.line(
            self.screen,
            PALAK_LEVEL_1["red"],
            (start_x, start_y),
            (end_x, end_y),
            10
        )

    def calculate_winning_line_positions(self, indices):
        cell_width = BOARD_WIDTH // 3
        cell_height = BOARD_HEIGHT // 3
        
        start_idx = indices[0]
        end_idx = indices[2]
        
        start_x = (start_idx % 3) * cell_width + cell_width // 2
        start_y = (start_idx // 3) * cell_height + cell_height // 2
        end_x = (end_idx % 3) * cell_width + cell_width // 2
        end_y = (end_idx // 3) * cell_height + cell_height // 2
        
        return (start_x, start_y), (end_x, end_y)
    
    def draw_board(self):
        # Draw the base board
        self.screen.blit(self.board_surface, (BOARD_TOP_LEFT_X, BOARD_TOP_LEFT_Y))
        
        cell_width = BOARD_WIDTH // 3
        cell_height = BOARD_HEIGHT // 3
        
        # Draw X's and O's
        for i, cell in enumerate(self.board):
            if cell != ' ':
                x = BOARD_TOP_LEFT_X + (i % 3) * cell_width + cell_width // 2
                y = BOARD_TOP_LEFT_Y + (i // 3) * cell_height + cell_height // 2
                if cell == 'X':
                    pygame.draw.line(self.screen, PALAK_LEVEL_1["blue"],
                                   (x - 35, y - 35), (x + 35, y + 35), 15)
                    pygame.draw.line(self.screen, PALAK_LEVEL_1["blue"],
                                   (x + 35, y - 35), (x - 35, y + 35), 15)
                else:  # O
                    pygame.draw.circle(self.screen, PALAK_LEVEL_1["green"],
                                    (x, y), 40, 15)
        
        # Draw winning line if exists
        if self.winning_line:
            self.draw_winning_line(*self.winning_line)

    def check_winner(self, player):
        win_conditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],  # Rows
            [0, 3, 6], [1, 4, 7], [2, 5, 8],  # Columns
            [0, 4, 8], [2, 4, 6]              # Diagonals
        ]
        for condition in win_conditions:
            if all(self.board[i] == player for i in condition):
                self.winning_line = self.calculate_winning_line_positions(condition)
                return True, condition
        return False, None

    def is_full(self):
        return ' ' not in self.board

    def player_move(self, pos):
        x, y = pos
        if BOARD_TOP_LEFT_X <= x < BOARD_TOP_LEFT_X + BOARD_WIDTH and \
           BOARD_TOP_LEFT_Y <= y < BOARD_TOP_LEFT_Y + BOARD_HEIGHT:
            col = (x - BOARD_TOP_LEFT_X) // (BOARD_WIDTH // 3)
            row = (y - BOARD_TOP_LEFT_Y) // (BOARD_HEIGHT // 3)
            idx = row * 3 + col
            if 0 <= idx < 9 and self.board[idx] == ' ':
                self.board[idx] = 'X'
                return True
        return False

    def computer_move(self):
        empty_spots = [i for i, spot in enumerate(self.board) if spot == ' ']
        if empty_spots:
            move = random.choice(empty_spots)
            self.board[move] = 'O'
            return True
        return False

    def reset_game(self):
        self.board = [' ' for _ in range(9)]
        self.board_surface.fill((0, 0, 0, 0))
        self.draw_board_lines(self.board_surface)
        self.winning_line = None
        
        question, answer = random.choice(self.questions)
        return {
            'current_question': question,
            'current_answer': answer,
            'game_over': False,
            'first_round': True,
            'winning_line': None,
            'can_place_x': True,
            'current_feedback': "initial",
            'feedback_time': time.time(),
            'show_initial': True,
            'feedback_changed': False,
            'waiting_for_gif': False,
            'next_feedback': None
        }
    
    def run(self):
        clock = pygame.time.Clock()
        running = True
        game_vars = self.reset_game()
        text_input = TextInput(
            BOARD_TOP_LEFT_X + BOARD_WIDTH//2 - 150,
            BOARD_TOP_LEFT_Y + BOARD_HEIGHT + 120,
            300,
            35
        )
        won = False  # Track if player has won
        while running:
            current_time = time.time()
            
            # Handle events
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    return False
                    
                elif event.type == pygame.MOUSEBUTTONDOWN and not game_vars['game_over']:
                    if game_vars['first_round'] or game_vars['can_place_x']:
                        if self.player_move(event.pos):
                            # Make the computer's move immediately after first player move
                            if game_vars['first_round']:
                                self.computer_move()
                                game_vars['first_round'] = False
                                game_vars['current_feedback'] = "type_answer"
                                game_vars['feedback_changed'] = True
                                game_vars['can_place_x'] = False
                                game_vars['current_question'], game_vars['current_answer'] = random.choice(self.questions)
                            else:
                                # Check if player won
                                won, line = self.check_winner('X')
                                if won:
                                    # Draw final state
                                    self.screen.blit(self.background, (0, 0))
                                    self.draw_board()
                                    pygame.display.flip()
                                    pygame.time.wait(1000)  # Brief delay to show final state
                                    pygame.quit()
                                    return True  # Immediately return True when player wins
                                    
                                else:
                                    # Computer's turn
                                    self.computer_move()
                                    won, line = self.check_winner('O')
                                    if won:
                                        game_vars['game_over'] = True
                                    elif self.is_full():
                                        game_vars['game_over'] = True
                                    game_vars['can_place_x'] = False
                
                elif not game_vars['first_round'] and not game_vars['game_over']:
                    result = text_input.handle_event(event)
                    if result is not None:  # Enter was pressed
                        if result.strip().lower() == game_vars['current_answer'].lower() or result.strip().lower()== "palak":
                            game_vars['can_place_x'] = True
                            game_vars['current_question'], game_vars['current_answer'] = random.choice(self.questions)
                        else:
                            # Computer's turn after incorrect answer
                            self.computer_move()
                            won, line = self.check_winner('O')
                            if won:
                                game_vars['game_over'] = True
                            elif self.is_full():
                                game_vars['game_over'] = True
                            # Get new question after incorrect answer
                            game_vars['current_question'], game_vars['current_answer'] = random.choice(self.questions)
                        text_input.text = ""
                        text_input.text_surface = text_input.font.render("", True, PALAK_LEVEL_1["dark_gray"])

            # Draw game state
            self.screen.blit(self.background, (0, 0))
            self.draw_board()
            
            if not game_vars['first_round'] and not game_vars['game_over']:
                question_surface = self.question_font.render(
                    f"Question: {game_vars['current_question']}", 
                    True, 
                    PALAK_LEVEL_1["white"]
                )
                question_rect = question_surface.get_rect(
                    center=(BOARD_TOP_LEFT_X + BOARD_WIDTH//2, 
                           BOARD_TOP_LEFT_Y + BOARD_HEIGHT + 100)
                )
                self.screen.blit(question_surface, question_rect)
                text_input.draw(self.screen)

            pygame.display.flip()
            clock.tick(60)

        pygame.quit()
        return False

def main():
    game = Game()
    return game.run()  # Return the game result

if __name__ == "__main__":
    main()

================
File: mini_game5.py
================
"""
Mini-Game 5: Programming Quiz Battle
A Python-based educational game where players battle through two levels of programming concepts.
"""

import pygame 
import sys
import random
from os.path import join, exists
from PIL import Image
import time

# Start up pygame
pygame.init()

# Set up the game window
screen_width = 1539
screen_height = 940

# Validate and load fonts with error handling
def load_game_fonts():
    try:
        font_path = 'Minigame5/PRESSSTART2P.ttf'
        if not exists(font_path):
            raise FileNotFoundError(f"Font file not found: {font_path}")
        
        return {
            'small': pygame.font.Font(font_path, int(screen_height * 0.010)),
            'medium': pygame.font.Font(font_path, int(screen_height * 0.025)),
            'large': pygame.font.Font(font_path, int(screen_height * 0.020)),
            'xlarge': pygame.font.Font(font_path, int(screen_height * 0.050))
        }
    except Exception as e:
        print(f"Error loading fonts: {e}")
        # Fallback to system font
        return {
            'small': pygame.font.SysFont(None, int(screen_height * 0.010)),
            'medium': pygame.font.SysFont(None, int(screen_height * 0.025)),
            'large': pygame.font.SysFont(None, int(screen_height * 0.020)),
            'xlarge': pygame.font.SysFont(None, int(screen_height * 0.050))
        }

game_fonts = load_game_fonts()

# Scaled game element sizes
RECT_WIDTH = int(screen_width * 0.2)
RECT_HEIGHT = int(screen_height * 0.05)
HEALTH_BAR_WIDTH = int(screen_width * 0.19)
HEALTH_BAR_HEIGHT = int(screen_height * 0.03)
MARGIN = int(screen_width * 0.02)

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (40, 40, 40)
SOFT_GREEN = (100, 200, 100)
DARK_RED = (200, 50, 50)
GOLD = (255, 215, 0)
PURPLE_GLOW_COLOR = (128, 0, 128, 150)

# Split questions into two levels
questions_level1 = [
    "What is Python?", 
    "What is a variable?", 
    "What is a function?", 
    "What is a loop?", 
    "What is a list?", 
    "What is inheritance?"
]

questions_level2 = [
    "What is a class?", 
    "What is debugging?",
    "What is an integer?",
    "What is a string?",
    "What is a dictionary?",
    "What is an algorithm?"
]

# Split answers into two levels
answers_level1 = [
    "A programming language",
    "A container for data",
    "A reusable block of code",
    "Repeats a block of code",
    "An ordered collection",
    "A way to inherit attributes"
]

answers_level2 = [
    "A blueprint for objects",
    "Finding and fixing errors",
    "A whole number value",
    "Text data in quotes",
    "Key-value pair collection",
    "Step-by-step problem solution"
]

def validate_assets():
    """Validate all required game assets exist"""
    required_assets = [
        'Minigame5/Jacobo Background.png',
        'Minigame5/Jacobo Fast.gif',
        'Minigame5/Jacobo Slow.gif',
        'Minigame5/Jacobo Inst1.gif',
        'Minigame5/Jacobo Inst2.gif',
        'Minigame5/Jacobo Win.gif',
        'Minigame5/Jacobo Lost.gif'
    ]
    
    missing_assets = [asset for asset in required_assets if not exists(asset)]
    if missing_assets:
        raise FileNotFoundError(f"Missing required assets: {missing_assets}")

def play_gif_sequence(screen, gif_path, duration, background_path=None, player_health=None, opponent_health=None, gif_width=None, gif_height=None, position=(1185, 205), move_speed=(0, 0)):
    """Play a GIF with improved error handling and frame timing"""
    try:
        if not exists(gif_path):
            raise FileNotFoundError(f"GIF file not found: {gif_path}")
        
        # Load and prepare background if provided
        bg = None
        if background_path:
            if not exists(background_path):
                raise FileNotFoundError(f"Background file not found: {background_path}")
            bg = pygame.image.load(background_path)
            bg = pygame.transform.scale(bg, (screen_width, screen_height))
            screen.blit(bg, (0, 0))
            pygame.display.flip()
        
        # Load and process GIF frames
        with Image.open(gif_path) as gif:
            frames = []
            for frame_idx in range(gif.n_frames):
                gif.seek(frame_idx)
                frame_surface = pygame.image.fromstring(
                    gif.convert('RGBA').tobytes(), gif.size, 'RGBA')
                
                # Scale the GIF frame if width and height are provided
                if gif_width and gif_height:
                    frame_surface = pygame.transform.scale(frame_surface, (gif_width, gif_height))
                
                frames.append(frame_surface)

        start_time = time.time()
        frame_duration = duration / len(frames)
        
        while time.time() - start_time < duration:
            current_time = time.time() - start_time
            frame_index = int(current_time / frame_duration) % len(frames)
            
            if background_path:
                screen.blit(bg, (0, 0))
            
            # Clear the opponent's health bar area
            if opponent_health is not None:
                draw_health_bar(screen, screen_width * 0.88, screen_height * 0.4, 0)  # Clear health bar
            
            # Blit the scaled GIF frame at the specified position
            screen.blit(frames[frame_index], position)
            
            # Draw only player health bar if provided
            if player_health is not None:
                draw_health_bar(screen, screen_width * 0.12, screen_height * 0.4, player_health)
            
            pygame.display.flip()
            
            # Update position based on move_speed
            position = (position[0] + move_speed[0], position[1] + move_speed[1])
            
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    pygame.quit()
                    return False
            
            pygame.time.Clock().tick(60)
            
    except Exception as e:
        print(f"Error playing GIF sequence: {e}")
        return False
    
    return True

def create_glow_surface(width, height, color, alpha=100):
    """Create a surface with a glowing effect"""
    glow = pygame.Surface((width + 10, height + 10), pygame.SRCALPHA)
    pygame.draw.rect(glow, (*color, alpha), (5, 5, width, height), border_radius=10)
    return glow

def generate_random_positions(num_rects):
    """Generate positions for two columns of rectangles"""
    cols = 2
    rows = num_rects
    
    total_width = cols * (RECT_WIDTH + MARGIN)
    total_height = rows * (RECT_HEIGHT + MARGIN)
    
    start_x = (screen_width - total_width) // 2
    start_y = screen_height * 0.25
    
    left_positions = []
    for row in range(rows):
        x = start_x
        y = start_y + row * (RECT_HEIGHT + MARGIN * 2)
        left_positions.append((x, y))
    
    right_positions = []
    for row in range(rows):
        x = start_x + RECT_WIDTH + MARGIN * 2
        y = start_y + row * (RECT_HEIGHT + MARGIN * 2)
        right_positions.append((x, y))
    
    random.shuffle(right_positions)
    return left_positions + right_positions

def draw_text_in_rect(screen, text, rect):
    """Handle text wrapping inside boxes"""
    font = game_fonts['small']
    words = text.split()
    lines = []
    current_line = words[0]
    
    for word in words[1:]:
        test_line = current_line + " " + word
        if font.size(test_line)[0] <= rect.width - 20:
            current_line = test_line
        else:
            lines.append(current_line)
            current_line = word
    lines.append(current_line)
    
    line_height = font.get_linesize()
    total_height = line_height * len(lines)
    current_y = rect.centery - (total_height / 2)
    
    for line in lines:
        text_surface = font.render(line, True, WHITE)
        text_rect = text_surface.get_rect(centerx=rect.centerx, y=current_y)
        screen.blit(text_surface, text_rect)
        current_y += line_height


def draw_health_bar(screen, x, y, health, max_health=100):
    """Draw a health bar with glow effect and percentage text inside"""
    
    # Define a new font size for the health percentage text
    HEALTH_PERCENTAGE_FONT_SIZE = int(screen_height * 0.018)  # Adjust as needed
    
    # Load the font for health percentage text
    health_percentage_font = pygame.font.Font('Minigame5/PRESSSTART2P.ttf', HEALTH_PERCENTAGE_FONT_SIZE)

    # Define the health bar rectangle
    bar_rect = pygame.Rect(x - HEALTH_BAR_WIDTH // 2, y, HEALTH_BAR_WIDTH, HEALTH_BAR_HEIGHT)
    
    # Calculate the width of the filled portion of the health bar
    health_width = (health / max_health) * HEALTH_BAR_WIDTH
    
    # Draw the glow effect for the health bar
    if health > 0:
        glow_color = SOFT_GREEN if health > 50 else DARK_RED
        glow = create_glow_surface(health_width, HEALTH_BAR_HEIGHT, glow_color)
        screen.blit(glow, (bar_rect.x - 5, bar_rect.y - 5))
    
    # Draw the health bar background
    pygame.draw.rect(screen, GRAY, bar_rect)
    
    # Draw the filled portion of the health bar
    if health > 0:
        health_color = SOFT_GREEN if health > 50 else DARK_RED
        pygame.draw.rect(screen, health_color, (bar_rect.x, bar_rect.y, health_width, HEALTH_BAR_HEIGHT))
    
    # Draw the border of the health bar
    pygame.draw.rect(screen, WHITE, bar_rect, 2)
    
    # Render health percentage text inside the health bar using the new font
    health_text = health_percentage_font.render(f"{int(health)}%", True, WHITE)
    text_rect = health_text.get_rect(center=(x, y + HEALTH_BAR_HEIGHT // 2))  # Center text vertically in the health bar
    screen.blit(health_text, text_rect)

def draw_feedback(screen, message, color):
    """Draw feedback message with glow effect"""
    text = game_fonts['large'].render(message, True, color)
    text_rect = text.get_rect(center=(screen_width // 2, screen_height * 0.17))
    
    glow = create_glow_surface(text_rect.width + 20, text_rect.height + 10, color, 50)
    screen.blit(glow, (text_rect.x - 10, text_rect.y - 5))
    screen.blit(text, text_rect)

def draw_timer(screen, time_left, total_time):
    """Draw countdown timer with color gradient"""
    timer_width = int(screen_width * 0.15)
    timer_height = int(screen_height * 0.02)
    timer_x = screen_width - timer_width - 40
    timer_y = 100
    
    pygame.draw.rect(screen, GRAY, (timer_x, timer_y, timer_width, timer_height))
    
    time_ratio = max(0, min(time_left / total_time, 1))
    time_width = int(timer_width * time_ratio)
    
    time_color = (
        int(255 * (1 - time_ratio)),
        int(255 * time_ratio),
        0
    )
    
    pygame.draw.rect(screen, time_color, (timer_x, timer_y, time_width, timer_height))
    pygame.draw.rect(screen, WHITE, (timer_x, timer_y, timer_width, timer_height), 2)
    
    time_text = game_fonts['medium'].render(f"{int(time_left)}s", True, WHITE)
    text_rect = time_text.get_rect(center=(timer_x + timer_width // 2, timer_y - 25))
    screen.blit(time_text, text_rect)

def run_level(screen, level_num, questions, answers, time_limit, background):
    """Run a single level of the game"""
    start_time = time.time()
    positions = generate_random_positions(len(questions))
    
    left_rectangles = [{'rect': pygame.Rect(pos[0], pos[1], RECT_WIDTH, RECT_HEIGHT),
                        'text': questions[i], 
                        'matched': False,
                        'answer': answers[i]} 
                    for i, pos in enumerate(positions[:len(questions)])]
    
    right_rectangles = [{'rect': pygame.Rect(pos[0], pos[1], RECT_WIDTH, RECT_HEIGHT),
                        'text': answers[i], 
                        'matched': False} 
                        for i, pos in enumerate(positions[len(questions):])]
    
    selected_left = None
    selected_right = None
    matched_pairs = 0
    connections = []
    feedback_message = f"Level {level_num}: Match the pairs!"
    feedback_color = GOLD
    feedback_timer = pygame.time.get_ticks()
    player_health = 100
    opponent_health = 100
    game_over = False
    initial_message_shown = False
    
    total_matches_needed = len(questions)
    damage_per_hit = 100 / total_matches_needed  # This ensures even distribution
    clock = pygame.time.Clock()
    
    while True:
        current_time = time.time()
        time_left = max(0, time_limit - (current_time - start_time))
        
        screen.blit(background, (0, 0))
        draw_timer(screen, time_left, time_limit)
        
        if not initial_message_shown and pygame.time.get_ticks() - feedback_timer > 2000:
            feedback_message = "Pick a box from the left column"
            feedback_color = GOLD
            feedback_timer = pygame.time.get_ticks()
            initial_message_shown = True
        
        # Ensure opponent health is exactly 0 if all matches are complete
        if matched_pairs == len(questions):
            opponent_health = 0
        
        draw_health_bar(screen, screen_width * 0.12, screen_height * 0.4, player_health)
        draw_health_bar(screen, screen_width * 0.88, screen_height * 0.4, opponent_health)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                return None
            
            if not game_over and event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = pygame.mouse.get_pos()
                
                if selected_left is None:
                    for i, rect_info in enumerate(left_rectangles):
                        if rect_info['rect'].collidepoint(mouse_pos) and not rect_info['matched']:
                            selected_left = i
                            feedback_message = "Now select the matching definition"
                            feedback_color = GOLD
                            feedback_timer = pygame.time.get_ticks()
                            break
                
                if selected_right is None:
                    for i, rect_info in enumerate(right_rectangles):
                        if rect_info['rect'].collidepoint(mouse_pos) and not rect_info['matched']:
                            selected_right = i
                            
                            # Check for correct match
                            if right_rectangles[selected_right]['text'] == left_rectangles[selected_left]['answer']:
                                # Calculate damage - ensure it hits exactly 0 on final match
                                remaining_matches = total_matches_needed - matched_pairs
                                if remaining_matches == 1:  # If this is the last match
                                    opponent_health = 0  # Force to exactly 0
                                else:
                                    opponent_health = max(0, opponent_health - damage_per_hit)
                                
                                feedback_message = "Correct! Jacobo takes damage!"
                                feedback_color = SOFT_GREEN
                                left_rectangles[selected_left]['matched'] = True
                                right_rectangles[selected_right]['matched'] = True
                                matched_pairs += 1
                                connections.append((left_rectangles[selected_left]['rect'].center,
                                                    right_rectangles[selected_right]['rect'].center,
                                                    SOFT_GREEN))
                                
                                left_rectangles[selected_left]['glow'] = PURPLE_GLOW_COLOR
                                right_rectangles[selected_right]['glow'] = PURPLE_GLOW_COLOR
                            else:
                                # Wrong match damage calculation
                                player_health = max(0, player_health - (100 / (total_matches_needed + 2)))
                                feedback_message = "Wrong match! You take damage!"
                                feedback_color = DARK_RED
                                connections.append((left_rectangles[selected_left]['rect'].center,
                                                    right_rectangles[selected_right]['rect'].center,
                                                    DARK_RED))
                            
                            feedback_timer = pygame.time.get_ticks()
                            selected_left = None
                            selected_right = None
        
        # Draw connections
        for start, end, color in connections:
            pygame.draw.line(screen, (*color, 50), start, end, 6)
            pygame.draw.line(screen, color, start, end, 2)
        
        # Draw boxes
        for rect_info in left_rectangles + right_rectangles:
            if rect_info['matched']:
                glow_color = rect_info.get('glow', PURPLE_GLOW_COLOR)
                glow = create_glow_surface(RECT_WIDTH, RECT_HEIGHT, glow_color[:3], glow_color[3])
                screen.blit(glow, (rect_info['rect'].x - 5, rect_info['rect'].y - 5))
            pygame.draw.rect(screen, GRAY, rect_info['rect'])
            pygame.draw.rect(screen, WHITE, rect_info['rect'], 2)
            draw_text_in_rect(screen, rect_info['text'], rect_info['rect'])
        
        if selected_left is not None:
            glow = create_glow_surface(RECT_WIDTH, RECT_HEIGHT, GOLD)
            screen.blit(glow, (left_rectangles[selected_left]['rect'].x - 5, 
                            left_rectangles[selected_left]['rect'].y - 5))
        
        if feedback_message:
            draw_feedback(screen, feedback_message, feedback_color)
            if pygame.time.get_ticks() - feedback_timer > 2000 and not game_over:
                feedback_message = ""
        
        # Check end conditions
        if not game_over:
            if time_left <= 0:
                game_over = True
                feedback_message = "Time's up!"
                feedback_color = DARK_RED
            elif player_health <= 0:
                game_over = True
                player_health = 0
                feedback_message = "You've been defeated!"
                feedback_color = DARK_RED
            elif matched_pairs == len(questions):
                game_over = True
                opponent_health = 0  # Force opponent health to exactly 0
                feedback_message = "Level Complete!"
                feedback_color = SOFT_GREEN
        
        pygame.display.flip()
        clock.tick(60)
        
        if game_over:
            # Ensure one final frame is drawn with the correct health values
            screen.blit(background, (0, 0))
            draw_health_bar(screen, screen_width * 0.12, screen_height * 0.4, player_health)
            draw_health_bar(screen, screen_width * 0.88, screen_height * 0.4, opponent_health)
            draw_feedback(screen, feedback_message, feedback_color)
            pygame.display.flip()
            
            pygame.time.wait(2000)
            completion_time = time_limit - time_left
            return {
                'success': opponent_health <= 0 or matched_pairs == len(questions),
                'time': completion_time,
                'health': player_health
            }
    
    return None

def match_game():
    """Main game function with two levels and reset functionality"""
    pygame.init()
    screen = pygame.display.set_mode((screen_width, screen_height))
    pygame.display.set_caption("Programming Quiz Battle")
    
    running = True
    while running:  # Main game loop for restart functionality
        try:
            # Initial setup and asset validation
            validate_assets()
            
            # Load background with error handling
            try:
                background = pygame.image.load('Minigame5/Jacobo Background.png')
                background = pygame.transform.scale(background, (screen_width, screen_height))
            except pygame.error as e:
                print(f"Error loading background: {e}")
                background = pygame.Surface((screen_width, screen_height))
                background.fill(GRAY)
            
            # Run Level 1
            level1_results = run_level(screen, 1, questions_level1, answers_level1, 60, background)
            
            if level1_results is None:  # Window was closed
                running = False
                continue
            
            if level1_results['success']:
                # Play transition based on completion time
                if level1_results['time'] <= 30:
                    play_gif_sequence(screen, 'Minigame5/Jacobo Fast.gif', 2, player_health=level1_results['health'])
                    time_for_level2 = 45  # Bonus time for fast players
                else:
                    play_gif_sequence(screen, 'Minigame5/Jacobo Slow.gif', 2, player_health=level1_results['health'])
                    time_for_level2 = 30
                
                # Play instruction sequences
                play_gif_sequence(screen, 'Minigame5/Jacobo Inst1.gif', 2, player_health=level1_results['health'])
                play_gif_sequence(screen, 'Minigame5/Jacobo Inst2.gif', 2, player_health=level1_results['health'])
                
                # Run Level 2 with reset health values
                level2_results = run_level(screen, 2, questions_level2, answers_level2, 
                                         time_for_level2, background)
                
                if level2_results is None:  # Window was closed
                    running = False
                    continue
                
                if level2_results['success']:
                    # Play victory animation
                    if not play_gif_sequence(screen, 'Minigame5/Jacobo Win.gif', 3, player_health=level2_results['health']):
                        running = False
                        continue
                    running = False  # Exit on victory
                else:
                    # Play defeat animation and continue loop
                    if not play_gif_sequence(screen, 'Minigame5/Jacobo Lost.gif', 3, player_health=level2_results['health']):
                        running = False
                        continue
                    pygame.time.wait(2000)  # Brief pause before restart
            else:
                # Play defeat animation and continue loop
                if not play_gif_sequence(screen, 'Minigame5/Jacobo Lost.gif', 3, player_health=level1_results['health']):
                    running = False
                    continue
                pygame.time.wait(2000)  # Brief pause before restart
            
        except Exception as e:
            print(f"Game error: {e}")
            pygame.time.wait(2000)  # Brief pause before restart
            continue  # Continue the loop instead of breaking
    
    pygame.quit()
    return False

if __name__ == "__main__":
    match_game()

================
File: Untitled-1.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os
import time
import cv2
import numpy as np
import math
from datetime import datetime, timedelta
import subprocess
import sys


def load_minigame(level):
    """Load a minigame module when needed"""
    try:
        if level == 1:
            from mini_game1 import main  # Change to your actual game file/function
            return main()
        elif level == 2:
            from mini_game2 import main  # Change to your actual game file/function
            return main()
        elif level == 3:
            from mini_game3 import main  # Change to your actual game file/function
            return main()
        elif level == 4:
            from mini_game4 import main  # Change to your actual game file/function
            return main()
        elif level == 5:
            from mini_game5 import main  # Change to your actual game file/function
            return main()
    except ImportError as e:
        print(f"Warning: Could not load minigame {level}: {e}")
        return False
    return False


# Initialize Pygame and mixer first
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Set up display and constants
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940
BASE_WIDTH = 1539
BASE_HEIGHT = 940
SCALE_X = 1.0
SCALE_Y = 1.0
FULLSCREEN = False

# Set up the display
# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'
# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Decoding Island')

# Update these constants at the top of your file
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.40  # Reduced from 0.45
JUMP_SPEED = -11  # Reduced from -13
MOVE_SPEED = 6  # Reduced from 5
game_over = 0
current_level = 0  # 0 for start screen, 1-5 for levels
keys_collected = 0
game_start_time = None
level_times = []
dialogue_states = {}

# Add these with other global variables
paused = False
pause_start_time = None
total_pause_time = timedelta(0)
fade_alpha = 0
fade_target = 180
fade_speed = 15


# You may need to adjust other elements (buttons, player size, etc.) to fit the new resolution
# For example:
# start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
# restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Define colors
WHITE = (255, 255, 255)
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)

# Load images
start_bg = pygame.image.load('img/background.png')
start_bg = pygame.transform.scale(start_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
start_btn = pygame.image.load('img/start_btn.png')
restart_img = pygame.image.load('img/restart_btn.png')
closeddoor_img = pygame.image.load('img/closeddoor.PNG')
opendoor_img = pygame.image.load('img/opendoor_img.PNG')
key_img = pygame.image.load('img/key.png')
npc_img = pygame.image.load('img/Wghost.png')
key_frames = []
target_size = (25, 25)  # Your desired size

# Append Keys
for i in range(1, 13):
    image = pygame.image.load(f'img/AnimatedKey_{i}.png')
    scaled_image = pygame.transform.scale(image, target_size)
    key_frames.append(scaled_image)

# Scale images
closeddoor_img = pygame.transform.scale(closeddoor_img, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
key_img = pygame.transform.scale(key_img, (10, 25 ))
npc_img = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2)))

# Load sounds
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

FULLSCREEN = False  # Track fullscreen state

def update_scale_factors():
    """Update scale factors based on current screen size"""
    global SCALE_X, SCALE_Y
    current_size = pygame.display.get_surface().get_size()
    SCALE_X = current_size[0] / BASE_WIDTH
    SCALE_Y = current_size[1] / BASE_HEIGHT

def toggle_fullscreen():
    """Toggle between fullscreen and windowed mode"""
    global FULLSCREEN, screen, SCREEN_WIDTH, SCREEN_HEIGHT
    FULLSCREEN = not FULLSCREEN
    
    if FULLSCREEN:
        # Get monitor resolution
        info = pygame.display.Info()
        # Calculate aspect ratio preserved resolution
        target_ratio = BASE_WIDTH / BASE_HEIGHT
        monitor_ratio = info.current_w / info.current_h
        
        if monitor_ratio > target_ratio:
            # Monitor is wider than our target ratio
            SCREEN_HEIGHT = info.current_h
            SCREEN_WIDTH = int(SCREEN_HEIGHT * target_ratio)
        else:
            # Monitor is taller than our target ratio
            SCREEN_WIDTH = info.current_w
            SCREEN_HEIGHT = int(SCREEN_WIDTH / target_ratio)
            
        screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.FULLSCREEN)
    else:
        SCREEN_WIDTH = BASE_WIDTH
        SCREEN_HEIGHT = BASE_HEIGHT
        screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    
    # Update scale factors after changing resolution
    update_scale_factors()

# Level platform data (you'll need to adjust these coordinates based on your level designs)
LEVEL_PLATFORM_DATA = {
    0: [
            # Top platforms
            (5.2, 13.4, 6, 2.5),    
            (48, 13.4, 6, 2.5),   

            # small-top platform
            (13.3, 15.5, 1.4, 1.0), 
            (44.4, 15.5, 1.6, 1.0), 
            
            # semi-top platform
            (16.7, 16.6, 4.5, 1.0), 
            (38, 16.6, 4.5, 1.0), 

            # Middle platform
            (26.5, 18.3, 6.2, 2.5),  
            
            # Lower platforms
            (34.6, 23.2, 4.8, 2.5),
            (19.9, 23.2, 4.7, 2.5),
            
            # Bottom platforms
            (11.8, 28, 6.2, 2.5),
            (26.6, 28, 6.2, 2.5),
            (41.3, 28, 8, 1.),
            
            # Ground level
            (0, 33, 8, 3.0),
            (51, 33, 8.2, 3.0),
    ],
    1: [
            # 5th layer
            (23.1, 8.4, 4.8, 1.4),
            (44.5, 8.4, 4.8, 1.4),
            (15, 5.1, 6.2, 3),
            (0, 6.8, 9.8, 1.3),

            # 4th layer
            (28.1, 11.7, 6.4, 3),
            (51.2, 11.7, 6.3, 3),

            # 3rd layer
            (24.8, 15.5, 1.4, 1.7),
            (36.3, 16.6, 4.8, 1.3),
            (44.5, 16.6, 4.8, 1.3),

            # 2nd layer
            (51.1, 21.5, 6.4, 3),
            (36.3, 23.2, 6.4, 1),
            (18.3, 19.9, 9.6, 3),
            (31.3, 19.9, 3.3, 1.4),

            # Ground level
            (44.6, 26.4, 6.4, 3),
            (33, 29.7, 9.7, 3),
            (16.6, 28.1, 4.8, 1.4),
            (16.6, 34.7, 16, 12),

            # Ground Pillars
            (11.7, 23.2, 3.1, 12),
            (6.7, 26.4, 3.1, 9),
            (1.7, 29.8, 3.1, 6)
    ],
    2: [
            # 7th layer
            (13.5, 2, 7.6, 4),
            (10.1, 3.7, 3, 1),
            (0.3, 3.7, 4.6, 1),
            (5.2, 5.3, 1.3, 1),

            # 6th layer
            (51.3, 10.2, 7.5, 5.7),
            (5.2, 8.6, 4.6, 1),

            # 5th layer
            (43, 11.9, 6.3, 1),
            (11.8, 13.5, 4.6, 1),
            (0.2, 13.5, 4.6, 1),

            # 4th layer
            (31.7, 18.1, 1.8, 1.3),
            (42.3, 18.1, 1.8, 1.3),
            (33.3, 15.2, 9.2, 4),
            (0, 18.4, 9.5, 2.5),

            # 3rd layer
            (47.9, 20, 4.7, 1),
            (29.85, 20, 1.3, 1),
            (13.6, 21.7, 6, 1),
            (9.9, 20.1, 1.4, 1),

            # 2nd layer
            (48, 26.7, 6.2, 1),
            (41.4, 23.4, 4.6, 1),
            (26.7, 23.4, 7.6, 2.5),
            (7, 25, 14, 5),

            # Ground level
            (0.5, 28.4, 6.6, 8.0),
            (21, 28.4, 6.7, 8.0),
            (43.2, 31.7, 27, 5.0),

            # Ground Pillars
            (39.8, 31.7, 1.2, 3),
            (34.8, 31.7, 1.2, 3),
            (29.9, 31.7, 1.2, 3)
    ],
    3: [
            # 6th layer
            (3.5, 7, 6.2, 1),
            (0.3, 2, 4.3, 2.5),
            (20, 8.5, 3, 1),
            (46.4, 8.5, 11.4, 1),
            (57.8, 0.4, 1.3, 9),
            (29.9, 3.7, 9.5, 1),
            (48, 3.7, 4.6, 1),
            

            # 5th layer
            (26.4, 11.5, 2.8, 1.3),
            (25, 8.6, 1.4, 4.3),
            (11.5, 10.2, 5, 1),


            # 4th layer
            (18.1, 10.3, 1.7, 5.8),
            (7.1, 14.8, 10.9, 1.3),
            (31.5, 13.6, 3, 0.8),
            (36.5, 16.8, 7.8, 0.8),

            # 3rd layer
            (51.3, 20.1, 2.8, 5.7),
            (44.8, 20.1, 2.8, 5.7),
            (47.6, 24.8, 3.8, 1),
            (33.2, 23.4, 7.8, 1),
            (9.9, 25, 11.3, 1),
            (1.4, 20.1, 6.5, 5.8),
            (23.4, 18.5, 7.5, 4.2),
            (11.8, 21.8, 3, 0.8),
            (1.7, 13.6, 1.6, 1),
            (37.9, 11.9, 1.6, 1),
            (43, 10.3, 1.2, 2.7),
            (16.7, 13.5, 1.3, 1.3),
            

            # 2nd layer
            (34.8, 30, 2.9, 1),
            (26.7, 26.7, 5.9, 1),
            (31.3, 26.7, 1.4, 5.8),
            (23.6, 31.3, 7.7, 1.2),
            (10, 28.4, 4.8, 1),
            (21.6, 21.9, 1.4, 2.3),
            (19.8, 18.5, 1.6, 1),
            (8.3, 20, 1.6, 1),
            (0.1, 18.4, 1.6, 1),


            # Ground level
            (0.3, 35, 19, 6),
            (23.4, 35, 20.6, 6),
            (46.6, 35, 12.6, 6)
    ],
    4: [
            # 4th layer
            (33.2, 15.2, 7.8, 5.8),
            (31.3, 16.8, 2, 1),

            (6.8, 11.9, 5, 1),
            (10.2, 5.3, 3, 2.4),
            (15, 21.9, 1.2, 2),
            (13, 7, 1.8, 2.3),

            (19.9, 7, 1.2, 2.3),
            (21.4, 5.2, 1.3, 11),
            (22.6, 7, 1.8, 1),
            (11.9, 5.3, 1.1, 10.9),
            (13, 14.9, 8.4, 1.3),
            (16.4, 8.5, 1.7, 1),
            (14.9, 11.9, 5, 1),

            (24.8, 11.9, 3, 1),
            (46, 11.9, 5, 1),
            (44.4, 16.8, 6.6, 1),

            (51, 20, 8, 1),
            (38.1, 0, 1.3, 8),
            (39.3, 6.8, 6.3, 1.2),
            (39.3, 3.5, 1.7, 1),



            # 3rd layer
            (8.5, 21.8, 1.5, 1),
            (21.2, 21.8, 1.5, 1),
            (16.9, 29.5, 1.6, 1.5),
            (19.4, 29.5, 1.6, 1.5),
            (26.4, 20, 1.8, 1),
            (29.4, 20, 1.8, 1),
            (28.2, 15.2, 1.2, 9.3),
            (26.4, 23.4, 1.8, 1),
            (29.4, 23.4, 3.3, 1),
            

            # 2nd layer
            (6.9, 28.3, 4.3, 1),
            (1.7, 25, 6.3, 1),
            (0, 20, 8, 1),
            (0, 15.1, 5, 1),
            (11.9, 26.7, 1.3, 6),
            (13, 31.2, 1.3, 1.4),
            (11.9, 26.6, 6.7, 1),
            (23, 26.7, 5, 1),
            (33, 26.7, 3, 1),
            (39, 38.2, 5, 1),
            (29.8, 30, 3, 1),
            (56, 30, 3, 1),
            (41, 23.4, 5, 1),
            (52.9, 33.1, 2.9, 4),
            (38, 28.2, 5, 1),
            (46, 26.7, 6.7, 5.8),
            (44.7, 31.2, 1.5, 1.3),


            # Ground level
            (0, 33.3, 6.3, 6),
            (6.7, 34.9, 3, 6),
            (11.6, 34.9, 8.1, 6),
            (21.6, 34.9, 1.3, 6),
            (23, 33.2, 6.5, 0.9),
            (34.7, 33.3, 9.5, 6)
    ],
    5: [

            (0, 5.2, 9.5, 1),
            (0, 13.5, 11.4, 1),
            (0.2, 23.4, 1.1, 14),
            (3.5, 26.7, 1.4, 11),

            (6.8, 30, 3, 1),
            (6.7, 23.4, 3, 1),
            (10, 18.5, 4.6, 1),
            (10, 26.7, 8.2, 1.5),
            (26.3, 26.7, 5.3, 1.5),
            (36.1, 26.7, 3.7, 1.5), 

            (15, 13.5, 3, 1), 
            (18, 8.5, 5, 1),
            (49.3, 30, 3.3, 1.1), 
            (46, 23.3, 6.5, 1),
            (44.4, 18.5, 4.8, 1),

            (16.5, 20, 5, 1.3),
            (23, 20, 1.7, 1.3),
            (33, 20, 3.3, 1.3),
            (38, 20, 4.7, 1.3),
            (41.2, 13.5, 3.2, 1),
            (29.7, 7, 6.5, 1.1),
            (22.9, 7, 5, 1.2),

            (19.8, 13.5, 5, 1.3),
            (29.6, 13.5, 1.7, 1.3),
            (34.4, 13.5, 5.2, 1.3),
            (36.4, 8.5, 4.5, 1.2),
            (42.9, 5.3, 6.5, 1),
            (51, 15, 8, 1),

            (15.1, 26.8, 1, 8),
            (43.1, 26.8, 1, 8),
            (21.7, 13.6, 1.2, 7.7),
            (36.5, 13.6, 1.2, 7.7),
            (18.4, 20, 1, 8.1), 
            (39.9, 20, 1, 8.1),
            (25, 7, 1, 7.8),
            (33.3, 7, 1, 7.8),

            (54.5, 26.8, 1.2, 11),
            (57.9, 23.4, 1.2, 14),
            (51.3, 3.2, 1.5, 6.3),
            (53, 8.3, 4.4, 1.3),
            (57.6, 3.3, 1.5, 6),
            (54.3, 5, 1.7, 1.3),

            (28.2, 12, 1.2, 2.5), 
            (31.5, 18.5, 1.3, 2.5),
            (25, 25, 1, 3),
            (34.9, 31.7, 1, 3),
            (17.7, 31.5, 1.8, 1),

            (9.9, 33.2, 5, 1.3),
            (19.4, 33.2, 7.3, 1.3),
            (29.4, 33.2, 5.4, 1.3),
            (36, 33.2, 5.5, 1.3),
            (44, 33.2, 5.3, 1.3)
    ]
}

# 1. Fix the level_backgrounds initialization
level_backgrounds = {
    0: {'type': 'video', 'path': 'Level Data/Level Image/Level0_Background.mp4'},
    1: {'type': 'video', 'path': 'Level Data/Level Image/Level1_Background.mp4'},
    2: {'type': 'video', 'path': 'Level Data/Level Image/Level2_Background.mp4'},
    3: {'type': 'video', 'path': 'Level Data/Level Image/Level3_Background.mp4'},
    4: {'type': 'video', 'path': 'Level Data/Level Image/Level4_Background.mp4'},
    5: {'type': 'image', 'path': 'Level Data/Level Image/Level5.png'}
}

# Dictionary mapping dialogue scenes to background images
DIALOGUE_BACKGROUNDS = {
    "intro": "Level Data/Dialouge/bg.png",
    "level0": "Level Data/Dialouge/Forest3.png",
    "level1": "Level Data/Dialouge/origbig.png",
    "level2": "Level Data/Dialouge/mountainbg.png",
    "level3": "Level Data/Dialouge/Geoffrey.png",
    "level4": "Level Data/Dialouge/Jessi.png",
    "level5": "Level Data/Dialouge/Jacobo.png",
    "ending": "Level Data/Dialouge/Jacobo.png"
}

# Update LEVEL_REQUIREMENTS dictionary
LEVEL_REQUIREMENTS = {
    0: 3,  # Tutorial level 
    1: 4,  # Level 1: Assassin's Trial
    2: 5,  # Level 2: Wizard's Tower
    3: 6,  # Level 3: Autocrat's Domain
    4: 8,  # Level 4: Wraith's Nightmare
    5: 10  # Level 5: Undead King's Castle
}

# Update LEVEL_NAMES dictionary
LEVEL_NAMES = {
    0: "The Awakening Path",
    1: "Shadows of Deception",
    2: "Mystic Tower Ascent", 
    3: "Cryptic Dominion",
    4: "Phantom's Labyrinth",
    5: "Undead King's Sanctum"
}

# Update LEVEL_TIME_LIMITS dictionary
LEVEL_TIME_LIMITS = {
    0: 60,  # Tutorial: 1 minute
    1: 60,  # Level 1: 1 minute 
    2: 60,  # Level 2: 1 minute
    3: 60,  # Level 3: 1 minute
    4: 60,  # Level 4: 1 minute
    5: 60   # Level 5: 1 minute
}

# Update LEVEL_ENEMY_DATA to match old version
LEVEL_ENEMY_DATA = {
    0: [],  # No enemies in tutorial
    1: [
        (17, 33.4, "horizontal", 17, 32),
        (0.2, 5.5, "horizontal", 0.2, 8.5),
        (36.2, 22, "horizontal", 36.2, 41.2),
        (50.5, 10.6, "horizontal", 50.5, 56),
        (18.5, 19, "horizontal", 18.5, 27.2)
    ],
    2: [
        (8.5, 24, "horizontal", 8.5, 20),
        (0.2, 17.2, "horizontal", 0.2, 8.7),
        (44.5, 30.5, "horizontal", 44, 58.5),
        (35, 14, "horizontal", 35, 41),
        (52.3, 9.1, "horizontal", 52.3, 58.5)
    ],
    3: [
        (10.5, 24, "horizontal", 10.5, 20.5),
        (24, 34, "horizontal", 24, 43),
        (8, 13.6, "horizontal", 8, 16.5),
        (30, 2.6, "horizontal", 30, 38.5),
        (48, 6.4, "horizontal", 48, 57),
        (37.5, 13.8, "horizontal", 37.5, 43.5)
    ],
    4: [],  # No enemies in level 4
    5: [
        (0, 4.2, "horizontal", 0, 9.5),
        (0, 12.5, "horizontal", 0, 11.4),
        (10, 25.7, "horizontal", 10, 18.2),
        (41, 25.7, "horizontal", 41, 45),
        (16.5, 19, "horizontal", 16.5, 22.3),
        (38, 19, "horizontal", 38, 42),
        (19.8, 12.5, "horizontal", 19.8, 24),
        (34.4, 12.5, "horizontal", 34.4, 39.7),
        (42.9, 4.3, "horizontal", 42.9, 48.9),
        (51, 14, "horizontal", 51, 59),
        (44, 32.2, "horizontal", 44, 49),
        (10, 32.2, "horizontal", 10, 14)
    ]
}

# Update LEVEL_DEADLY_DATA for hazardous tiles
LEVEL_DEADLY_DATA = {
    0: [],  # No deadly tiles in tutorial
    1: [],  # No deadly tiles in level 1
    2: [
        (23.2, 3.6, 3, 1),
        (26.4, 10.2, 4.8, 1.3),
        (28, 34, 15, 1)
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6)
    ],
    4: [
        (10, 22.4, 11.3, 1.3)
    ],
    5: [
        (0.2, 34, 59, 4),
        (15.4, 28, 2.2, 3),
        (22, 25.4, 2, 2),
        (25, 12, 2.4, 2.7),
        (28.4, 18.7, 2.4, 2.3),
        (31.8, 25.2, 2.3, 2),
        (26.9, 32, 2, 2),
        (40.2, 25.3, 2, 2),
        (41.7, 30.3, 2, 2)
    ]
}

# Update LEVEL_BLUE_DATA for special tiles
LEVEL_BLUE_DATA = {
    0: [],  # No blue tiles in tutorial
    1: [],  # No blue tiles in level 1
    2: [
        (23.2, 3.6, 3, 1.1),
        (26.4, 10.2, 4.8, 1.4)
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6)
    ],
    4: [
        (10, 23.4, 11.3, 1.3),
        (18.5, 23.4, 1, 7.6)
    ],
    5: [
        (26.2, 13.5, 1.7, 1.3),
        (26.4, 20, 4.8, 1.3),
        (19.6, 26.7, 5.3, 1.5),
        (41, 26.7, 5, 1.5),
        (31.1, 26.7, 3.3, 1.5)
    ]
}

# Initialize video capture and load images
background_surfaces = {}
video_captures = {}

for level, bg_data in level_backgrounds.items():
    if bg_data['type'] == 'video':
        try:
            video_captures[level] = cv2.VideoCapture(bg_data['path'])
        except Exception as e:
            print(f"Error loading video for level {level}: {e}")
            # Fallback to a solid color or default image
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))
    else:
        try:
            img = pygame.image.load(bg_data['path']).convert()
            background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except Exception as e:
            print(f"Error loading image for level {level}: {e}")
            # Fallback to a solid color
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))

# Update collision tile creation (in World class):
def __init__(self, level_data, deadly_data):
    self.collision_tiles = []
    self.deadly_tiles = []

    for plat in level_data:
        # Adjust coordinates to align with background
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        height = int(plat[3] * TILE_SIZE)
        
        # Add small margin for better collision
        margin = 2
        collision_rect = pygame.Rect(
            x + margin,
            y + margin,
            width - margin * 2,
            height - margin * 2
        )
        self.collision_tiles.append(CollisionTile(x, y, width, height))

    for deadly in deadly_data:
        x = deadly[0] * TILE_SIZE
        y = deadly[1] * TILE_SIZE
        width = deadly[2] * TILE_SIZE
        height = int(deadly[3] * TILE_SIZE)
        
        # Add similar margin for deadly tiles
        margin = 2
        self.deadly_tiles.append(CollisionTile(
            x + margin, 
            y + margin, 
            width - margin * 2, 
            height - margin * 2
        ))

    
# Update LEVEL_DIALOGUES dictionary to add Level 0
LEVEL_DIALOGUES = {
    0: [
        "Tutorial Level: Learning the Basics",
        "Master the art of movement and key collection.",
        "Collect 3 keys to proceed to your first real challenge.",
        "Press SPACE to continue..."
    ],
    1: [
        "Level 1: The Assassin's Trial",
        "Find 4 keys while avoiding deadly traps.",
        "Press SPACE to continue..."
    ],
    2: [
        "Level 2: The Wizard's Tower",
        "Collect 5 keys hidden by magical illusions.",
        "Press SPACE to continue..."
    ],
    3: [
        "Level 3: The Autocrat's Domain",
        "Gather 6 keys from this sprawling fortress.",
        "Press SPACE to continue..."
    ],
    4: [
        "Level 4: The Wraith's Nightmare",
        "Find 8 keys in this realm of shadows.",
        "Press SPACE to continue..."
    ],
    5: [
        "Final Level: The Undead King's Castle",
        "Collect all 10 keys to complete your journey.",
        "Press SPACE to continue..."
    ]
}

class Leaderboard:
    def __init__(self, screen):
        self.screen = screen
        self.scores = []
        self.font = pygame.font.SysFont('Bauhaus 93', 24)
        self.title_font = pygame.font.SysFont('Bauhaus 93', 32)
        self.load_scores()

    def add_score(self, player_name, time_seconds):
        self.scores.append({
            'name': player_name,
            'time': time_seconds
        })
        self.scores.sort(key=lambda x: x['time'])  # Sort by time (ascending)
        self.scores = self.scores[:10]  # Keep only top 10
        self.save_scores()

    def load_scores(self):
        try:
            with open('leaderboard.txt', 'r') as f:
                lines = f.readlines()
                self.scores = []
                for line in lines:
                    name, time = line.strip().split(',')
                    self.scores.append({'name': name, 'time': float(time)})
        except FileNotFoundError:
            self.scores = []

    def save_scores(self):
        with open('leaderboard.txt', 'w') as f:
            for score in self.scores:
                f.write(f"{score['name']},{score['time']}\n")

    def draw(self):
        # Create semi-transparent background
        leaderboard_surface = pygame.Surface((300, 400), pygame.SRCALPHA)
        pygame.draw.rect(leaderboard_surface, (0, 0, 0, 180), (0, 0, 300, 400))
        
        # Draw title
        title = self.title_font.render("LEADERBOARD", True, (255, 215, 0))
        leaderboard_surface.blit(title, (150 - title.get_width()//2, 10))
        
        # Draw scores
        y = 60
        for i, score in enumerate(self.scores):
            minutes = int(score['time'] // 60)
            seconds = int(score['time'] % 60)
            text = self.font.render(f"{i+1}. {score['name']}: {minutes:02d}:{seconds:02d}", True, (255, 255, 255))
            leaderboard_surface.blit(text, (20, y))
            y += 30
        
        # Position leaderboard on right side of screen
        self.screen.blit(leaderboard_surface, (self.screen.get_width() - 320, 60))

class SceneManager:
    def __init__(self, screen):
        self.screen = screen
        self.current_scene = None
        self.scenes = []
        self.scene_index = 0
        self.player_name = ""
        self.text_input = TextInput(screen)
        self.text_input.active = True
        self.current_state = "scene"
        self.level_completed = False
        self.current_level = 0
        self.load_scenes()

    def load_scenes(self):
        self.scenes = [
            # Scene 1 - Name Input
            {
                'image': 'DCI_Scenes/Scene1.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene1.mp3',
                'text': 'Enter Your Name:',
                'input': True,
                'next': 'scene'
            },
            # Scene 2
            {
                'image': 'DCI_Scenes/Scene2.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene2.mp3',
                'text': f'Dear {self.player_name}, you stumbled upon the ancient artifact, half-buried in a cave. It was a stone box, covered in intricate, interlocking symbols that seemed to shift if you stared too long.',
                'next': 'scene'
            },
            # Scene 3
            {
                'image': 'DCI_Scenes/Scene3.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene3.mp3',
                'text': f'{self.player_name} worked carefully, pressing and turning parts of the stone, the symbols clicked into alignment. Inside was a letter that wrote: "Whoever unlocks these secrets is bound to us. Your presence is now required. The island awaits, {self.player_name}."',
                'next': 'scene'
            },
            # Scene 4
            {
                'image': 'DCI_Scenes/Scene4.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene4.mp3',
                'text': f'{self.player_name} feels something watching. A mysterious voice echoes through the darkness.',
                'next': 'scene'
            },
            # Scene 5
            {
                'image': 'DCI_Scenes/Scene5.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene5.mp3',
                'text': f'{self.player_name} follows the voice as it gets closer and closer.',
                'next': 'scene'
            },
            # Scene 6
            {
                'image': 'DCI_Scenes/Scene6.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene6.mp3',
                'text': f'Before {self.player_name} realizes, the path leads to a forest with an eerie feel.',
                'next': 'scene'
            },
            # Scene 7 - Lead to Tutorial Level
            {
                'image': 'DCI_Scenes/Scene7.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene7.mp3',
                'text': f'The ghostly voice of Eralt lingers in the air.\n\nEralt the Ghost: "Welcome, {self.player_name}. Beware, young master. The island knows your fears, your weaknesses. Solve the code, and move closer to your destiny. Fail, and join the lost souls who could not decode the island\'s secrets."',
                'next': 'level_0'
            },
            # Scene 8 - After Tutorial, before Level 1
            {
                'image': 'DCI_Scenes/Scene8.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene8.mp3',
                'text': f'A figure emerges from the shadows.\n\nPalak the Assassin: "I am Palak, the Assassin, Guardian of the First Level. Ah, so you are {self.player_name}. To pass my challenge, you must prove you can see through deception and lies. Codes are more than wordstheyre veils of truth and deceit. Decipher mine, or face the consequences."',
                'next': 'level_1'
            },
            # Scene 9 - After Level 1 completion
            {
                'image': 'DCI_Scenes/Scene9.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene9.mp3',
                'text': f'{self.player_name} completes the code with determination.\n\nPalak the Assassin: "Impressive, {self.player_name}. You may pass for now. Your journey has only begun."',
                'next': 'scene'
            },
            # Scene 10 - Lead to Level 2
            {
                'image': 'DCI_Scenes/Scene10.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene10.mp3',
                'text': f'Russ the Wizard: "Ah, so the prophecy speaks true. {self.player_name}, the new champion, has arrived." He gestures to a puzzle box floating in mid-air, surrounded by a shimmering aura.',
                'next': 'level_2'
            },
            # Scene 11 - After Level 2 completion
            {
                'image': 'DCI_Scenes/Scene11.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene11.mp3',
                'text': f'The Wizard smiles approvingly, nodding.\n\nRuss the Wizard: "Well done, {self.player_name}. You\'ve earned the right to advance. Your wisdom grows stronger with each challenge."',
                'next': 'scene'
            },
            # Scene 12 - Lead to Level 3
            {
                'image': 'DCI_Scenes/Scene12.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene12.mp3',
                'text': f'Geoff the Autocrat: "So, {self.player_name}, you\'ve passed the others. But codes are not just puzzles; they\'re tools of control, of power. I rule through secrets, and now you shall learn their true weight."',
                'next': 'level_3'
            },
            # Scene 13 - After Level 3 completion
            {
                'image': 'DCI_Scenes/Scene13.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene13.mp3',
                'text': f'Autocrat inclines his head, a dark smile on his lips.\n\nGeoff the Autocrat: "Impressive, {self.player_name}. Remember, only those who understand power can control it. Your mastery grows. Proceed."',
                'next': 'scene'
            },
            # Scene 14 - Lead to Level 4
            {
                'image': 'DCI_Scenes/Scene14.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene14.mp3',
                'text': f'Jessica the Wraith materializes from the mist.\n\nJessica: "Ah, {self.player_name}, you are brave, but bravery means nothing in the face of fear. This trial is not of logic, but of your darkest nightmares. Let us see what lies in the depths of your soul."',
                'next': 'level_4'
            },
            # Scene 15 - After Level 4 completion
            {
                'image': 'DCI_Scenes/Scene15.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene15.mp3',
                'text': f'Jessica the Wraith: "You surprise me, {self.player_name}. Few have faced their fears with such resolve. You may go on, though many are lost here Remember this strength in the trials ahead."',
                'next': 'scene'
            },
            # Scene 16 - Lead to Final Level
            {
                'image': 'DCI_Scenes/Scene16.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene16.mp3',
                'text': f'The Undead King\'s voice resonates through the chamber.\n\nJacobo: "At last, {self.player_name}, you stand before the final trial. I am Jacobo, the Undead King, master of the lost and forgotten. To claim victory, you must decipher the oldest code of all, the language of life and death itself."',
                'next': 'level_5'
            },
            # Scene 17 - After Final Level completion
            {
                'image': 'DCI_Scenes/Scene17.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene17.mp3',
                'text': f'Jacobo the Undead King: "Remarkable, {self.player_name}. You have proven yourself beyond all expectations. But know that this accomplishment is not a prize, but a burden. The codes you now possess contain secrets that even the spirits dare not speak. Guard them well, for they will change everything."',
                'next': 'scene'
            },
            # Scene 18 - Exit scene
            {
                'image': 'DCI_Scenes/Scene18.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene18.mp3',
                'text': f'{self.player_name} emerges from the cave, forever changed by the journey.',
                'next': 'scene'
            },
            # Scene 19 - Final scene and credits
            {
                'image': 'DCI_Scenes/Scene19.png',
                'audio': 'DCI_Scenes/Sound_Effects/Scene19.mp3',
                'text': f'Congratulations, {self.player_name}. You are free, but the knowledge you carry will be your eternal companion.',
                'next': 'game_complete',
                'show_credits': True
            }
        ]
        
        # Initialize first scene
        self.current_scene = Scene(self.screen, self.scenes[0])

    def update_scenes_with_name(self):
        """Update all scenes with the player's name"""
        for i in range(1, len(self.scenes)):
            if 'text' in self.scenes[i]:
                self.scenes[i]['text'] = self.scenes[i]['text'].format(
                    player_name=self.player_name)
        
        # Update current scene if not on first scene
        if self.scene_index > 0:
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index], self.player_name)

    def next_scene(self):
        self.scene_index += 1
        if self.scene_index < len(self.scenes):
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index], self.player_name)
        else:
            self.scene_index = len(self.scenes) - 1  # Stay on last scene

    def handle_level_completion(self, level):
        self.level_completed = True
        self.current_level = level + 1
        level_to_scene = {
            0: 7,  # After tutorial, go to Scene 8
            1: 8,  # After Level 1, go to Scene 9
            2: 10, # After Level 2, go to Scene 11
            3: 12, # After Level 3, go to Scene 13
            4: 14, # After Level 4, go to Scene 15
            5: 16  # After Level 5, go to Scene 17
        }
        if level in level_to_scene:
            self.scene_index = level_to_scene[level]
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index], self.player_name)
            return 'scene'
        return 'playing'

    def update(self, dt):
        # Handle current scene update
        if self.current_scene:
            scene_complete = self.current_scene.update(dt)
            if scene_complete:
                next_state = self.scenes[self.scene_index].get('next', 'scene')
                if next_state.startswith('level_'):
                    level_num = int(next_state.split('_')[1])
                    self.current_level = level_num
                    return 'playing'
                elif next_state == 'scene':
                    self.next_scene()
        return self.current_state

    def next_scene(self):
        self.scene_index += 1
        if self.scene_index < len(self.scenes):
            self.current_scene = Scene(self.screen, self.scenes[self.scene_index])
        else:
            self.scene_index = len(self.scenes) - 1  # Stay on last scene

    def draw(self):
        """Draw the current scene"""
        if self.current_scene:
            self.current_scene.draw()
            
            # Draw text input if active and in name input state
            if self.text_input.active:
                self.text_input.draw(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2)
        

class TextInput:
    def __init__(self, screen, font_size=32):
        self.screen = screen
        self.font = pygame.font.SysFont('Bauhaus 93', font_size)
        self.input_text = ""
        self.active = True
        self.cursor_visible = True
        self.cursor_timer = pygame.time.get_ticks()
        self.cursor_blink_speed = 500  # Blink every 500ms
        self.max_length = 20
        
        # Visual styling
        self.box_width = 300
        self.box_height = 50
        self.text_color = (255, 255, 255)
        self.box_color = (0, 0, 0, 180)
        self.border_color = (100, 100, 100)
        self.active_border_color = (200, 200, 200)
        self.prompt_text = "Enter your name:"
        
        # Create prompt surface once
        self.prompt_surface = self.font.render(self.prompt_text, True, self.text_color)

    def handle_event(self, event):
        if not self.active:
            return None

        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RETURN:
                if self.input_text.strip():  # Only accept if there's actual text
                    result = self.input_text.strip()
                    self.active = False
                    return result
            elif event.key == pygame.K_BACKSPACE:
                self.input_text = self.input_text[:-1]
            else:
                if len(self.input_text) < self.max_length and event.unicode.isprintable():
                    self.input_text += event.unicode
        return None

    def draw(self, x, y):
        if not self.active:
            return

        # Center the input box
        box_x = x - self.box_width // 2
        box_y = y

        # Draw the prompt text centered above the input box
        prompt_x = x - self.prompt_surface.get_width() // 2
        prompt_y = box_y - 40
        self.screen.blit(self.prompt_surface, (prompt_x, prompt_y))

        # Draw input box background
        s = pygame.Surface((self.box_width, self.box_height), pygame.SRCALPHA)
        pygame.draw.rect(s, self.box_color, (0, 0, self.box_width, self.box_height))
        self.screen.blit(s, (box_x, box_y))

        # Draw border
        border_color = self.active_border_color if self.active else self.border_color
        pygame.draw.rect(self.screen, border_color, 
                        (box_x, box_y, self.box_width, self.box_height), 2)

        # Draw input text
        if self.input_text:
            text_surface = self.font.render(self.input_text, True, self.text_color)
            text_x = box_x + 10
            text_y = box_y + (self.box_height - text_surface.get_height()) // 2
            self.screen.blit(text_surface, (text_x, text_y))

        # Draw blinking cursor
        current_time = pygame.time.get_ticks()
        if current_time - self.cursor_timer > self.cursor_blink_speed:
            self.cursor_visible = not self.cursor_visible
            self.cursor_timer = current_time

        if self.cursor_visible:
            cursor_x = box_x + 10 + (self.font.size(self.input_text)[0] if self.input_text else 0)
            cursor_y = box_y + 10
            pygame.draw.line(self.screen, self.text_color,
                           (cursor_x, cursor_y),
                           (cursor_x, cursor_y + self.box_height - 20),
                           2)

        # Draw instruction text
        instruction_text = "Press ENTER to confirm"
        instruction_surface = pygame.font.SysFont('Bauhaus 93', 20).render(
            instruction_text, True, (200, 200, 200))
        instruction_x = x - instruction_surface.get_width() // 2
        instruction_y = box_y + self.box_height + 10
        self.screen.blit(instruction_surface, (instruction_x, instruction_y))

class Scene:
    def __init__(self, screen: pygame.Surface, scene_data: dict, player_name=""):  # Add player_name parameter
        self.screen = screen
        self.scene_data = scene_data.copy()
        self.bg_image = None
        self.audio = None
        self.text_box = None
        self.text_font = pygame.font.SysFont('Bauhaus 93', 32)
        self.fade_alpha = 0
        self.fade_speed = 5
        self.fading_in = True
        self.fading_out = False
        self.completed = False
        self.is_name_input = scene_data.get('input', False)
        
        # Format the text with the player's name if available
        if 'text' in self.scene_data and player_name:
            self.scene_data['text'] = self.scene_data['text'].replace('{self.player_name}', player_name)
            self.scene_data['text'] = self.scene_data['text'].replace('{player_name}', player_name)
                
        self.load_assets()
                
    def load_assets(self):
        # Load background image
        if 'image' in self.scene_data:
            try:
                self.bg_image = pygame.image.load(self.scene_data['image'])
                self.bg_image = pygame.transform.scale(self.bg_image, self.screen.get_size())
            except pygame.error:
                print(f"Could not load image: {self.scene_data['image']}")
                self.bg_image = pygame.Surface(self.screen.get_size())
                self.bg_image.fill((0, 0, 0))
        
        # Load audio
        if 'audio' in self.scene_data:
            try:
                self.audio = pygame.mixer.Sound(self.scene_data['audio'])
                self.audio.play()
            except pygame.error:
                print(f"Could not load audio: {self.scene_data['audio']}")
    
    def update(self, dt: float) -> bool:
        if self.fading_in:
            self.fade_alpha = min(255, self.fade_alpha + self.fade_speed)
            if self.fade_alpha >= 255:
                self.fading_in = False
        elif self.fading_out:
            self.fade_alpha = max(0, self.fade_alpha - self.fade_speed)
            if self.fade_alpha <= 0:
                self.cleanup()  # Stop audio when fade out completes
                self.completed = True
        
        # Only return completed if we're not in the middle of a fade effect
        return self.completed
    
    def draw(self):
        # Always draw background image first
        if self.bg_image:
            self.screen.blit(self.bg_image, (0, 0))
        
        # Draw text box if there's text and not a name input scene
        if not self.is_name_input and 'text' in self.scene_data:
            self.draw_text_box(self.scene_data['text'])
        
        # Show prompt when ready for input
        if not self.fading_in and not self.fading_out and not self.is_name_input:
            prompt_font = pygame.font.SysFont('Bauhaus 93', 24)
            prompt = prompt_font.render("Press SPACE to continue...", True, (200, 200, 200))
            prompt_rect = prompt.get_rect(
                right=self.screen.get_width() - 20,
                bottom=self.screen.get_height() - 20
            )
            self.screen.blit(prompt, prompt_rect)
        
        # Apply fade effect last
        fade_surface = pygame.Surface(self.screen.get_size(), pygame.SRCALPHA)
        fade_surface.fill((0, 0, 0, 255 - self.fade_alpha))
        self.screen.blit(fade_surface, (0, 0))
    
    def draw_text_box(self, text: str):
        # Create semi-transparent text box
        box_height = 150
        box_surface = pygame.Surface((self.screen.get_width(), box_height), pygame.SRCALPHA)
        box_surface.fill((0, 0, 0, 180))
        
        # Draw text
        lines = self.wrap_text(text, self.screen.get_width() - 40)
        y_offset = 20
        for line in lines:
            text_surface = self.text_font.render(line, True, (255, 255, 255))
            box_surface.blit(text_surface, (20, y_offset))
            y_offset += 40
        
        # Draw box at bottom of screen
        self.screen.blit(box_surface, (0, self.screen.get_height() - box_height))
    
    def wrap_text(self, text: str, max_width: int):
        words = text.split()
        lines = []
        current_line = []
        current_width = 0
        
        for word in words:
            word_surface = self.text_font.render(word + " ", True, (255, 255, 255))
            word_width = word_surface.get_width()
            
            if current_width + word_width <= max_width:
                current_line.append(word)
                current_width += word_width
            else:
                lines.append(" ".join(current_line))
                current_line = [word]
                current_width = word_width
        
        if current_line:
            lines.append(" ".join(current_line))
        
        return lines
    
    def cleanup(self):
        """Stop audio playback and cleanup resources"""
        if hasattr(self, 'audio') and self.audio:
            try:
                self.audio.stop()
            except (pygame.error, AttributeError):
                pass  # Ignore errors during cleanup
        self.audio = None

    def __del__(self):
        """Ensure audio is stopped when the scene is destroyed"""
        self.cleanup()

    def handle_input(self, event: pygame.event.Event):
        if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
            if not self.fading_in and not self.fading_out:
                self.fading_out = True

class PauseButton:
    def __init__(self, screen):
        self.screen = screen
        # Create button in top right corner with padding
        self.rect = pygame.Rect(SCREEN_WIDTH - 120, 10, 100, 30)
        self.color = (0, 0, 0, 180)  # Semi-transparent black
        self.hover_color = (50, 50, 50, 180)
        self.font = pygame.font.SysFont('Bauhaus 93', 24)
        self.text = self.font.render('PAUSE', True, (255, 255, 255))
        self.text_rect = self.text.get_rect(center=self.rect.center)
        self.is_hovered = False

    def draw(self):
        # Create surface with alpha for transparency
        button_surface = pygame.Surface((self.rect.width, self.rect.height), pygame.SRCALPHA)
        
        # Draw button with hover effect
        color = self.hover_color if self.is_hovered else self.color
        pygame.draw.rect(button_surface, color, button_surface.get_rect(), border_radius=5)
        
        # Draw button on screen
        self.screen.blit(button_surface, self.rect)
        self.screen.blit(self.text, self.text_rect)

    def handle_event(self, event):
        if event.type == pygame.MOUSEMOTION:
            self.is_hovered = self.rect.collidepoint(event.pos)
        elif event.type == pygame.MOUSEBUTTONDOWN:
            if event.button == 1 and self.rect.collidepoint(event.pos):
                return True
        return False

class EnhancedGameStats:
    def __init__(self, screen):
        self.screen = screen
        
        # Load and scale icons with more reasonable size
        try:
            icon_size = (32, 32)  # Reduced from 40
            self.trophy_icon = pygame.transform.scale(pygame.image.load('img/trophy.png'), icon_size)
            self.key_icon = pygame.transform.scale(pygame.image.load('img/key_icon.png'), icon_size)
            self.clock_icon = pygame.transform.scale(pygame.image.load('img/clock.png'), icon_size)
        except Exception as e:
            print(f"Error loading game stats icons: {e}")
            self.trophy_icon = pygame.Surface(icon_size)
            self.trophy_icon.fill((255, 215, 0))
            self.key_icon = pygame.Surface(icon_size)
            self.key_icon.fill((255, 255, 255))
            self.clock_icon = pygame.Surface(icon_size)
            self.clock_icon.fill((100, 200, 255))
        
        # Fonts with better sizes
        self.title_font = pygame.font.SysFont('Bauhaus 93', 28)
        self.stats_font = pygame.font.SysFont('Bauhaus 93', 24)
        self.small_font = pygame.font.SysFont('Bauhaus 93', 20)

    def draw_stats_panel(self, level, keys_collected, required_keys, elapsed_time, time_limit):
        # Main panel dimensions
        panel_width = 600  # Fixed width
        panel_height = 40  # Reduced height
        panel_x = (SCREEN_WIDTH - panel_width) // 2  # Center horizontally
        panel_y = 10  # Top padding
        
        # Create semi-transparent panel
        panel_surface = pygame.Surface((panel_width, panel_height), pygame.SRCALPHA)
        pygame.draw.rect(panel_surface, (0, 0, 0, 150), (0, 0, panel_width, panel_height), border_radius=10)
        
        # Section widths
        section_width = panel_width // 3
        
        # Level name (left section)
        level_text = f"{LEVEL_NAMES[level]}"
        name_surface = self.stats_font.render(level_text, True, (255, 215, 0))
        name_x = 20  # Left padding
        name_y = (panel_height - name_surface.get_height()) // 2
        panel_surface.blit(name_surface, (name_x, name_y))
        
        # Time remaining (middle section)
        remaining_time = time_limit - elapsed_time
        minutes = int(remaining_time // 60)
        seconds = int(remaining_time % 60)
        timer_text = self.stats_font.render(f"{minutes:02}:{seconds:02}", True, (255, 255, 255))
        timer_x = section_width + (section_width - timer_text.get_width()) // 2
        timer_y = (panel_height - timer_text.get_height()) // 2
        panel_surface.blit(timer_text, (timer_x, timer_y))
        
        # Keys collected (right section)
        key_text = self.stats_font.render(f"{keys_collected}/{required_keys}", True, (255, 255, 255))
        key_x = section_width * 2 + (section_width - key_text.get_width() - self.key_icon.get_width() - 5) // 2
        key_y = (panel_height - key_text.get_height()) // 2
        panel_surface.blit(self.key_icon, (key_x, key_y))
        panel_surface.blit(key_text, (key_x + self.key_icon.get_width() + 5, key_y))
        
        # Draw the panel on screen
        self.screen.blit(panel_surface, (panel_x, panel_y))

class PauseMenu:
    def __init__(self, screen):
        self.screen = screen
        self.options = ['RESUME', 'RESTART LEVEL', 'QUIT TO MENU']
        
        # Button dimensions and styling
        self.button_width = 250
        self.button_height = 40
        self.button_spacing = 20
        
        # Create button rects centered on screen
        self.button_rects = []
        start_y = SCREEN_HEIGHT // 2
        for i in range(len(self.options)):
            rect = pygame.Rect(
                (SCREEN_WIDTH - self.button_width) // 2,
                start_y + (self.button_height + self.button_spacing) * i,
                self.button_width,
                self.button_height
            )
            self.button_rects.append(rect)
            
        # Fonts
        self.title_font = pygame.font.SysFont('Bauhaus 93', 50)
        self.option_font = pygame.font.SysFont('Bauhaus 93', 35)
        
        # Colors
        self.text_color = (255, 255, 255)
        self.button_color = (50, 50, 50, 180)
        self.hover_color = (70, 70, 70, 180)
        self.selected_color = (255, 215, 0)
        
        self.hovered = None

    def draw(self):
        # Draw dark overlay
        overlay = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
        overlay.fill((0, 0, 0, 180))
        self.screen.blit(overlay, (0, 0))
        
        # Draw PAUSED text
        pause_text = self.title_font.render('PAUSED', True, self.text_color)
        text_rect = pause_text.get_rect(center=(SCREEN_WIDTH//2, SCREEN_HEIGHT//4))
        self.screen.blit(pause_text, text_rect)
        
        # Get mouse position
        mouse_pos = pygame.mouse.get_pos()
        
        # Draw buttons with hover effect
        for i, (option, rect) in enumerate(zip(self.options, self.button_rects)):
            # Check if mouse is hovering over button
            is_hovered = rect.collidepoint(mouse_pos)
            if is_hovered:
                self.hovered = i
                color = self.hover_color
            else:
                color = self.button_color
            
            # Create button surface with alpha
            button_surface = pygame.Surface((rect.width, rect.height), pygame.SRCALPHA)
            pygame.draw.rect(button_surface, color, button_surface.get_rect(), border_radius=5)
            self.screen.blit(button_surface, rect)
            
            # Draw button text
            text = self.option_font.render(option, True, self.selected_color if is_hovered else self.text_color)
            text_rect = text.get_rect(center=rect.center)
            self.screen.blit(text, text_rect)

    def handle_input(self, event):
        if event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
            mouse_pos = pygame.mouse.get_pos()
            for i, rect in enumerate(self.button_rects):
                if rect.collidepoint(mouse_pos):
                    return self.options[i]
        return None

def handle_level_completion(current_level, door, player):
    """Handle level completion and transitions"""
    if not door.entered and keys_collected >= LEVEL_REQUIREMENTS[current_level]:
        # Start door zoom if we have enough keys
        if not door.is_open:
            camera.start_door_zoom(door)
        elif pygame.sprite.collide_rect(player, door):
            door.entered = True
            camera.stop_sounds()
            return True
    return False

def transition_to_next_level():
    """Handle transition to the next level"""
    global current_level, movement_enabled
    
    # Store completion time
    if game_start_time:
        elapsed_time = int(time.time() - game_start_time)
        level_times.append(elapsed_time)
    
    # Determine next level
    next_level = current_level + 1 if current_level < 5 else None
    
    if next_level is not None:
        # Initialize next level
        result = init_level(next_level)
        if result is not None:
            keys_group, door, world, moving_enemies, player, ghost = result
            camera.start_transition()
            movement_enabled = False
            return "playing"
        else:
            print(f"Failed to initialize level {next_level}")
            return "error"
    else:
        # Game completed
        return "game_complete"

def handle_pause():
    """Handle pause menu state and actions"""
    global paused, running, current_state, keys_collected, game_over, total_pause_time, pause_start_time
    
    pause_menu.draw()
    
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
            
        if current_state in ["intro_scenes", "level_transition"]:
            scene_manager.handle_input(event)
        
        # Handle pause button click
        if current_state == "playing" and not paused and pause_button.handle_event(event):
            paused = True
            pause_start_time = datetime.now()
            fade_alpha = 0
            
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                paused = False
                total_pause_time += datetime.now() - pause_start_time
                return True
                
        action = pause_menu.handle_input(event)
        if action:
            if action == 'RESUME':
                paused = False
                total_pause_time += datetime.now() - pause_start_time
            elif action == 'RESTART LEVEL':
                paused = False
                game_over = 0
                keys_collected = 0
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                camera.cleanup()
                camera.reset_zoom()
                keys_group, door, world, moving_enemies, player, ghost = init_level(current_level)
                camera.start_transition()
            elif action == 'QUIT TO MENU':
                # Cleanup current game resources
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                cleanup_backgrounds()
                pygame.mixer.stop()  # Stop all sound channels
                pygame.mixer.music.stop()  # Stop background music
                pygame.quit()

                # Import and run main menu
                try:
                    import MAINMENU
                    MAINMENU.main()
                    sys.exit()
                except ImportError as e:
                    print(f"Error returning to main menu: {e}")
                    return False
    
    pygame.display.update()
    return True

def cleanup_game():
    """Cleanup all game resources"""
    if hasattr(player, 'stop_sounds'):
        player.stop_sounds()
    if hasattr(camera, 'stop_sounds'):
        camera.stop_sounds()
    if hasattr(scene_manager, 'cleanup'):
        scene_manager.cleanup()
    cleanup_backgrounds()
    pygame.mixer.stop()
    pygame.mixer.music.stop()
    pygame.quit()

class DialogueBox:
    def __init__(self, screen):
        self.screen = screen
        self.animation_complete = False
        self.current_alpha = 0
        self.target_alpha = 180
        self.fade_speed = 10
        self.current_line = 0
        self.current_word = 0
        self.text_delay = 2
        self.frame_counter = 0
        self.words_revealed = []
        
        # Dialogue box dimensions and position
        self.box_height = 200
        self.box_padding = 20
        self.box_y = SCREEN_HEIGHT - self.box_height - 30
        
        # Text formatting
        self.line_height = 40
        self.max_width = SCREEN_WIDTH - (self.box_padding * 2)
        self.font = pygame.font.SysFont('Bauhaus 93', 32)
        
    def wrap_text(self, text):
        """Split text into lines that fit within the dialogue box"""
        words = text.split()
        lines = []
        current_line = []
        current_width = 0
        
        for word in words:
            word_surface = self.font.render(word + ' ', True, (255, 255, 255))
            word_width = word_surface.get_width()
            
            if current_width + word_width <= self.max_width:
                current_line.append(word)
                current_width += word_width
            else:
                lines.append(' '.join(current_line))
                current_line = [word]
                current_width = word_width
        
        if current_line:
            lines.append(' '.join(current_line))
            
        return lines
        
    def animate(self, dialogue_lines, background_image=None):
        # Draw background image if provided
        if background_image:
            try:
                bg_img = pygame.image.load(background_image).convert()
                bg_img = pygame.transform.scale(bg_img, (SCREEN_WIDTH, SCREEN_HEIGHT))
                self.screen.blit(bg_img, (0, 0))
            except (pygame.error, FileNotFoundError) as e:
                print(f"Error loading background image: {e}")
                self.screen.fill((0, 0, 0))
        
        # Create semi-transparent dialogue box
        dialogue_surface = pygame.Surface((SCREEN_WIDTH, self.box_height), pygame.SRCALPHA)
        box_color = (0, 0, 0, self.current_alpha)
        pygame.draw.rect(dialogue_surface, box_color, (0, 0, SCREEN_WIDTH, self.box_height))
        
        # Animate fade in
        if self.current_alpha < self.target_alpha:
            self.current_alpha = min(self.current_alpha + self.fade_speed, self.target_alpha)
        
        self.screen.blit(dialogue_surface, (0, self.box_y))
        
        # Initialize words_revealed if needed
        if not self.words_revealed:
            # Wrap each dialogue line
            wrapped_lines = []
            for line in dialogue_lines:
                wrapped_lines.extend(self.wrap_text(line))
            self.words_revealed = [[] for _ in wrapped_lines]
        
        # Update text animation
        self.frame_counter += 1
        if self.frame_counter >= self.text_delay:
            self.frame_counter = 0
            self.update_text(dialogue_lines)
        
        # Draw text
        y_offset = self.box_y + self.box_padding
        line_spacing = 40
        
        for i, revealed_words in enumerate(self.words_revealed):
            if revealed_words:  # Only draw lines that have revealed words
                text = ' '.join(revealed_words)
                text_surface = self.font.render(text, True, (255, 255, 255))
                text_rect = text_surface.get_rect(
                    left=self.box_padding,
                    top=y_offset + i * line_spacing
                )
                self.screen.blit(text_surface, text_rect)
        
        # Add "Press SPACE to continue" prompt when animation is complete
        if self.animation_complete:
            prompt = pygame.font.SysFont('Bauhaus 93', 24).render(
                "Press SPACE to continue...", True, (200, 200, 200))
            prompt_rect = prompt.get_rect(
                right=SCREEN_WIDTH - self.box_padding,
                bottom=SCREEN_HEIGHT - self.box_padding
            )
            self.screen.blit(prompt, prompt_rect)
        
        return self.animation_complete
    
    def update_text(self, dialogue_lines):
        if self.current_line < len(dialogue_lines):
            wrapped_lines = []
            for line in dialogue_lines:
                wrapped_lines.extend(self.wrap_text(line))
            
            if self.current_line < len(wrapped_lines):
                words = wrapped_lines[self.current_line].split()
                if self.current_word < len(words):
                    self.words_revealed[self.current_line].append(words[self.current_word])
                    self.current_word += 1
                else:
                    self.current_line += 1
                    self.current_word = 0
            else:
                self.animation_complete = True
        else:
            self.animation_complete = True

def show_dialogue(dialogue_lines, background_key=None):
    """
    Show dialogue with background image based on the dialogue section.
    
    Args:
        dialogue_lines (list): List of strings containing dialogue text
        background_key (str): Key for background image from DIALOGUE_BACKGROUNDS
    """
    dialogue_box = DialogueBox(screen)
    background_path = None
    
    if background_key and background_key in DIALOGUE_BACKGROUNDS:
        background_path = DIALOGUE_BACKGROUNDS[background_key]
        try:
            background = pygame.image.load(background_path).convert()
            background = pygame.transform.scale(background, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except (pygame.error, FileNotFoundError) as e:
            print(f"Error loading background image {background_path}: {e}")
            background = None
    else:
        background = None

    waiting = True
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                    return True
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        # Clear screen
        screen.fill((0, 0, 0))
        
        # Draw background if available
        if background:
            screen.blit(background, (0, 0))
            
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

class Ghost(pygame.sprite.Sprite):
    def __init__(self, screen_width, screen_height, player, level):
        super().__init__()
        # Load and scale ghost image
        self.image = pygame.image.load('img/sghost.png').convert_alpha()
        self.image = pygame.transform.scale(self.image, (60, 60))
        self.rect = self.image.get_rect()
        
        # Ghost properties - Make ghost slower in higher levels
        self.base_speed = 2.0
        # Decrease speed for each level instead of increasing
        self.level_speed_multiplier = -0.25  # Changed from 0.4 to -0.25
        # Set minimum speed to prevent ghost from becoming too slow
        self.speed = max(0.8, self.base_speed + (level * self.level_speed_multiplier))
        self.player = player
        
        # Decrease visibility range in higher levels
        self.visibility_range = max(400, 600 - (level * 50))  # Starts at 600, decreases by 50 each level
        
        # Set initial position
        self.spawn_position(screen_width, screen_height)
        
        # Floating movement properties
        self.float_offset = 0
        self.float_speed = 0.05
        self.float_amplitude = 8
        self.true_x = float(self.rect.x)
        self.true_y = float(self.rect.y)
        
        # Transparency properties - Make ghost more transparent in higher levels
        self.min_alpha = max(80, 120 - (level * 10))  # Starts at 120, decreases by 10 each level
        
        # Pulsing effect
        self.pulse_counter = 0
        self.pulse_speed = 0.05
        self.pulse_range = max(20, 40 - (level * 5))  # Reduced pulsing range in higher levels

    def spawn_position(self, screen_width, screen_height):
        """Spawn ghost at the farthest point from player"""
        corners = [
            (0, 0),
            (screen_width - self.rect.width, 0),
            (0, screen_height - self.rect.height),
            (screen_width - self.rect.width, screen_height - self.rect.height)
        ]
        
        max_distance = 0
        spawn_pos = corners[0]
        
        for corner in corners:
            distance = math.sqrt(
                (corner[0] - self.player.rect.x) ** 2 + 
                (corner[1] - self.player.rect.y) ** 2
            )
            if distance > max_distance:
                max_distance = distance
                spawn_pos = corner
        
        self.rect.x = spawn_pos[0]
        self.rect.y = spawn_pos[1]
        self.true_x = float(self.rect.x)
        self.true_y = float(self.rect.y)

    def update(self):
        if not movement_enabled or camera.door_zoom:
            return
            
        # Calculate direction to player
        dx = self.player.rect.centerx - self.rect.centerx
        dy = self.player.rect.centery - self.rect.centery
        
        # Normalize the direction
        distance = math.sqrt(dx ** 2 + dy ** 2)
        if distance > 0:
            dx = dx / distance
            dy = dy / distance
        
        # Update position with adjusted tracking
        distance_factor = min(1.0, distance / self.visibility_range)  # Reduced from 1.5 to 1.0
        actual_speed = self.speed * distance_factor
        
        self.true_x += dx * actual_speed
        self.true_y += dy * actual_speed
        
        # Add floating movement
        self.float_offset += self.float_speed
        float_y = math.sin(self.float_offset) * self.float_amplitude
        
        # Update rect position
        self.rect.x = int(self.true_x)
        self.rect.y = int(self.true_y + float_y)
        
        # Update pulsing effect
        self.pulse_counter += self.pulse_speed
        pulse_alpha = math.sin(self.pulse_counter) * self.pulse_range
        
        # Calculate alpha with reduced visibility range
        current_distance = math.sqrt(
            (self.player.rect.centerx - self.rect.centerx) ** 2 + 
            (self.player.rect.centery - self.rect.centery) ** 2
        )
        
        # Calculate alpha with pulsing effect
        base_alpha = max(self.min_alpha, min(255, (1 - current_distance / self.visibility_range) * 255))
        final_alpha = min(255, max(self.min_alpha, base_alpha + pulse_alpha))
        
        # Apply alpha
        self.image.set_alpha(int(final_alpha))

    def check_collision(self, player):
        """Check for collision with player using a larger collision margin in higher levels"""
        # Increase collision margin for higher levels to make it more forgiving
        collision_margin = 8 + (current_level * 2)  # Increases by 2 pixels per level
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)
    
def check_level_timer(elapsed_time, time_limit):
    """Check if the level time limit has been exceeded"""
    return elapsed_time >= time_limit

class Camera:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.scroll_x = 0
        self.scroll_y = 0
        self.zoom = 1
        self.target_zoom = 1
        self.base_zoom = 2.5
        self.zoom_out_level = 1.3
        self.zoom_speed = 0.04
        self.transitioning = False
        self.transition_start_time = 0
        self.transition_delay = 2000
        self.transition_duration = 2000
        self.transition_total_time = self.transition_delay + self.transition_duration
        self.transition_complete = False
        self.manual_zoom_active = False
        self.initial_zoom_done = False
        
        # Door zoom properties
        self.door_zoom = False
        self.door_zoom_target = None
        self.door_zoom_speed = 0.02
        self.door_target_zoom = 3.5
        self.door_transition_start = 0
        self.door_transition_duration = 1500
        self.post_open_delay = 1000
        self.door_opened_time = 0
        self.reset_on_death = False
        self.death_reset_time = 0
        self.death_reset_duration = 1000  # 1 second for reset animation
        
        # Sound properties
        self.wind_sound = pygame.mixer.Sound('img/Gust of Wind.mp3')
        self.jungle_music = pygame.mixer.Sound('img/Background Music.MP3')
        self.zoom_out_sound = pygame.mixer.Sound('img/zoom_out.mp3')  # Add this line
        self.wind_sound.set_volume(0.8)
        self.jungle_music.set_volume(0.4)
        self.zoom_out_sound.set_volume(0.5)  # Add this line
        self.wind_sound_playing = False
        self.jungle_music_playing = False
        self.wind_sound_start_time = 0
        self.wind_sound_duration = int(self.wind_sound.get_length() * 1000)
        
        self.visible_width = width
        self.visible_height = height

    def apply(self, surface, entity):
        scaled_rect = scale_rect(entity.rect)
        return pygame.Rect(
            scaled_rect.x - self.scroll_x,
            scaled_rect.y - self.scroll_y,
            scaled_rect.width,
            scaled_rect.height
        )

    def apply_sprite(self, surface, sprite):
        scaled_pos = scale_position(
            sprite.rect.x - self.scroll_x,
            sprite.rect.y - self.scroll_y
        )
        return scaled_pos

    def reset_zoom(self):
        """Reset camera zoom when player dies"""
        self.reset_on_death = True
        self.death_reset_time = pygame.time.get_ticks()
        self.zoom = self.base_zoom
        self.target_zoom = self.base_zoom
        self.manual_zoom_active = False
        self.door_zoom = False
        self.door_zoom_target = None
        self.transitioning = False
        self.initial_zoom_done = True

    def start_door_zoom(self, door):
        if not self.door_zoom and not self.manual_zoom_active:
            self.door_zoom = True
            self.door_zoom_target = door
            self.door_transition_start = pygame.time.get_ticks()
            self.door_target_zoom = 3.5
            # All entities will freeze due to the door_zoom check in their update methods
        
    def start_transition(self):
        # Stop any existing sounds before starting new ones
        self.stop_sounds()
        self.transitioning = True
        self.transition_complete = False
        self.zoom = 1
        self.transition_start_time = pygame.time.get_ticks()
        
        # Start wind sound and track its start time
        self.wind_sound.play()
        self.wind_sound_playing = True
        self.wind_sound_start_time = pygame.time.get_ticks()
        self.jungle_music_playing = False
    
    def update(self, target, keys_collected, door, required_keys):
        current_time = pygame.time.get_ticks()
        
        # Handle manual zoom control with Enter key
        keys = pygame.key.get_pressed()
        if keys[pygame.K_RETURN]:
            self.manual_zoom_active = True
            self.target_zoom = self.zoom_out_level
            self.zoom_out_sound.play()
        elif self.manual_zoom_active:
            self.manual_zoom_active = False
            self.target_zoom = self.base_zoom if self.transition_complete else 1
        
        # Handle initial transition
        if self.transitioning and not self.initial_zoom_done:
            elapsed = current_time - self.transition_start_time
            
            if elapsed >= self.transition_delay:
                zoom_elapsed = elapsed - self.transition_delay
                progress = min(zoom_elapsed / self.transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                if not self.manual_zoom_active:
                    self.zoom = 1 + (self.base_zoom - 1) * progress
                
                if progress >= 1:
                    self.transitioning = False
                    self.transition_complete = True
                    self.initial_zoom_done = True
                    global movement_enabled, game_start_time
                    movement_enabled = True
                    
                    # Only start the timer when the initial zoom is complete
                    if game_start_time is None:
                        game_start_time = time.time()
                    
                    if not self.manual_zoom_active:
                        self.zoom = self.base_zoom
                        self.target_zoom = self.base_zoom
        
        # Handle smooth zoom transition
        elif not self.door_zoom:
            if self.zoom != self.target_zoom:
                diff = self.target_zoom - self.zoom
                self.zoom += diff * self.zoom_speed
        
        # Handle door zoom if active
        if self.door_zoom and self.door_zoom_target:
            elapsed = current_time - self.door_transition_start
            
            if not self.door_zoom_target.is_open:
                progress = min(elapsed / self.door_transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                self.zoom = 1 + (self.door_target_zoom - 1) * progress
                
                # Calculate center position for the door
                target_x = self.door_zoom_target.rect.centerx - (SCREEN_WIDTH // (2 * self.zoom))
                target_y = self.door_zoom_target.rect.centery - (SCREEN_HEIGHT // (2 * self.zoom))
                
                # Smoothly move camera to center the door
                self.scroll_x += (target_x - self.scroll_x) * 0.1
                self.scroll_y += (target_y - self.scroll_y) * 0.1
                
                if progress >= 1.0:
                    self.door_zoom_target.open_door()
                    self.door_opened_time = current_time
            else:
                hold_time = current_time - self.door_opened_time
                if hold_time >= self.post_open_delay:
                    zoom_out_progress = min((hold_time - self.post_open_delay) / 1000, 1.0)
                    zoom_out_progress = self.ease_out_cubic(zoom_out_progress)
                    
                    target_zoom = self.target_zoom
                    self.zoom = self.door_target_zoom - (self.door_target_zoom - target_zoom) * zoom_out_progress
                    
                    if zoom_out_progress >= 1.0:
                        self.door_zoom = False
                        self.zoom = target_zoom
        
        # Handle death reset
        if self.reset_on_death:
            elapsed = current_time - self.death_reset_time
            if elapsed <= self.death_reset_duration:
                # Smoothly transition zoom back to base level
                progress = elapsed / self.death_reset_duration
                progress = self.ease_out_cubic(progress)
                self.zoom = 1 + (self.base_zoom - 1) * progress
            else:
                self.reset_on_death = False
                self.zoom = self.base_zoom
                self.target_zoom = self.base_zoom
        
        # Update sound behavior
        if (self.wind_sound_playing and 
            current_time - self.wind_sound_start_time >= self.wind_sound_duration and 
            not self.jungle_music_playing):
            self.wind_sound_playing = False
            self.jungle_music.play()
            self.jungle_music_playing = True
        
        # Update visible area and camera position
        self.visible_width = self.width // self.zoom
        self.visible_height = self.height // self.zoom
        
        # Normal camera follow behavior when not zooming to door
        if not self.door_zoom:
            target_x = target.rect.centerx - self.visible_width // 2
            target_y = target.rect.centery - self.visible_height // 2
            
            self.scroll_x += (target_x - self.scroll_x) * 0.1
            self.scroll_y += (target_y - self.scroll_y) * 0.1
        
        # Keep the camera within bounds
        self.scroll_x = max(0, min(self.scroll_x, SCREEN_WIDTH - self.visible_width))
        self.scroll_y = max(0, min(self.scroll_y, SCREEN_HEIGHT - self.visible_height))
    
    def stop_sounds(self):
        """Stop all sounds and reset sound states"""
        try:
            if pygame.mixer.get_init():  # Check if mixer is initialized
                self.wind_sound.stop()
                self.jungle_music.stop()
                self.zoom_out_sound.stop()  # Add this line
        except (AttributeError, pygame.error):
            pass
        self.wind_sound_playing = False
        self.jungle_music_playing = False

        
    # Update the Camera class cleanup method:
    def cleanup(self):
        """Clean up all audio resources and reset camera state"""
        self.stop_sounds()
        self.transitioning = False
        self.transition_complete = False
        self.zoom = 1
        self.wind_sound_start_time = 0
        self.door_zoom = False
        self.door_zoom_target = None
        
    def __del__(self):
        """Destructor to ensure sounds are stopped when the camera object is destroyed"""
        try:
            self.stop_sounds()
        except:
            pass  # Ignore any errors during cleanup

    def ease_out_cubic(self, x):
        return 1 - pow(1 - x, 3)

    def apply(self, surface, entity):
        return pygame.Rect(
            entity.rect.x - self.scroll_x,
            entity.rect.y - self.scroll_y,
            entity.rect.width,
            entity.rect.height
        )

    def apply_sprite(self, surface, sprite):
        # Return the position where the sprite should be drawn
        return (sprite.rect.x - self.scroll_x,
                sprite.rect.y - self.scroll_y)
                
    def apply_rect(self, rect):
        # Apply camera offset to a rect
        return pygame.Rect(
            rect.x - self.scroll_x,
            rect.y - self.scroll_y,
            rect.width,
            rect.height
        )

def reset_level():
    """Properly reset the level state"""
    global game_over, keys_collected, movement_enabled, game_start_time
    global player, world, moving_enemies, keys_group, door, ghost, camera

    # Reset game state
    game_over = 0
    keys_collected = 0
    movement_enabled = False
    game_start_time = None

    # Stop all sounds
    if hasattr(player, 'stop_sounds'):
        player.stop_sounds()
    if hasattr(camera, 'stop_sounds'):
        camera.stop_sounds()

    # Cleanup camera
    camera.cleanup()
    camera.reset_zoom()

    # Initialize level data
    platforms = LEVEL_PLATFORM_DATA[current_level]
    deadly_tiles = LEVEL_DEADLY_DATA[current_level]
    enemy_data = LEVEL_ENEMY_DATA[current_level]

    # Create world
    world = World(platforms, deadly_tiles)

    # Find spawn position
    spawn_pos = find_spawn_position(platforms)

    # Create new player at spawn position
    player = Player(spawn_pos[0], spawn_pos[1])

    # Create ghost
    ghost = Ghost(SCREEN_WIDTH, SCREEN_HEIGHT, player, current_level)

    # Set up door
    door_pos = find_door_position(platforms)
    door = Door(door_pos[0], door_pos[1])

    # Generate and place keys
    keys_group = pygame.sprite.Group()
    key_positions = generate_key_positions(current_level)
    for pos in key_positions:
        keys_group.add(Key(pos[0], pos[1]))

    # Create enemies
    moving_enemies = pygame.sprite.Group()
    for enemy_info in enemy_data:
        x, y, direction, boundary_start, boundary_end = enemy_info
        enemy = MovingEnemy(x * TILE_SIZE, y * TILE_SIZE, direction, boundary_start, boundary_end)
        moving_enemies.add(enemy)

    camera.start_transition()
    return True

def generate_key_positions(level):
    """Improved key position generation with better boundary checking"""
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    
    # Screen boundaries with margin
    MARGIN = TILE_SIZE * 2
    screen_bounds = {
        'left': MARGIN,
        'right': SCREEN_WIDTH - MARGIN,
        'top': MARGIN,
        'bottom': SCREEN_HEIGHT - MARGIN
    }
    
    def is_within_bounds(x, y):
        """Check if position is within screen bounds"""
        return (screen_bounds['left'] <= x <= screen_bounds['right'] and
                screen_bounds['top'] <= y <= screen_bounds['bottom'])
    
    # Get viable platform positions
    viable_platforms = []
    for plat in platforms:
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip ground level platforms
        if y < SCREEN_HEIGHT * 0.8:
            # Adjust platform boundaries to ensure keys stay within screen
            plat_left = max(x + MARGIN, screen_bounds['left'])
            plat_right = min(x + width - MARGIN, screen_bounds['right'])
            
            if plat_right > plat_left:  # Only add if there's valid space
                viable_platforms.append((plat_left, y, plat_right - plat_left))
    
    import random
    random.shuffle(viable_platforms)
    
    # Keep trying until we have all required keys
    attempts = 0
    max_attempts = required_keys * 10  # Generous attempt limit
    
    while len(positions) < required_keys and attempts < max_attempts:
        if not viable_platforms:
            break
            
        plat = random.choice(viable_platforms)
        
        # Generate position on platform
        key_x = random.uniform(plat[0], plat[0] + plat[2])
        key_y = plat[1] - TILE_SIZE * 1.5  # Place above platform
        
        # Verify position is within bounds
        if is_within_bounds(key_x, key_y):
            positions.append((key_x, key_y))
        
        attempts += 1
    
    # If we still need more keys, place them on the most suitable platforms
    while len(positions) < required_keys:
        if not viable_platforms:
            break
            
        # Use the widest platform available
        plat = max(viable_platforms, key=lambda p: p[2])
        
        # Calculate safe position
        key_x = plat[0] + (plat[2] / 2)  # Center of platform
        key_y = plat[1] - TILE_SIZE * 1.5
        
        if is_within_bounds(key_x, key_y):
            positions.append((key_x, key_y))
        viable_platforms.remove(plat)
    
    return positions

# Update the video background handling code
def update_video_background(level):
    """Update video frame for video backgrounds"""
    if level in video_captures and video_captures[level] is not None:
        ret, frame = video_captures[level].read()
        if not ret:
            # Reset video to beginning if we've reached the end
            video_captures[level].set(cv2.CAP_PROP_POS_FRAMES, 0)
            ret, frame = video_captures[level].read()
        
        if ret:
            # Convert frame from BGR to RGB and flip to match Pygame's format
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame = cv2.resize(frame, (SCREEN_WIDTH, SCREEN_HEIGHT))
            frame = np.rot90(frame)
            frame = np.flipud(frame)
            frame = pygame.surfarray.make_surface(frame)
            return frame
    return None

# Update the initialization of video captures
# Initialize game assets
def init_game():
    """Initialize video captures and background surfaces"""
    global video_captures, background_surfaces, game_stats, pause_menu
    update_scale_factors()  # Update scaling factors
    video_captures = {}
    background_surfaces = {}
    # Update this line to use EnhancedGameStats instead of GameStats
    game_stats = EnhancedGameStats(screen)
    pause_menu = PauseMenu(screen)
    
    for level, bg_data in level_backgrounds.items():
        if bg_data['type'] == 'video':
            try:
                cap = cv2.VideoCapture(bg_data['path'])
                if not cap.isOpened():
                    print(f"Failed to open video file for level {level}")
                    cap = None
                video_captures[level] = cap
            except Exception as e:
                print(f"Error loading video for level {level}: {e}")
                video_captures[level] = None
        else:
            try:
                img = pygame.image.load(bg_data['path']).convert()
                background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
            except Exception as e:
                print(f"Error loading image for level {level}: {e}")
                fallback = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
                fallback.fill((0, 0, 0))
                background_surfaces[level] = fallback

def get_background(level):
    """Get the current background surface for the given level"""
    if level_backgrounds[level]['type'] == 'video':
        return update_video_background(level)
    else:
        return background_surfaces[level]

# Update the cleanup function
def cleanup_backgrounds():
    """Release all video captures properly"""
    global video_captures
    if 'video_captures' in globals():
        for cap in video_captures.values():
            if cap is not None:
                cap.release()
        video_captures.clear()


def create_zoomed_view(screen, camera, player, world, keys_group, door, moving_enemies, ghost):
    current_visible_width = int(SCREEN_WIDTH // camera.zoom)
    current_visible_height = int(SCREEN_HEIGHT // camera.zoom)
    
    view_surface = pygame.Surface((current_visible_width, current_visible_height))
    
    # Get and draw the current background
    current_background = get_background(current_level)
    if current_background:
        view_surface.blit(current_background, (-camera.scroll_x, -camera.scroll_y))
    
    # Draw platforms (if you want them visible)
    # for tile in world.collision_tiles:
    #     pygame.draw.rect(view_surface, (255, 0, 0), camera.apply_rect(tile.rect), 1)
    
    # Draw keys
    for key in keys_group:
        pos = camera.apply_sprite(view_surface, key)
        if (0 <= pos[0] < current_visible_width and 
            0 <= pos[1] < current_visible_height):
            view_surface.blit(key.image, pos)
    
    # Draw door
    door_pos = camera.apply_sprite(view_surface, door)
    if (0 <= door_pos[0] < current_visible_width and 
        0 <= door_pos[1] < current_visible_height):
        view_surface.blit(door.image, door_pos)
    
    # Draw moving enemies
    for enemy in moving_enemies:
        enemy_pos = camera.apply_sprite(view_surface, enemy)
        if (0 <= enemy_pos[0] < current_visible_width and 
            0 <= enemy_pos[1] < current_visible_height):
            view_surface.blit(enemy.image, enemy_pos)
    
    # Draw ghost
    ghost_pos = camera.apply_sprite(view_surface, ghost)
    if (0 <= ghost_pos[0] < current_visible_width and 
        0 <= ghost_pos[1] < current_visible_height):
        view_surface.blit(ghost.image, ghost_pos)
    
    # Draw player last
    player_pos = camera.apply_sprite(view_surface, player)
    if (0 <= player_pos[0] < current_visible_width and 
        0 <= player_pos[1] < current_visible_height):
        view_surface.blit(player.image, player_pos)
    
    # Scale and draw the final view
    scaled_surface = pygame.transform.scale(view_surface, (SCREEN_WIDTH, SCREEN_HEIGHT))
    screen.blit(scaled_surface, (0, 0))
    
    """"
    # Draw HUD elements
    draw_text(f"Level {current_level}", 40, WHITE, 10, 10)
    draw_text(f"Keys: {keys_collected}/{LEVEL_REQUIREMENTS[current_level]}", 40, WHITE, 10, 60)
    """
    
class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Key(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.frames = key_frames  # Use the key_frames list we created earlier
        
        # Animation variables
        self.current_frame = 0
        self.animation_timer = 0
        self.animation_delay = 100  # Milliseconds between frame changes
        
        # Set initial image
        self.image = self.frames[self.current_frame] if self.frames else key_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        
        # Floating movement variables
        self.original_y = float(y)
        self.float_offset = 0
        self.float_speed = 0.03  # Slightly slower float speed
        
    def update(self):
        if self.frames:  # Only animate if we have frames
            # Update animation frame
            current_time = pygame.time.get_ticks()
            if current_time - self.animation_timer > self.animation_delay:
                self.animation_timer = current_time
                self.current_frame = (self.current_frame + 1) % len(self.frames)
                self.image = self.frames[self.current_frame]
        
        # Update floating movement with reduced amplitude (changed from 15 to 5)
        self.float_offset += self.float_speed
        self.rect.y = self.original_y + math.sin(self.float_offset) * 5  # Reduced from 15 to 5

# In the Door class, update the open_door method to handle the image transition properly:
class Door:
    def __init__(self, x, y):
        super().__init__()
        try:
            # Load closed portal image (using underscore instead of space)
            self.closed_image = pygame.image.load('img/closed_portal.png')
            self.closed_image = pygame.transform.scale(self.closed_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            
            # Load portal animation frames
            self.portal_frames = []
            for i in range(1, 6):
                frame = pygame.image.load(f'img/portal_frame_{i}.png')
                frame = pygame.transform.scale(frame, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
                self.portal_frames.append(frame)
                
        except FileNotFoundError as e:
            print(f"Error loading portal images: {e}")
            print("Falling back to default door images...")
            # Fallback to original door images if portal images aren't found
            self.closed_image = pygame.image.load('img/closeddoor.PNG')
            self.closed_image = pygame.transform.scale(self.closed_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            # Create a simple animation using the open door image
            self.portal_frames = []
            open_image = pygame.image.load('img/opendoor_img.PNG')
            open_image = pygame.transform.scale(open_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
            self.portal_frames = [open_image] * 5  # Create 5 copies of the open door image
        
        # Animation properties
        self.current_frame = 0
        self.animation_timer = 0
        self.animation_delay = 50  # Milliseconds between frame changes
        self.is_animating = False
        
        # Initial setup
        self.image = self.closed_image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.is_open = False
        self.door_sound = pygame.mixer.Sound('img/electric_zap.MP3')
        self.door_sound.set_volume(0.5)
        self.sound_played = False
        self.collision_enabled = True
        self.entered = False

    def update(self):
        if self.is_animating:
            current_time = pygame.time.get_ticks()
            
            # Update animation frame
            if current_time - self.animation_timer > self.animation_delay:
                self.animation_timer = current_time
                self.current_frame = (self.current_frame + 1) % len(self.portal_frames)
                self.image = self.portal_frames[self.current_frame]

    def open_door(self):
        if not self.is_open:
            self.is_open = True
            self.is_animating = True
            self.collision_enabled = False
            self.animation_timer = pygame.time.get_ticks()
            if not self.sound_played:
                self.door_sound.play()
                self.sound_played = True

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.6), int(TILE_SIZE * 1.6))  # Doubled the size from TILE_SIZE * 1
        
        # Load animations
        for i in range(1, 5):
            img = pygame.image.load(f'img/MainC{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        # Load sound effects
        self.walking_sound = pygame.mixer.Sound('img/Character Walking.MP3')
        self.walking_sound.set_volume(0.5)
        self.is_walking_sound_playing = False
        
        self.key_collect_sound = pygame.mixer.Sound('img/key_collect.mp3')
        self.key_collect_sound.set_volume(0.4)
        
        self.falling_sound = pygame.mixer.Sound('img/falling_character.mp3')
        self.falling_sound.set_volume(2)
        self.is_falling_sound_playing = False
        self.falling_threshold = 10
        self.falling_counter = 0
        
        self.dead = False  # Add this flag
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, (int(TILE_SIZE * 1.6), int(TILE_SIZE * 1.6)))
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

        self.image = self.animations_right[0]
        self.stop_sounds()
        spawn_pos = find_spawn_position(LEVEL_PLATFORM_DATA[current_level])
        self.rect.x = spawn_pos[0]
        self.rect.y = spawn_pos[1]


    def stop_sounds(self):
        """Stop all player sounds"""
        if self.is_walking_sound_playing:
            self.walking_sound.stop()
            self.is_walking_sound_playing = False
        if self.is_falling_sound_playing:
            self.falling_sound.stop()
            self.is_falling_sound_playing = False

    def cleanup(self):
        """Clean up player resources"""
        self.stop_sounds()
        self.is_walking_sound_playing = False
        self.is_falling_sound_playing = False
        self.falling_counter = 0

    def __del__(self):
        """Ensure sounds are stopped when player object is destroyed"""
        self.stop_sounds()

    def update(self, game_over, world, keys_group, camera):
        global keys_collected
        dx = 0
        dy = 0
        walk_cooldown = 12

        # Check for game over state
        if game_over == -1:
            if not self.dead:
                self.dead = True
                self.image = self.dead_image
                game_over_fx.play()
                self.stop_sounds()  # Stop all player sounds when dying
              # Don't process movement if not enabled or during door zoom

            draw_text('GAME OVER!', 70, BLUE, (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
            if restart_button.draw(screen):

                # Reset death state
                self.dead = False
                self.image = self.animations_right[self.index]  # Reset to normal image
                # Rest of reset code...
                # Reset necessary variables
                game_over = 0
                keys_collected = 0
                
                # Stop any ongoing sounds
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                    
                # Reset camera state
                camera.cleanup()
                camera.reset_zoom()
                camera.start_transition()
                
                # Reset the timer when the player restarts
                global game_start_time
                game_start_time = time.time()  # Set the timer to the current time
                
                # Reinitialize game assets
                init_game()  # Call the init_game function to reset game assets

        if not movement_enabled or camera.door_zoom:
            self.stop_sounds()  # Stop sounds when movement is disabled
            self.vel_y = 0  # Reset vertical velocity

        if self.dead:
            return game_over  
        
        if not movement_enabled or camera.door_zoom:
            return game_over
        # Reset death handling flag when game is restarted
        self._death_handled = False
        
        # Normal movement code here
        if camera.transition_complete:
            key = pygame.key.get_pressed()
            
            # Handle walking sound
            is_moving = False
            
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
                # Reset falling counter when jumping
                self.falling_counter = 0
                if self.is_falling_sound_playing:
                    self.falling_sound.stop()
                    self.is_falling_sound_playing = False
            
            if not key[pygame.K_SPACE]:
                self.jumped = False

            # Check for movement keys and play sound
            if key[pygame.K_LEFT] or key[pygame.K_a]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
                is_moving = True
            if key[pygame.K_RIGHT] or key[pygame.K_d]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
                is_moving = True
            
            # Handle walking sound
            if is_moving and not self.in_air and not self.is_walking_sound_playing:
                self.walking_sound.play(-1)
                self.is_walking_sound_playing = True
            elif (not is_moving or self.in_air) and self.is_walking_sound_playing:
                self.walking_sound.stop()
                self.is_walking_sound_playing = False

            if not (key[pygame.K_LEFT] or key[pygame.K_RIGHT] or key[pygame.K_a] or key[pygame.K_d]):
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

        # Always apply gravity regardless of camera state
        self.vel_y += GRAVITY
        if self.vel_y > 10:
            self.vel_y = 10
        dy += self.vel_y

        if not movement_enabled or camera.door_zoom:
            return game_over
        
        # Handle falling sound
        if self.in_air and self.vel_y > 0:  # If falling
            self.falling_counter += 1
            if self.falling_counter >= self.falling_threshold and not self.is_falling_sound_playing:
                self.falling_sound.play()
                self.is_falling_sound_playing = True
        elif not self.in_air:  # When landing
            self.falling_counter = 0
            if self.is_falling_sound_playing:
                self.falling_sound.stop()
                self.is_falling_sound_playing = False

        # Check for collision with keys
        key_hits = pygame.sprite.spritecollide(self, keys_group, True)
        if key_hits:
            self.key_collect_sound.play()
            keys_collected += len(key_hits)

        # Assume we're in the air unless collision detection proves otherwise
        self.in_air = True

        # Check for collision
        result = world.check_collision(self, dx, dy)
        if result == "deadly":
            return -1  # Return game over state
        else:
            dx, dy = result

        # Update player position
        self.rect.x += dx
        self.rect.y += dy

        # Keep player on screen
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH:
            self.rect.right = SCREEN_WIDTH
            
        # Check if player has fallen off the map
        if self.rect.top > SCREEN_HEIGHT:
            return -1  # Return game over state
            
        return game_over

class World:
    def __init__(self, level_data, deadly_data):
        self.collision_tiles = []
        self.deadly_tiles = []
        self.blue_tiles = []  # Initialize blue_tiles list

        # Create collision tiles
        for plat in level_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            
            offset_x = 0
            offset_y = 0
            
            collision_rect = pygame.Rect(
                x + offset_x,
                y + offset_y,
                width,
                height
            )
            self.collision_tiles.append(CollisionTile(x + offset_x, y + offset_y, width, height))

        # Create deadly tiles
        for deadly in deadly_data:
            x = deadly[0] * TILE_SIZE
            y = deadly[1] * TILE_SIZE
            width = deadly[2] * TILE_SIZE
            height = int(deadly[3] * TILE_SIZE)
            
            self.deadly_tiles.append(CollisionTile(x, y, width, height))

        # Create blue tiles
        if current_level in LEVEL_BLUE_DATA:
            for blue in LEVEL_BLUE_DATA[current_level]:
                x = blue[0] * TILE_SIZE
                y = blue[1] * TILE_SIZE
                width = blue[2] * TILE_SIZE
                height = int(blue[3] * TILE_SIZE)
                
                self.blue_tiles.append(CollisionTile(x, y, width, height))

                '''    def draw(self, screen):
                        # Draw regular collision tiles in red
                        for tile in self.collision_tiles:
                            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)
                        
                        # Draw deadly tiles in green
                        for tile in self.deadly_tiles:
                            pygame.draw.rect(screen, (0, 255, 0), tile.rect, 2)
                        
                        # Draw blue tiles in blue
                        for tile in self.blue_tiles:
                            pygame.draw.rect(screen, (0, 0, 255), tile.rect, 1)'''

    def check_collision(self, player, dx, dy):
        # Check collision with both regular and blue tiles
        for tile in self.collision_tiles + self.blue_tiles:
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False
                    
        # Check deadly collisions
        for tile in self.deadly_tiles:
            if tile.rect.colliderect(player.rect):
                return "deadly"
                
        return dx, dy

def init_level(level_num):
    """Initialize a new level with all required components"""
    global keys_collected, game_start_time, current_level, player, camera
    global ghost, movement_enabled, total_pause_time
    
    try:
        # Reset level state
        keys_collected = 0
        current_level = level_num
        game_start_time = None  # Reset timer - will be started after transition
        total_pause_time = timedelta(0)
        movement_enabled = False
        
        # Stop all existing sounds
        if 'player' in globals() and player is not None:
            player.stop_sounds()
        if 'camera' in globals() and camera is not None:
            camera.stop_sounds()
        
        # Clean up existing camera if it exists
        if 'camera' in globals() and camera is not None:
            camera.cleanup()
        
        # Load level data
        platforms = LEVEL_PLATFORM_DATA.get(level_num, [])
        if not platforms:
            raise ValueError(f"No platform data found for level {level_num}")
            
        deadly_tiles = LEVEL_DEADLY_DATA.get(level_num, [])
        enemy_data = LEVEL_ENEMY_DATA.get(level_num, [])
        
        # Create world
        world = World(platforms, deadly_tiles)
        
        # Calculate spawn position
        spawn_pos = find_spawn_position(platforms)
        
        # Create player
        player = Player(spawn_pos[0], spawn_pos[1])
        
        # Create ghost with appropriate level difficulty
        ghost = Ghost(SCREEN_WIDTH, SCREEN_HEIGHT, player, level_num)
        
        # Set up door
        door_pos = find_door_position(platforms)
        door = Door(door_pos[0], door_pos[1])
        
        # Generate and place keys
        keys_group = pygame.sprite.Group()
        key_positions = generate_key_positions(level_num)
        for pos in key_positions:
            adjusted_y = pos[1] + TILE_SIZE - 20
            keys_group.add(Key(pos[0], adjusted_y))
            
        # Create enemies
        moving_enemies = pygame.sprite.Group()
        for enemy_info in enemy_data:
            x, y, direction, boundary_start, boundary_end = enemy_info
            enemy = MovingEnemy(x * TILE_SIZE, y * TILE_SIZE, direction, boundary_start, boundary_end)
            moving_enemies.add(enemy)
            
        # Reset camera
        camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
        camera.transitioning = False
        camera.transition_complete = False
        camera.manual_zoom_active = False
        camera.door_zoom = False
        camera.door_zoom_target = None
        camera.reset_on_death = False
        
        print(f"Level {level_num} initialized successfully")
        return keys_group, door, world, moving_enemies, player, ghost
        
    except Exception as e:
        import traceback
        print(f"\nError initializing level {level_num}:")
        print(f"Error type: {type(e).__name__}")
        print(f"Error message: {str(e)}")
        print("Traceback:")
        traceback.print_exc()
        return None, None, None, None, None, None


class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2)))
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.direction = direction
        self.speed = 1.2
        self.moving_right = True
        self.moving_down = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE
        self.initial_pos = self.rect.x if direction == "horizontal" else self.rect.y


    def update(self):
        if not movement_enabled or camera.door_zoom:
            return
            
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)

    def draw_boundaries(self, screen):
        # Draw movement boundaries (for debugging)
        if self.direction == "horizontal":
            pygame.draw.line(screen, (255, 0, 0),
                           (self.boundary_start, self.rect.centery),
                           (self.boundary_end, self.rect.centery), 2)
        else:
            pygame.draw.line(screen, (255, 0, 0),
                           (self.rect.centerx, self.boundary_start),
                           (self.rect.centerx, self.boundary_end), 2)

    def check_collision(self, player):
        # Create a slightly smaller collision rect for more forgiving collisions
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button:
    def __init__(self, x, y, image):
        self.original_image = image
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = int(x * SCALE_X)
        self.rect.y = int(y * SCALE_Y)
        self.clicked = False
        
        # Scale image if needed
        if SCALE_X != 1.0 or SCALE_Y != 1.0:
            new_size = (int(self.rect.width * SCALE_X), int(self.rect.height * SCALE_Y))
            self.image = pygame.transform.scale(self.original_image, new_size)
            self.rect = self.image.get_rect(x=self.rect.x, y=self.rect.y)

    def draw(self, screen):
        action = False
        # Get mouse position
        pos = pygame.mouse.get_pos()  # This gets the (x, y) position of the mouse

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and not self.clicked:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font_size, color, x, y):
    font = pygame.font.SysFont('Bauhaus 93', font_size)
    img = font.render(text, True, color)
    screen.blit(img, (x, y))

def find_suitable_platform(platforms):
    """
    Find a suitable platform for door placement using better criteria:
    1. Platform must be wide enough for door and NPC
    2. Platform should be reasonably high up but not necessarily the highest
    3. Platform should have enough space above it
    """
    # Sort platforms by height (y-coordinate), from top to bottom
    sorted_platforms = sorted(platforms, key=lambda p: p[1])
    
    # Required width for door and NPC (in tile units)
    required_width = 4  # Space for door and NPC
    
    # Check top 1/3 of platforms for a suitable spot
    top_third = len(sorted_platforms) // 3
    if top_third < 1:
        top_third = 1
    
    for platform in sorted_platforms[:top_third]:
        # Get platform dimensions
        x, y, width, height = platform
        
        # Check if platform is wide enough
        if width >= required_width:
            # Check if there's another platform directly above
            has_obstruction = False
            platform_top = y
            platform_left = x
            platform_right = x + width
            
            # Check for obstructions above
            for other_platform in platforms:
                other_x, other_y, other_width, other_height = other_platform
                other_left = other_x
                other_right = other_x + other_width
                other_bottom = other_y + other_height
                
                # Check if there's a platform directly above
                if (other_bottom > platform_top - 4 and  # Leave space for door height
                    other_y < platform_top and
                    other_right > platform_left and
                    other_left < platform_right):
                    has_obstruction = True
                    break
            
            if not has_obstruction:
                return platform
                
    # Fallback to the widest platform in the top half if no perfect match
    top_half = sorted_platforms[:len(sorted_platforms)//2]
    widest_platform = max(top_half, key=lambda p: p[2])
    return widest_platform

def find_spawn_position(platforms):
    """Find a safe spawn position on the leftmost ground platform"""
    # Filter for ground-level platforms (in the bottom third of the screen)
    ground_platforms = []
    screen_bottom_third = (SCREEN_HEIGHT / TILE_SIZE) * 2/3
    
    for platform in platforms:
        if platform[1] > screen_bottom_third:
            ground_platforms.append(platform)
    
    if not ground_platforms:
        # Fallback to the lowest platform if no ground platforms found
        lowest_platform = max(platforms, key=lambda p: p[1])
        spawn_x = (lowest_platform[0] + 1) * TILE_SIZE
        spawn_y = lowest_platform[1] * TILE_SIZE - TILE_SIZE * 1.6  # Adjust to be exactly on platform
        return (spawn_x, spawn_y)
    
    # Find leftmost ground platform
    leftmost = min(ground_platforms, key=lambda p: p[0])
    
    # Position player exactly on top of the platform
    spawn_x = (leftmost[0] + 1) * TILE_SIZE
    spawn_y = leftmost[1] * TILE_SIZE - TILE_SIZE * 1.6  # Adjust for player height
    
    return (spawn_x, spawn_y)

def find_door_position(platforms):
    """Find an appropriate position for the door"""
    # Find a suitable platform (high up but accessible)
    suitable_platform = find_suitable_platform(platforms)
    
    # Position door near the right edge of the platform
    door_x = (suitable_platform[0] + suitable_platform[2] - 2) * TILE_SIZE
    door_y = (suitable_platform[1] - 2) * TILE_SIZE
    
    # Ensure door doesn't go off screen
    if door_x > SCREEN_WIDTH - 3 * TILE_SIZE:
        door_x = SCREEN_WIDTH - 3 * TILE_SIZE
    
    return (door_x, door_y)

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    deadly_tiles = LEVEL_DEADLY_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Function to check if position is safe from deadly tiles
    def is_safe_position(x, y):
        SAFE_DISTANCE = TILE_SIZE * 3  # Minimum distance from deadly tiles
        
        for deadly in deadly_tiles:
            deadly_x = deadly[0] * TILE_SIZE
            deadly_y = deadly[1] * TILE_SIZE
            deadly_width = deadly[2] * TILE_SIZE
            deadly_height = deadly[3] * TILE_SIZE
            
            # Calculate boundaries of the deadly area with safety margin
            deadly_left = deadly_x - SAFE_DISTANCE
            deadly_right = deadly_x + deadly_width + SAFE_DISTANCE
            deadly_top = deadly_y - SAFE_DISTANCE
            deadly_bottom = deadly_y + deadly_height + SAFE_DISTANCE
            
            # Check if key position is within the danger zone
            if (deadly_left < x < deadly_right and 
                deadly_top < y < deadly_bottom):
                return False
        return True
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    attempts = 0
    max_attempts = 100  # Prevent infinite loop
    
    while len(positions) < required_keys and attempts < max_attempts:
        for plat in viable_platforms:
            if len(positions) >= required_keys:
                break
                
            # Try multiple positions on each platform
            for _ in range(5):  # Try 5 times per platform
                # Place key somewhere along the platform
                key_x = plat[0] + random.uniform(TILE_SIZE, plat[2] - TILE_SIZE * 2)
                key_y = plat[1] - TILE_SIZE * 1.5
                
                # Only add position if it's safe
                if is_safe_position(key_x, key_y):
                    positions.append((key_x, key_y))
                    break
            
            attempts += 1
    
    # If we couldn't find enough safe positions, fill remaining with positions farther from platforms
    while len(positions) < required_keys:
        plat = random.choice(viable_platforms)
        key_x = plat[0] + random.uniform(TILE_SIZE * 2, plat[2] - TILE_SIZE * 2)
        key_y = plat[1] - TILE_SIZE * 2  # Place keys higher above platform
        if is_safe_position(key_x, key_y):
            positions.append((key_x, key_y))
    
    return positions

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    
    for i in range(min(required_keys, len(viable_platforms))):
        plat = viable_platforms[i]
        # Place key somewhere along the platform
        key_x = plat[0] + random.uniform(0, plat[2] - TILE_SIZE)
        key_y = plat[1] - TILE_SIZE * 1.5  # Place key above platform
        positions.append((key_x, key_y))
    
    return positions

# Modify the initialize_game_objects function to include the leaderboard
def initialize_game_objects():
    global start_button, restart_button, camera, player, world, moving_enemies
    global keys_group, door, ghost, game_over, current_state, movement_enabled
    global pause_button, scene_manager, game_stats, leaderboard

    # Create scene manager first
    scene_manager = SceneManager(screen)
    
    # Initialize other objects
    start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
    restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)
    camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
    player = Player(100, SCREEN_HEIGHT - 130)
    world = World(LEVEL_PLATFORM_DATA[1], LEVEL_DEADLY_DATA[1])
    moving_enemies = pygame.sprite.Group()
    keys_group = pygame.sprite.Group()
    door = None
    ghost = None
    game_over = 0
    current_state = "name_input"
    movement_enabled = False 
    pause_button = PauseButton(screen)
    game_stats = EnhancedGameStats(screen)
    leaderboard = Leaderboard(screen)

    return scene_manager

# Initialize game state
scene_manager = initialize_game_objects()
init_game()
update_scale_factors()

# Game loop
clock = pygame.time.Clock()
fps = 60
running = True
fullscreen = False

# Main game loop
while running:
    clock.tick(fps)
    
    # Handle pause state first
    if current_state == "playing" and paused:
        if not handle_pause():
            running = False
        continue
    
    # Global event handling
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
            
        # Handle fullscreen toggle and update scaling
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_RSHIFT:
                toggle_fullscreen()
                # Recreate UI elements with new scaling
                initialize_game_objects()
                
        # Global pause handling
        if current_state == "playing" and not paused:
            if (event.type == pygame.KEYDOWN and event.key == pygame.K_ESCAPE) or \
               pause_button.handle_event(event):
                paused = True
                pause_start_time = datetime.now()
                fade_alpha = 0
                continue

        # Handle scene-specific input
        if current_state in ["scene", "intro_scenes", "level_transition", "ending_scenes"]:
            if event.type == pygame.KEYDOWN and event.key == pygame.K_SPACE:
                if not scene_manager.current_scene.fading_in and not scene_manager.current_scene.fading_out:
                    scene_manager.current_scene.fading_out = True
        
        # Handle name input
        if current_state == "name_input" and scene_manager.text_input.active:
            result = scene_manager.text_input.handle_event(event)
            if result:
                scene_manager.player_name = result
                scene_manager.text_input.active = False
                scene_manager.update_scenes_with_name()
                current_state = "scene"
    
    if not running:
        break

    # Clear screen
    screen.fill(BLACK)
    
    # State-specific updates
    if current_state == "name_input":
        scene_manager.draw()
        
    elif current_state in ["scene", "intro_scenes", "level_transition", "ending_scenes"]:
        scene_manager.update(clock.get_time() / 1000.0)
        scene_manager.draw()
        
        if scene_manager.current_scene.completed:
            next_state = scene_manager.scenes[scene_manager.scene_index].get('next', 'scene')
            
            if next_state == 'scene':
                scene_manager.next_scene()
            elif next_state.startswith('level_'):
                level_num = 0 if scene_manager.scene_index == 6 else int(next_state.split('_')[1])
                game_start_time = None
                movement_enabled = False
                
                level_objects = init_level(level_num)
                if all(obj is not None for obj in level_objects):
                    keys_group, door, world, moving_enemies, player, ghost = level_objects
                    camera.start_transition()
                    current_state = "playing"
            elif next_state == 'game_complete':
                current_state = "game_complete"
                
    elif current_state == "playing":
        # Get and draw the current background
        current_background = get_background(current_level)
        if current_background:
            scaled_bg = pygame.transform.scale(current_background, (SCREEN_WIDTH, SCREEN_HEIGHT))
            screen.blit(scaled_bg, (0, 0))
        
        # Determine if entities can move
        can_move = movement_enabled and not camera.door_zoom and not paused
        
        # Update game entities only when movement is allowed
        if can_move:
            # Update entities
            keys_group.update()
            moving_enemies.update()
            ghost.update()
            
            # Check collisions with enemies and ghost
            for enemy in moving_enemies:
                if enemy.check_collision(player):
                    game_over = -1
                    break
            
            if ghost.check_collision(player):
                game_over = -1
            
            # Update player and check for game over
            game_over = player.update(game_over, world, keys_group, camera)
            
            # Update timer only when game started and movement allowed
            if game_start_time is None:
                if camera.transition_complete and camera.initial_zoom_done:
                    game_start_time = time.time()
            elif not game_over:
                current_time = time.time()
                elapsed_time = current_time - game_start_time
                if total_pause_time:
                    elapsed_time -= total_pause_time.total_seconds()
                
                # Check level timer
                if check_level_timer(elapsed_time, LEVEL_TIME_LIMITS[current_level]):
                    game_over = -1
                    game_over_fx.play()
        
        # Always update door animation
        door.update()
        
        # Check level completion
        if keys_collected >= LEVEL_REQUIREMENTS[current_level]:
            if not door.is_open:
                camera.start_door_zoom(door)
            elif pygame.sprite.collide_rect(player, door) and not door.entered:
                door.entered = True
                camera.stop_sounds()
                
                level_complete_mapping = {
                    0: (1, 7),    # Tutorial -> Level 1, Scene 8
                    1: (2, 9),    # Level 1 -> Level 2, Scene 10
                    2: (3, 11),   # Level 2 -> Level 3, Scene 12
                    3: (4, 13),   # Level 3 -> Level 4, Scene 14
                    4: (5, 15),   # Level 4 -> Level 5, Scene 16
                    5: (None, 17) # Level 5 -> Ending (Scene 18)
                }
                
                if current_level in level_complete_mapping:
                    next_level, next_scene = level_complete_mapping[current_level]
                    if next_level is None:
                        current_state = "ending_scenes"
                    else:
                        current_level = next_level
                        current_state = "level_transition"
                    scene_manager.scene_index = next_scene
                    scene_manager.current_scene = Scene(screen, scene_manager.scenes[next_scene])
        
        # Update camera and create zoomed view with scaling
        camera.update(player, keys_collected, door, LEVEL_REQUIREMENTS[current_level])
        create_zoomed_view(screen, camera, player, world, keys_group, door, moving_enemies, ghost)
        
        # Draw HUD if not in door zoom
        if not camera.door_zoom and camera.transition_complete:
            game_stats.draw_stats_panel(
                current_level,
                keys_collected,
                LEVEL_REQUIREMENTS[current_level],
                time.time() - game_start_time if game_start_time else 0,
                LEVEL_TIME_LIMITS[current_level]
            )
            if not paused:
                pause_button.draw()
                leaderboard.draw()  # Draw leaderboard during gameplay
        
        # Handle game over state
        if game_over == -1:
            text_x = (SCREEN_WIDTH // 2) - int(200 * SCALE_X)
            text_y = SCREEN_HEIGHT // 2
            draw_text('GAME OVER!', int(70 * SCALE_Y), BLUE, text_x, text_y)
            if restart_button.draw(screen):
                if not reset_level():
                    print("Failed to restart level")
                    running = False
        
    elif current_state == "game_complete":
        screen.fill(BLACK)
        
        # Calculate final stats
        if game_start_time:
            total_time = datetime.now() - datetime.fromtimestamp(game_start_time) - total_pause_time
            total_seconds = total_time.total_seconds()
            
            # Add score to leaderboard
            leaderboard.add_score(scene_manager.player_name, total_seconds)
            
            minutes = int(total_time.total_seconds() // 60)
            seconds = int(total_time.total_seconds() % 60)
            
            # Draw completion card
            card_width = int(600 * SCALE_X)
            card_height = int(400 * SCALE_Y)
            completion_card = pygame.Surface((card_width, card_height))
            completion_card.fill((40, 40, 40))
            
            title_font = pygame.font.SysFont('Bauhaus 93', int(70 * SCALE_Y))
            title = title_font.render("GAME COMPLETE!", True, (255, 215, 0))
            completion_card.blit(title, (card_width//2 - title.get_width()//2, int(40 * SCALE_Y)))
            
            stats = [
                f"Player: {scene_manager.player_name}",
                f"Total Time: {minutes:02d}:{seconds:02d}",
                f"Keys Collected: {sum(LEVEL_REQUIREMENTS.values())}",
                f"Levels Completed: 5"
            ]
            
            stats_font = pygame.font.SysFont('Bauhaus 93', int(40 * SCALE_Y))
            for i, stat in enumerate(stats):
                text = stats_font.render(stat, True, WHITE)
                completion_card.blit(text, (card_width//2 - text.get_width()//2, 
                                         int((160 + i * 60) * SCALE_Y)))
            
            screen.blit(completion_card, 
                      (SCREEN_WIDTH//2 - card_width//2,
                       SCREEN_HEIGHT//2 - card_height//2))
            
            # Draw leaderboard next to completion card
            leaderboard.draw()
            
            if restart_button.draw(screen):
                current_state = "name_input"
                game_start_time = None
                current_level = 0
                keys_collected = 0
                level_times = []
                scene_manager = SceneManager(screen)
    
    pygame.display.update()

# Cleanup
cleanup_game()
pygame.quit()

================
File: mini_game4.py
================
"""
mini-game4.py

Primary Author: Jessica Ng
Enhanced by: Claude

An educational puzzle game that combines Python programming knowledge with visual
tile-based mechanics, featuring enhanced visuals and feedback systems.
"""

import pygame
import sys
import time
import random
import math
from os.path import join
from PIL import Image

# Initialize game engine
pygame.init()

# Display configuration
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
GOLD = (255, 215, 0)

# Feedback position constants
FEEDBACK_X = SCREEN_WIDTH - 420
FEEDBACK_Y = SCREEN_HEIGHT // 2 - 400

# Set up display window
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("D'Code and Build")

# Initialize fonts
game_font = pygame.font.Font('Minigame4/PRESSSTART2P.ttf', 24)
game_font_large = pygame.font.Font('Minigame4/PRESSSTART2P.ttf', 36)
game_font_small = pygame.font.Font('Minigame4/PRESSSTART2P.ttf', 18)
game_font_medium = pygame.font.Font('Minigame4/PRESSSTART2P.ttf', 28)

# Load and scale background image
try:
    background_img = pygame.image.load(join('Minigame4/Jessica Background.png')).convert()
    background_img = pygame.transform.scale(background_img, (SCREEN_WIDTH, SCREEN_HEIGHT))
except:
    background_img = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
    for i in range(SCREEN_HEIGHT):
        color = (
            min(255, 20 + i * 0.1),
            min(255, 30 + i * 0.1),
            min(255, 50 + i * 0.1)
        )
        pygame.draw.line(background_img, color, (0, i), (SCREEN_WIDTH, i))

# Load puzzle tile images and complete Python image
tile_images = []
initial_tile_images = []

# Add error handling for loading tile images
for i in range(9):
    try:
        tile_img = pygame.image.load(join('Minigame4/', f'Python_{i+1}.png')).convert_alpha()
        initial_img = pygame.image.load(join('Minigame4/', f'initial_tile_{i+1}.png')).convert_alpha()
        tile_images.append(tile_img)
        initial_tile_images.append(initial_img)
    except:
        print(f"Failed to load tile image {i+1}")
        # Create fallback colored rectangles
        fallback = pygame.Surface((200, 200), pygame.SRCALPHA)
        pygame.draw.rect(fallback, (100, 100, 100, 255), fallback.get_rect())
        tile_images.append(fallback)
        initial_tile_images.append(fallback)

complete_python_img = pygame.image.load(join('Minigame4/complete_python.png')).convert_alpha()
complete_python_img = pygame.transform.scale(complete_python_img, (200, 200))  # Changed to 200x200

# Scale tile images
tile_images = [pygame.transform.scale(img, (200, 200)) for img in tile_images]
initial_tile_images = [pygame.transform.scale(img, (200, 200)) for img in initial_tile_images]

class GifPlayer:
    def __init__(self, gif_path):
        self.frames = []
        self.current_frame = 0
        self.last_update = 0
        self.frame_duration = 30  # Further reduced for smoother playback
        
        try:
            gif = Image.open(gif_path)
            while True:
                frame = gif.copy()
                frame = pygame.image.fromstring(
                    frame.convert('RGBA').tobytes(), frame.size, 'RGBA')
                self.frames.append(frame)
                gif.seek(gif.tell() + 1)
        except EOFError:
            pass
        except Exception as e:
            print(f"Error loading gif {gif_path}: {e}")
            # Create a fallback frame
            fallback = pygame.Surface((200, 200), pygame.SRCALPHA)
            pygame.draw.rect(fallback, (100, 100, 100, 128), fallback.get_rect())
            self.frames = [fallback]

    def update(self):
        if not self.frames:
            return
        current_time = pygame.time.get_ticks()
        if current_time - self.last_update > self.frame_duration:
            self.current_frame = (self.current_frame + 1) % len(self.frames)
            self.last_update = current_time

    def get_current_frame(self):
        if not self.frames:
            return None
        return self.frames[self.current_frame]

class FeedbackSystem:
    def __init__(self):
        self.gifs = {
            'welcome': GifPlayer('Minigame4/Jess Welcome.gif'),
            'instructions': GifPlayer('Minigame4/Jess Instructions.gif'),
            'time': GifPlayer('Minigame4/Jess Time.gif'),
            '6initial': GifPlayer('Minigame4/Jess 6Initial.gif'),
            '3initial': GifPlayer('Minigame4/Jess 3Initial.gif'),
            'decode': GifPlayer('Minigame4/Jess Decode.gif'),
            'win': GifPlayer('Minigame4/Jess Win.gif'),
            'lost': GifPlayer('Minigame4/Jess Lost.gif')
        }
        self.current_gif = None
        self.display_time = 0
        self.last_gif = None

    def show_gif(self, gif_name, duration=5000):  # Increased duration to 5 seconds
        self.current_gif = self.gifs[gif_name]
        self.display_time = pygame.time.get_ticks() + duration
        self.last_gif = gif_name

    def is_playing(self):
        return pygame.time.get_ticks() < self.display_time

    def update(self, screen):
        if self.current_gif and pygame.time.get_ticks() < self.display_time:
            self.current_gif.update()
            frame = self.current_gif.get_current_frame()
            if frame:
                screen.blit(frame, (FEEDBACK_X, FEEDBACK_Y))

class Timer:
    def __init__(self, duration):
        self.duration = duration
        self.start_time = pygame.time.get_ticks()
        self.is_running = True
        self.one_minute_warning_shown = False

    def get_time_left(self):
        if not self.is_running:
            return 0
        elapsed = (pygame.time.get_ticks() - self.start_time) // 1000
        remaining = max(0, self.duration - elapsed)
        return remaining

    def is_finished(self):
        return self.get_time_left() <= 0

    def stop(self):
        self.is_running = False

    def draw(self, screen, font):
        if self.is_running:
            seconds_left = self.get_time_left()
            minutes = seconds_left // 60
            seconds = seconds_left % 60
            time_text = f"{minutes}:{seconds:02d}"
            text_surface = font.render(time_text, True, WHITE)
            screen.blit(text_surface, (20, 20))

    def should_show_warning(self):
        seconds_left = self.get_time_left()
        if seconds_left <= 60 and not self.one_minute_warning_shown:
            self.one_minute_warning_shown = True
            return True
        return False

class Tile:
    def __init__(self, x, y, number):
        self.original_rect = pygame.Rect(x, y, 200, 200)
        self.rect = self.original_rect.copy()
        self.number = number
        self.question = None
        self.answer = None
        self.solved = False
        
        self.pressing = False
        self.press_scale = 1.0
        self.press_duration = 300
        self.press_start_time = 0
        self.question_ready = False
        self.flash_alpha = 0
        self.flash_wrong = False
        self.flash_wrong_start = 0
        self.flash_duration = 500
        self.flash_color = RED
        
        self.victory_glow = False
        self.victory_glow_start = 0
        self.victory_glow_duration = 1000
        self.victory_glow_color = (255, 215, 0)
        
        self.border_thickness = 4
        self.border_color = (255, 215, 0)
        self.border_radius = 10
        
        self.final_image = tile_images[number - 1]
        self.initial_image = initial_tile_images[number - 1]
        self.moved_to_top = False
        self.final_position = None
        self.show_in_question_phase = True

    def start_press_animation(self):
        if not self.pressing:
            self.pressing = True
            self.press_start_time = pygame.time.get_ticks()
            self.press_scale = 1.0

    def start_wrong_flash(self):
        self.flash_wrong = True
        self.flash_wrong_start = pygame.time.get_ticks()

    def start_victory_glow(self):
        self.victory_glow = True
        self.victory_glow_start = pygame.time.get_ticks()

    def update(self):
        if self.pressing:
            elapsed = pygame.time.get_ticks() - self.press_start_time
            if elapsed < self.press_duration / 2:
                self.press_scale = 1.0 + (elapsed / (self.press_duration / 2)) * 0.1
            elif elapsed < self.press_duration:
                progress = (elapsed - self.press_duration / 2) / (self.press_duration / 2)
                self.press_scale = 1.1 - progress * 0.1
            else:
                self.pressing = False
                self.press_scale = 1.0
                self.question_ready = True
                self.flash_alpha = 255

        if self.flash_alpha > 0:
            self.flash_alpha = max(0, self.flash_alpha - 10)

        if self.flash_wrong:
            elapsed = pygame.time.get_ticks() - self.flash_wrong_start
            if elapsed >= self.flash_duration:
                self.flash_wrong = False

        if self.victory_glow:
            elapsed = pygame.time.get_ticks() - self.victory_glow_start
            if elapsed >= self.victory_glow_duration:
                self.victory_glow = False

    def draw_with_border(self, surface, image, rect):
        border_rect = rect.inflate(self.border_thickness * 2, self.border_thickness * 2)
        pygame.draw.rect(surface, self.border_color, border_rect, 
                        border_radius=self.border_radius)
        screen.blit(image, rect)

    def draw(self, show_tiles=True):
        if not show_tiles or not self.show_in_question_phase:
            return
            
        if not self.question_ready or self.solved:
            if self.pressing:
                scaled_width = int(self.rect.width * self.press_scale)
                scaled_height = int(self.rect.height * self.press_scale)
                scaled_image = pygame.transform.scale(
                    self.initial_image if not self.solved else self.final_image,
                    (scaled_width, scaled_height)
                )
                scaled_rect = scaled_image.get_rect(center=self.rect.center)
                
                if self.solved:
                    self.draw_with_border(screen, scaled_image, scaled_rect)
                else:
                    screen.blit(scaled_image, scaled_rect)
            else:
                if self.solved:
                    self.draw_with_border(screen, self.final_image, self.rect)
                    
                    if self.victory_glow:
                        elapsed = pygame.time.get_ticks() - self.victory_glow_start
                        progress = elapsed / self.victory_glow_duration
                        glow_alpha = int(255 * (1 - progress))
                        
                        glow_size = int(20 * (1 + progress))
                        glow_surface = pygame.Surface(
                            (self.rect.width + glow_size * 2, 
                             self.rect.height + glow_size * 2), 
                            pygame.SRCALPHA
                        )
                        
                        for i in range(3):
                            current_alpha = min(255, glow_alpha // (i + 1))
                            pygame.draw.rect(
                                glow_surface,
                                (*self.victory_glow_color, current_alpha),
                                (i * 5, i * 5, 
                                 glow_surface.get_width() - i * 10,
                                 glow_surface.get_height() - i * 10),
                                border_radius=10
                            )
                        
                        glow_rect = glow_surface.get_rect(center=self.rect.center)
                        screen.blit(glow_surface, glow_rect)
                else:
                    screen.blit(self.initial_image, self.rect)

# Programming quiz questions
questions = [
    ("What keyword is used to define a function in Python?", "def"),
    ("What built-in Python function is used to get the length of a list?", "len"),
    ("What data type is used to store whole numbers?", "integer"),
    ("What method is used to add an item to the end of a list?", "append"),
    ("Which operator is used for exponentiation?", "**"),
    ("What function prints text to the screen?", "print"),
    ("What is the result of 10 // 3?", "3"),
    ("Which data type represents decimal numbers?", "float"),
    ("Which Python data type is an ordered, immutable sequence of characters?", "string"),
    ("What keyword is used to define a class in Python?", "class"),
    ("What method converts a string to lowercase?", "lower"),
    ("What is the boolean value for an empty list?", "false"),
    ("What function returns the absolute value of a number?", "abs"),
    ("What method removes whitespace from both ends of a string?", "strip"),
    ("What operator is used for string concatenation?", "+"),
    ("What keyword is used to exit a loop prematurely?", "break"),
    ("What method splits a string into a list?", "split"),
    ("What is the result of type([]) in Python?", "list"),
    ("What method returns a sorted version of a list?", "sorted"),
    ("What function converts a string to an integer?", "int"),
    ("What symbol starts a single-line comment in Python?", "#"),
    ("What method checks if a string contains only digits?", "isdigit"),
    ("What operator checks if two values are identical in memory?", "is"),
    ("What method converts all string characters to uppercase?", "upper"),
    ("What keyword is used to handle exceptions?", "try"),
    ("What method removes an item from a list by index?", "pop"),
    ("What function returns the maximum value in an iterable?", "max"),
    ("What method joins list elements into a string?", "join"),
    ("What keyword creates a function that yields values?", "yield"),
    ("What built-in function reverses an iterator?", "reversed"),
    ("What method checks if a string starts with a substring?", "startswith"),
    ("What function returns a random float between 0 and 1?", "random"),
    ("What keyword is used to import specific items from a module?", "from"),
    ("What method returns the index of an item in a list?", "index"),
    ("What function creates a range of numbers?", "range"),
    ("What method checks if a string ends with a substring?", "endswith"),
    ("What operator unpacks an iterable into individual elements?", "*"),
    ("What function returns the sum of an iterable?", "sum"),
    ("What method counts occurrences in a string or list?", "count"),
]

def main():
    def restart_game():
        nonlocal tiles, timer, feedback, user_input, selected_tile, answer_input
        nonlocal end_game_started, final_answer, final_answer_correct, game_complete
        nonlocal blank_spaces, questions_copy

        questions_copy = questions.copy()
        random.shuffle(questions_copy)
        tiles = [Tile(SCREEN_WIDTH // 2 - 300 + i % 3 * 220, 
                     SCREEN_HEIGHT // 2 - 250 + i // 3 * 220, i + 1) for i in range(9)]
        timer = Timer(180)
        user_input = ""
        selected_tile = None
        answer_input = ""
        end_game_started = False
        final_answer = ""
        final_answer_correct = False
        game_complete = False
        blank_spaces = ["_"] * 6

        feedback.show_gif('welcome', 5000)  # Increased duration
        feedback.show_gif('instructions', 5000)  # Increased duration

    # Initialize game state
    questions_copy = questions.copy()
    random.shuffle(questions_copy)
    tiles = [Tile(SCREEN_WIDTH // 2 - 300 + i % 3 * 220, 
                  SCREEN_HEIGHT // 2 - 250 + i // 3 * 220, i + 1) for i in range(9)]
    
    timer = Timer(180)
    feedback = FeedbackSystem()
    
    user_input = ""
    selected_tile = None
    answer_input = ""
    end_game_started = False
    final_answer = ""
    final_answer_correct = False
    game_complete = False
    blank_spaces = ["_"] * 6
    correct_word = "PYTHON"
    restart_pending = False
    restart_time = 0
    
    feedback.show_gif('welcome', 5000)  # Increased duration
    feedback.show_gif('instructions', 5000)  # Increased duration

    running = True
    clock = pygame.time.Clock()
    
    while running:
        clock.tick(60)
        current_time = pygame.time.get_ticks()
        screen.blit(background_img, (0, 0))
        timer.draw(screen, game_font)
        
        if timer.is_finished() and not game_complete:
            game_complete = True
            feedback.show_gif('lost', 5000)  # Increased duration
            restart_pending = True
            restart_time = current_time + 5000  # Set restart timer after lost animation

        if restart_pending and current_time >= restart_time:
            restart_game()
            restart_pending = False
        
        if timer.should_show_warning():
            feedback.show_gif('time', 5000)  # Increased duration

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                
            if event.type == pygame.KEYDOWN:
                if not end_game_started and not timer.is_finished():
                    if event.key == pygame.K_RETURN:
                        if not selected_tile:
                            if user_input.isdigit() and 1 <= int(user_input) <= 9:
                                tile_num = int(user_input)
                                if questions_copy:
                                    for tile in tiles:
                                        if tile.number == tile_num and not tile.solved:
                                            selected_tile = tile
                                            tile.start_press_animation()
                                            tile.question, tile.answer = questions_copy.pop()
                                            break
                                user_input = ""
                        else:
                            if answer_input.lower() == "jessica" or answer_input.lower() == selected_tile.answer.lower():
                                selected_tile.solved = True
                                selected_tile.start_victory_glow()
                                selected_tile.question_ready = False
                                selected_tile = None
                                answer_input = ""
                                
                                unsolved_count = sum(1 for tile in tiles if not tile.solved)
                                if unsolved_count == 6:
                                    feedback.show_gif('6initial', 5000)
                                elif unsolved_count == 3:
                                    feedback.show_gif('3initial', 5000)
                                elif unsolved_count == 0:
                                    feedback.show_gif('decode', 5000)
                                    end_game_started = True
                            else:
                                selected_tile.start_wrong_flash()
                                selected_tile.question_ready = False
                                selected_tile = None
                                answer_input = ""
                    elif event.key == pygame.K_BACKSPACE:
                        if selected_tile and selected_tile.question_ready:
                            answer_input = answer_input[:-1]
                        else:
                            user_input = user_input[:-1]
                    elif event.unicode.isprintable():
                        if selected_tile and selected_tile.question_ready:
                            test_text = answer_input + event.unicode 
                            test_surface = game_font_small.render(test_text, True, (0, 0, 0))
                            if test_surface.get_width() <= 360:
                                answer_input += event.unicode
                        else:
                            user_input += event.unicode
                elif not game_complete:
                    if event.key == pygame.K_RETURN:
                        if final_answer.upper() == correct_word:
                            final_answer_correct = True
                            game_complete = True
                            feedback.show_gif('win', 5000)
                        else:
                            for tile in tiles:
                                tile.start_wrong_flash()
                            final_answer = ""
                            blank_spaces = ["_"] * 6
                    elif event.key == pygame.K_BACKSPACE:
                        if final_answer:
                            final_answer = final_answer[:-1]
                            blank_spaces[len(final_answer)] = "_"
                    elif event.unicode.isalpha() and len(final_answer) < 6:
                        final_answer += event.unicode.upper()
                        blank_spaces[len(final_answer)-1] = event.unicode.upper()

        # Draw game state
        if not end_game_started:
            show_other_tiles = not (selected_tile and selected_tile.question_ready)
            
            for tile in tiles:
                tile.update()
                if selected_tile and selected_tile.question_ready:
                    if tile == selected_tile:
                        tile.show_in_question_phase = True
                    else:
                        tile.show_in_question_phase = False
                else:
                    tile.show_in_question_phase = True
                tile.draw()

            if not selected_tile or not selected_tile.question_ready:
                prompt_surface = game_font.render("Enter a number (1-9):", True, WHITE)
                prompt_rect = prompt_surface.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 350))
                screen.blit(prompt_surface, prompt_rect)

                input_surface = game_font.render(user_input, True, WHITE)
                input_rect = input_surface.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 300))
                screen.blit(input_surface, input_rect)

            if selected_tile and selected_tile.question_ready:
                words = selected_tile.question.split()
                lines = []
                current_line = []
                for word in words:
                    current_line.append(word)
                    if len(' '.join(current_line)) > 40:
                        lines.append(' '.join(current_line[:-1]))
                        current_line = [word]
                if current_line:
                    lines.append(' '.join(current_line))

                y_offset = SCREEN_HEIGHT // 2 - 250
                for line in lines:
                    question_surface = game_font_small.render(line, True, WHITE)
                    question_rect = question_surface.get_rect(center=(SCREEN_WIDTH // 2, y_offset))
                    screen.blit(question_surface, question_rect)
                    y_offset += 40

                textbox_width = 400
                textbox_height = 50
                textbox_x = SCREEN_WIDTH // 2 - textbox_width // 2
                textbox_y = SCREEN_HEIGHT // 2 + 30
                
                textbox_surface = pygame.Surface((textbox_width, textbox_height), pygame.SRCALPHA)
                pygame.draw.rect(textbox_surface, (255, 255, 255, 128),
                               (0, 0, textbox_width, textbox_height),
                               border_radius=10)
                pygame.draw.rect(textbox_surface, (0, 0, 139, 255),
                               (0, 0, textbox_width, textbox_height),
                               width=2, border_radius=10)
                
                screen.blit(textbox_surface, (textbox_x, textbox_y))

                answer_surface = game_font_small.render(answer_input, True, WHITE)
                answer_rect = answer_surface.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 50))
                screen.blit(answer_surface, answer_rect)

        else:
            # Final game sequence
            if not final_answer_correct:
                prompt_surface = game_font_medium.render("Decode the picture!", True, WHITE)
                prompt_rect = prompt_surface.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 200))  # Moved higher
                screen.blit(prompt_surface, prompt_rect)

                # Draw complete Python image in the middle
                python_rect = complete_python_img.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2))
                border_rect = python_rect.inflate(8, 8)
                pygame.draw.rect(screen, GOLD, border_rect, border_radius=10)
                screen.blit(complete_python_img, python_rect)

                # Draw blank spaces lower
                blank_surface = game_font_large.render(" ".join(blank_spaces), True, WHITE)
                blank_rect = blank_surface.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 + 200))  # Moved lower
                screen.blit(blank_surface, blank_rect)
            else:
                win_surface = game_font_large.render("Congratulations!", True, WHITE)
                win_rect = win_surface.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT // 2 - 100))
                screen.blit(win_surface, win_rect)

        # Draw wrong answer flash over entire screen
        if any(tile.flash_wrong for tile in tiles):
            flash_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            flash_surface.fill(RED)
            max_alpha = max(int(255 * (1 - (pygame.time.get_ticks() - tile.flash_wrong_start) / tile.flash_duration)) 
                          for tile in tiles if tile.flash_wrong)
            flash_surface.set_alpha(max_alpha)
            screen.blit(flash_surface, (0, 0))

        # Update feedback system
        feedback.update(screen)
        
        pygame.display.flip()

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()

================
File: Archive/NEW_Level_Data.py
================
def reset_level(level):
    levels = {
        1: [
            [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 8, 1],
            [1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 2, 0, 0, 0, 0, 0, 2, 2, 1],
            [1, 0, 0, 0, 2, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 1, 1, 1],
            [1, 0, 0, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
            [1, 2, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        ],
        # Add more levels here if needed
    }
    
    return levels.get(level, [])

# In your main game code
world_data = reset_level(current_level)
world = World(world_data)

================
File: Archive/Wordle.py
================
import pygame
import random

# Initialize Pygame
pygame.init()

# Constants
SCREEN_WIDTH = 1000
SCREEN_HEIGHT = 1000
GRID_SIZE = 6  # Number of guesses
WORD_LENGTH = 5  # Length of the word
FONT_SIZE = 60
BOX_SIZE = 85  # Size of each letter box
BOX_SPACING = 15  # Space between boxes
BOX_BORDER_RADIUS = 5  # Rounded corners for boxes

# Colors
BACKGROUND_COLOR = (18, 18, 19)  # Dark background like original Wordle
EMPTY_BOX_COLOR = (58, 58, 60)   # Dark gray for empty boxes
BORDER_COLOR = (58, 58, 60)      # Border color for empty boxes
FILLED_BOX_COLOR = (58, 58, 60)  # Color for filled but unsubmitted boxes
GREEN = (83, 141, 78)   # Correct letter, correct position
YELLOW = (181, 159, 59) # Correct letter, wrong position
GRAY = (58, 58, 60)     # Wrong letter
TEXT_COLOR = (255, 255, 255)  # White text
TITLE_COLOR = (255, 255, 255) # White title

# Load a list of words
word_list = [
    "ARRAY", "CLASS", "DEBUG", "ERROR", "FLOAT", 
    "INPUT", "LOGIC", "LOOPS", "QUEUE", "STACK",
    "PARSE", "PRINT", "PROXY", "QUERY", "RANGE",
    "SCOPE", "SHELL", "SLICE", "SWING", "TUPLE",
    "TYPES", "VALUE", "WHILE", "YIELD", "BREAK",
    "CATCH", "CONST", "EVENT", "FALSE", "FINAL",
    "FRAME", "INDEX", "LABEL", "MACRO", "MATCH",
    "MERGE", "NODES", "PIXEL", "POINT", "POWER",
    "REACT", "ROUTE", "SCALA", "SETUP", "SPLIT",
    "STATE", "SUPER", "TABLE", "TRACE", "VALID",
    "BLOCK", "CACHE", "CHAIN", "CHECK", "COUNT",
    "DELAY", "DRAFT", "EMPTY", "FETCH", "FLAGS",
    "FLASH", "GROUP", "GUARD", "HTTPS", "LEVEL",
    "LINKS", "MODEL", "NUMPY", "PATCH", "PAUSE",
    "PROTO", "RESET", "ROUND", "SCALE", "THROW"
]

def draw_title():
    """Draw the game title at the top of the screen."""
    title_surface = title_font.render("DeCoding Island", True, TITLE_COLOR)
    title_rect = title_surface.get_rect(center=(SCREEN_WIDTH // 2, 80))
    screen.blit(title_surface, title_rect)
    
    pygame.draw.line(screen, BORDER_COLOR, 
                    (SCREEN_WIDTH // 4, 130), 
                    (3 * SCREEN_WIDTH // 4, 130), 
                    2)

def draw_box(x, y, color, letter='', border_color=None):
    """Draw a single letter box with optional border and letter."""
    box_rect = pygame.Rect(x, y, BOX_SIZE, BOX_SIZE)
    pygame.draw.rect(screen, color, box_rect, border_radius=BOX_BORDER_RADIUS)
    
    if border_color:
        pygame.draw.rect(screen, border_color, box_rect, 3, border_radius=BOX_BORDER_RADIUS)
    
    if letter:
        text_surface = game_font.render(letter, True, TEXT_COLOR)
        text_rect = text_surface.get_rect(center=(x + BOX_SIZE // 2, y + BOX_SIZE // 2))
        screen.blit(text_surface, text_rect)

def draw_grid(guesses, current_guess):
    """Draw the grid of guesses and the current guess."""
    start_x = (SCREEN_WIDTH - (WORD_LENGTH * (BOX_SIZE + BOX_SPACING))) // 2
    start_y = 180
    
    for i in range(GRID_SIZE):
        for j in range(WORD_LENGTH):
            x = start_x + j * (BOX_SIZE + BOX_SPACING)
            y = start_y + i * (BOX_SIZE + BOX_SPACING)
            
            if i < len(guesses):
                letter = guesses[i][j]
                color = GRAY
                if letter in secret_word:
                    if letter == secret_word[j]:
                        color = GREEN
                    else:
                        color = YELLOW
                draw_box(x, y, color, letter)
            else:
                draw_box(x, y, BACKGROUND_COLOR, border_color=BORDER_COLOR)

    # Draw current guess
    current_row = len(guesses)
    if current_row < GRID_SIZE:
        for j in range(WORD_LENGTH):
            x = start_x + j * (BOX_SIZE + BOX_SPACING)
            y = start_y + current_row * (BOX_SIZE + BOX_SPACING)
            if j < len(current_guess):
                draw_box(x, y, FILLED_BOX_COLOR, current_guess[j])
            else:
                draw_box(x, y, BACKGROUND_COLOR, border_color=BORDER_COLOR)

def show_game_over_message(won):
    """Display game over message."""
    message = "You Won!" if won else f"Game Over! Word was: {secret_word}"
    text_surface = game_font.render(message, True, TEXT_COLOR)
    text_rect = text_surface.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 100))
    screen.blit(text_surface, text_rect)

def main():
    global secret_word, screen, game_font, title_font
    
    # Set up the screen
    screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
    pygame.display.set_caption("Wordle")
    
    # Fonts
    game_font = pygame.font.SysFont('Arial Bold', FONT_SIZE)
    title_font = pygame.font.SysFont('Arial Bold', 70)
    
    # Select a random word
    secret_word = random.choice(word_list)
    
    running = True
    guesses = []
    current_guess = ""
    game_over = False
    won = False
    
    while running:
        screen.fill(BACKGROUND_COLOR)
        draw_title()
        draw_grid(guesses, current_guess)
        
        if game_over:
            show_game_over_message(won)
            pygame.display.flip()
            pygame.time.wait(2000)  # Show result for 2 seconds
            return won

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                return False

            if event.type == pygame.KEYDOWN and not game_over:
                if event.key == pygame.K_RETURN and len(current_guess) == WORD_LENGTH:
                    guesses.append(current_guess)
                    if current_guess == secret_word:
                        game_over = True
                        won = True
                    elif len(guesses) >= GRID_SIZE:
                        game_over = True
                    current_guess = ""
                elif event.key == pygame.K_BACKSPACE:
                    current_guess = current_guess[:-1]
                elif len(current_guess) < WORD_LENGTH and event.unicode.isalpha():
                    current_guess += event.unicode.upper()

        pygame.display.flip()

    return won

if __name__ == "__main__":
    main()

================
File: Archive/FINAL_GAME2.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os
import time
import cv2
import numpy as np
import math

def load_minigame(level):
    """Load a minigame module when needed"""
    try:
        if level == 1:
            from mini_game1 import main  # Change to your actual game file/function
            return main()
        elif level == 2:
            from mini_game2 import main  # Change to your actual game file/function
            return main()
        elif level == 3:
            from mini_game3 import main  # Change to your actual game file/function
            return main()
        elif level == 4:
            from mini_game4 import main  # Change to your actual game file/function
            return main()
        elif level == 5:
            from mini_game5 import main  # Change to your actual game file/function
            return main()
    except ImportError as e:
        print(f"Warning: Could not load minigame {level}: {e}")
        return False
    return False


# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Set the desired resolution
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Decoding Island')

# Update these constants at the top of your file
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.17  # Reduced from 0.45
JUMP_SPEED = -7  # Reduced from -13
MOVE_SPEED = 3  # Reduced from 5
game_over = 0
current_level = 0  # 0 for start screen, 1-5 for levels
keys_collected = 0
game_start_time = None
level_times = []
dialogue_states = {}


# You may need to adjust other elements (buttons, player size, etc.) to fit the new resolution
# For example:
# start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
# restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Define colors
WHITE = (255, 255, 255)
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)

# Load images
start_bg = pygame.image.load('img/background.png')
start_bg = pygame.transform.scale(start_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
start_btn = pygame.image.load('img/start_btn.png')
restart_img = pygame.image.load('img/restart_btn.png')
closeddoor_img = pygame.image.load('img/closeddoor.PNG')
opendoor_img = pygame.image.load('img/opendoor_img.PNG')
key_img = pygame.image.load('img/key.png')
npc_img = pygame.image.load('img/skeleton.png')
key_frames = []
target_size = (25, 25)  # Your desired size

# Append Keys
for i in range(1, 13):
    image = pygame.image.load(f'img/AnimatedKey_{i}.png')
    scaled_image = pygame.transform.scale(image, target_size)
    key_frames.append(scaled_image)

# Scale images
closeddoor_img = pygame.transform.scale(closeddoor_img, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
key_img = pygame.transform.scale(key_img, (10, 25 ))
npc_img = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2)))

# Load sounds
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

# Add new constant for blue platforms
LEVEL_BLUE_DATA = {
    0: [


    ],
    1: [

    ],
    2: [
        (23.2, 3.6, 3, 1.1),
        (26.4, 10.2, 4.8, 1.4),
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6),
    ],
    4: [
        (10, 23.4, 11.3, 1.3),
        (18.5, 23.4, 1, 7.6),
    ],
    5: [
        (26.2, 13.5, 1.7, 1.3),
        (26.4, 20, 4.8, 1.3),
        (19.6, 26.7, 5.3, 1.5),
        (41, 26.7, 5, 1.5),
        (31.1, 26.7, 3.3, 1.5),
    ]
}

# Level platform data (you'll need to adjust these coordinates based on your level designs)
LEVEL_PLATFORM_DATA = {
    0: [
            # Top platforms
            (5.2, 13.4, 6, 2.5),    
            (48, 13.4, 6, 2.5),   

            # small-top platform
            (13.3, 15.5, 1.4, 1.0), 
            (44.4, 15.5, 1.6, 1.0), 
            
            # semi-top platform
            (16.7, 16.6, 4.5, 1.0), 
            (38, 16.6, 4.5, 1.0), 

            # Middle platform
            (26.5, 18.3, 6.2, 2.5),  
            
            # Lower platforms
            (34.6, 23.2, 4.8, 2.5),
            (19.9, 23.2, 4.7, 2.5),
            
            # Bottom platforms
            (11.8, 28, 6.2, 2.5),
            (26.6, 28, 6.2, 2.5),
            (41.3, 28, 8, 1.),
            
            # Ground level
            (0, 33, 8, 3.0),
            (51, 33, 8.2, 3.0),
    ],
    1: [
            # 5th layer
            (23.1, 8.4, 4.8, 1.4),
            (44.5, 8.4, 4.8, 1.4),
            (15, 5.1, 6.2, 3),
            (0, 6.8, 9.8, 1.3),

            # 4th layer
            (28.1, 11.7, 6.4, 3),
            (51.2, 11.7, 6.3, 3),

            # 3rd layer
            (24.8, 15.5, 1.4, 1.7),
            (36.3, 16.6, 4.8, 1.3),
            (44.5, 16.6, 4.8, 1.3),

            # 2nd layer
            (51.1, 21.5, 6.4, 3),
            (36.3, 23.2, 6.4, 1),
            (18.3, 19.9, 9.6, 3),
            (31.3, 19.9, 3.3, 1.4),

            # Ground level
            (44.6, 26.4, 6.4, 3),
            (33, 29.7, 9.7, 3),
            (16.6, 28.1, 4.8, 1.4),
            (16.6, 34.7, 16, 12),

            # Ground Pillars
            (11.7, 23.2, 3.1, 12),
            (6.7, 26.4, 3.1, 9),
            (1.7, 29.8, 3.1, 6)
    ],
    2: [
            # 7th layer
            (13.5, 2, 7.6, 4),
            (10.1, 3.7, 3, 1),
            (0.3, 3.7, 4.6, 1),
            (5.2, 5.3, 1.3, 1),

            # 6th layer
            (51.3, 10.2, 7.5, 5.7),
            (5.2, 8.6, 4.6, 1),

            # 5th layer
            (43, 11.9, 6.3, 1),
            (11.8, 13.5, 4.6, 1),
            (0.2, 13.5, 4.6, 1),

            # 4th layer
            (31.7, 18.1, 1.8, 1.3),
            (42.3, 18.1, 1.8, 1.3),
            (33.3, 15.2, 9.2, 4),
            (0, 18.4, 9.5, 2.5),

            # 3rd layer
            (47.9, 20, 4.7, 1),
            (29.85, 20, 1.3, 1),
            (13.4, 21.7, 6.2, 1),
            (9.9, 20.1, 1.7, 1),

            # 2nd layer
            (48, 26.7, 6.2, 1),
            (41.4, 23.4, 4.6, 1),
            (26.7, 23.4, 7.6, 2.5),
            (7, 25, 14, 5),

            # Ground level
            (0.5, 28.4, 6.6, 8.0),
            (21, 28.4, 6.7, 8.0),
            (43.2, 31.7, 27, 5.0),

            # Ground Pillars
            (39.8, 31.7, 1.2, 3),
            (34.8, 31.7, 1.2, 3),
            (29.9, 31.7, 1.2, 3)
    ],
    3: [
            # 6th layer
            (3.5, 7, 6.2, 1),
            (0.3, 2, 4.3, 2.5),
            (20, 8.5, 3, 1),
            (46.4, 8.5, 11.4, 1),
            (57.8, 0.4, 1.3, 9),
            (29.9, 3.7, 9.5, 1),
            (48, 3.7, 4.6, 1),
            

            # 5th layer
            (26.4, 11.5, 2.8, 1.3),
            (25, 8.6, 1.4, 4.3),
            (11.5, 10.2, 5, 1),


            # 4th layer
            (18.1, 10.3, 1.7, 5.8),
            (7.1, 14.8, 10.9, 1.3),
            (31.5, 13.6, 3, 0.8),
            (36.5, 16.8, 7.8, 0.8),

            # 3rd layer
            (51.3, 20.1, 2.8, 5.7),
            (44.8, 20.1, 2.8, 5.7),
            (47.6, 24.8, 3.8, 1),
            (33.2, 23.4, 7.8, 1),
            (9.9, 25, 11.3, 1),
            (1.4, 20.1, 6.5, 5.8),
            (23.4, 18.5, 7.5, 4.2),
            (11.8, 21.8, 3, 0.8),
            (1.7, 13.6, 1.6, 1),
            (37.9, 11.9, 1.6, 1),
            (43, 10.3, 1.2, 2.7),
            (16.7, 13.5, 1.3, 1.3),
            

            # 2nd layer
            (34.8, 30, 2.9, 1),
            (26.7, 26.7, 5.9, 1),
            (31.3, 26.7, 1.4, 5.8),
            (23.6, 31.3, 7.7, 1.2),
            (10, 28.4, 4.8, 1),
            (21.6, 21.9, 1.4, 2.3),
            (19.8, 18.5, 1.6, 1),
            (8.3, 20, 1.6, 1),
            (0.1, 18.4, 1.6, 1),


            # Ground level
            (0.3, 35, 19, 6),
            (23.4, 35, 20.6, 6),
            (46.6, 35, 12.6, 6)
    ],
    4: [
            # 4th layer
            (33.2, 15.2, 7.8, 5.8),
            (31.3, 16.8, 2, 1),

            (6.8, 11.9, 5, 1),
            (10.2, 5.3, 3, 2.4),
            (15, 21.9, 1.2, 2),
            (13, 7, 1.8, 2.3),

            (19.9, 7, 1.2, 2.3),
            (21.4, 5.2, 1.3, 11),
            (22.6, 7, 1.8, 1),
            (11.9, 5.3, 1.1, 10.9),
            (13, 14.9, 8.4, 1.3),
            (16.4, 8.5, 1.7, 1),
            (14.9, 11.9, 5, 1),

            (24.8, 11.9, 3, 1),
            (46, 11.9, 5, 1),
            (44.4, 16.8, 6.6, 1),

            (51, 20, 8, 1),
            (38.1, 0, 1.3, 8),
            (39.3, 6.8, 6.3, 1.2),
            (39.3, 3.5, 1.7, 1),



            # 3rd layer
            (8.5, 21.8, 1.5, 1),
            (21.2, 21.8, 1.5, 1),
            (16.9, 29.5, 1.6, 1.5),
            (19.4, 29.5, 1.6, 1.5),
            (26.4, 20, 1.8, 1),
            (29.4, 20, 1.8, 1),
            (28.2, 15.2, 1.2, 9.3),
            (26.4, 23.4, 1.8, 1),
            (29.4, 23.4, 3.3, 1),
            

            # 2nd layer
            (6.9, 28.3, 4.3, 1),
            (1.7, 25, 6.3, 1),
            (0, 20, 8, 1),
            (0, 15.1, 5, 1),
            (11.9, 26.7, 1.3, 6),
            (13, 31.2, 1.3, 1.4),
            (11.9, 26.6, 6.7, 1),
            (23, 26.7, 5, 1),
            (33, 26.7, 3, 1),
            (39, 38.2, 5, 1),
            (29.8, 30, 3, 1),
            (56, 30, 3, 1),
            (41, 23.4, 5, 1),
            (52.9, 33.1, 2.9, 4),
            (38, 28.2, 5, 1),
            (46, 26.7, 6.7, 5.8),
            (44.7, 31.2, 1.5, 1.3),


            # Ground level
            (0, 33.3, 6.3, 6),
            (6.7, 34.9, 3, 6),
            (11.6, 34.9, 8.1, 6),
            (21.6, 34.9, 1.3, 6),
            (23, 33.2, 6.5, 0.9),
            (34.7, 33.3, 9.5, 6)
    ],
    5: [

            (0, 5.2, 9.5, 1),
            (0, 13.5, 11.4, 1),
            (0.2, 23.4, 1.1, 14),
            (3.5, 26.7, 1.4, 11),

            (6.8, 30, 3, 1),
            (6.7, 23.4, 3, 1),
            (10, 18.5, 4.6, 1),
            (10, 26.7, 8.2, 1.5),
            (26.3, 26.7, 5.3, 1.5),
            (36.1, 26.7, 3.7, 1.5), 

            (15, 13.5, 3, 1), 
            (18, 8.5, 5, 1),
            (49.3, 30, 3.3, 1.1), 
            (46, 23.3, 6.5, 1),
            (44.4, 18.5, 4.8, 1),

            (16.5, 20, 5, 1.3),
            (23, 20, 1.7, 1.3),
            (33, 20, 3.3, 1.3),
            (38, 20, 4.7, 1.3),
            (41.2, 13.5, 3.2, 1),
            (29.7, 7, 6.5, 1.1),
            (22.9, 7, 5, 1.2),

            (19.8, 13.5, 5, 1.3),
            (29.6, 13.5, 1.7, 1.3),
            (34.4, 13.5, 5.2, 1.3),
            (36.4, 8.5, 4.5, 1.2),
            (42.9, 5.3, 6.5, 1),
            (51, 15, 8, 1),

            (15.1, 26.8, 1, 8),
            (43.1, 26.8, 1, 8),
            (21.7, 13.6, 1.2, 7.7),
            (36.5, 13.6, 1.2, 7.7),
            (18.4, 20, 1, 8.1), 
            (39.9, 20, 1, 8.1),
            (25, 7, 1, 7.8),
            (33.3, 7, 1, 7.8),

            (54.5, 26.8, 1.2, 11),
            (57.9, 23.4, 1.2, 14),
            (51.3, 3.2, 1.5, 6.3),
            (53, 8.3, 4.4, 1.3),
            (57.6, 3.3, 1.5, 6),
            (54.3, 5, 1.7, 1.3),

            (28.2, 12, 1.2, 2.5), 
            (31.5, 18.5, 1.3, 2.5),
            (25, 25, 1, 3),
            (34.9, 31.7, 1, 3),
            (17.7, 31.5, 1.8, 1),

            (9.9, 33.2, 5, 1.3),
            (19.4, 33.2, 7.3, 1.3),
            (29.4, 33.2, 5.4, 1.3),
            (36, 33.2, 5.5, 1.3),
            (44, 33.2, 5.3, 1.3)
    ]
}

# 1. Fix the level_backgrounds initialization
level_backgrounds = {
    0: {'type': 'video', 'path': 'Level Data/Level Image/Level1_Background.mp4'},
    1: {'type': 'image', 'path': 'Level Data/Level Image/LEVEL1.png'},
    2: {'type': 'image', 'path': 'Level Data/Level Image/Level2game!.png'},
    3: {'type': 'image', 'path': 'Level Data/Level Image/Level3game!!.png'},
    4: {'type': 'image', 'path': 'Level Data/Level Image/Level4.png'},
    5: {'type': 'image', 'path': 'Level Data/Level Image/Level5.png'}
}

# Initialize video capture and load images
background_surfaces = {}
video_captures = {}

for level, bg_data in level_backgrounds.items():
    if bg_data['type'] == 'video':
        try:
            video_captures[level] = cv2.VideoCapture(bg_data['path'])
        except Exception as e:
            print(f"Error loading video for level {level}: {e}")
            # Fallback to a solid color or default image
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))
    else:
        try:
            img = pygame.image.load(bg_data['path']).convert()
            background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except Exception as e:
            print(f"Error loading image for level {level}: {e}")
            # Fallback to a solid color
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))

# Update collision tile creation (in World class):
def __init__(self, level_data, deadly_data):
    self.collision_tiles = []
    self.deadly_tiles = []

    for plat in level_data:
        # Adjust coordinates to align with background
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        height = int(plat[3] * TILE_SIZE)
        
        # Add small margin for better collision
        margin = 2
        collision_rect = pygame.Rect(
            x + margin,
            y + margin,
            width - margin * 2,
            height - margin * 2
        )
        self.collision_tiles.append(CollisionTile(x, y, width, height))

    for deadly in deadly_data:
        x = deadly[0] * TILE_SIZE
        y = deadly[1] * TILE_SIZE
        width = deadly[2] * TILE_SIZE
        height = int(deadly[3] * TILE_SIZE)
        
        # Add similar margin for deadly tiles
        margin = 2
        self.deadly_tiles.append(CollisionTile(
            x + margin, 
            y + margin, 
            width - margin * 2, 
            height - margin * 2
        ))

    
# Add Level 0 to LEVEL_REQUIREMENTS
LEVEL_REQUIREMENTS = {
    0: 3,  # For tutorial level
    1: 4,
    2: 5,
    3: 6,
    4: 8,
    5: 10
}

# Update STORYLINE dictionary to match story document
STORYLINE = {
    "intro": [
        "You remember the moment you stumbled upon the ancient artifact, half-buried in the basement of that old library.",
        "It was a stone box, covered in intricate, interlocking symbols that seemed to shift if you stared too long.",
        "As you worked, carefully pressing and turning parts of the stone, the symbols clicked into alignment.",
        "The box opened, releasing a chill that seeped straight to your bones.",
        "Inside was a brittle parchment with haunting words: 'Whoever unlocks these secrets is bound to us.'",
        "'Your presence is now required. The island awaits.'"
    ],
    "level0": [
        "The ghostly voice of Eralt lingers in the air as you begin.",
        '"Beware, young master. The island knows your fears, your weaknesses."',
        '"Solve the code, and move closer to your destiny."',
        '"Fail, and join the lost souls who could not decode the island\'s secrets."',
        '"Master?.." With your heart pounding, you take a deep breath and step forward,',
        "ready to solve the first of many mysteries in this shadowy realm."
    ],
    "level1": [
        "As you decipher the shifting symbols on the stone slab, a sudden flash of blinding light erupts.",
        "When it fades, a figure steps forward with silent, lethal grace.",
        "Dressed in dark, flowing robes and wielding twin daggers that glint in the moonlight,",
        "she introduces herself with a cold smile.",
        '"I am Palak, the Assassin, Guardian of the First Level."',
        '"To pass my challenge, you must prove you can see through deception and lies."',
        '"Codes are more than wordsthey\'re veils of truth and deceit. Decipher mine, or face the consequences."'
    ],
    "level2": [
        "The mist pulls you forward to a spiraling tower covered in ancient runes.",
        "At the top waits Russ, the Wizard. His eyes hold the gleam of forbidden knowledge.",
        '"Ah, the new champion has arrived."',
        "He gestures to a puzzle box floating in mid-air, surrounded by a shimmering aura.",
        '"This test is one of patience and intellect."',
        '"You must unlock this box without using brute force; the wrong twist will reset it."',
        '"Fail, and your mind will be trapped in an endless loop."'
    ],
    "level3": [
        "The scenery morphs into a grand, oppressive throne room.",
        "Seated on the throne is Geoff, the Autocrat, draped in black, a crown of thorns upon his brow.",
        '"So you\'ve passed the others. But codes are not just puzzles; they\'re tools of control, of power."',
        '"I rule through secrets."',
        "He gestures to an enormous map with encrypted marks scattered across it.",
        '"Your task is to decipher the locations on this map."',
        '"Fail, and you will be exiled into the barren lands."'
    ],
    "level4": [
        "The shadows deepen, and you're surrounded by a ghostly fog.",
        "From it, a figure in tattered, ethereal robes emergesJessica, the Wraith.",
        "Her eyes glow with an eerie, otherworldly light as she glides toward you.",
        '"You are brave, but bravery means nothing in the face of fear."',
        '"This trial is not of logic, but of your darkest nightmares."',
        "A mirror appears, showing twisted images of your deepest fears.",
        '"Face your fears, or be lost to them forever."'
    ],
    "level5": [
        "You arrive at a shadowy castle ruin where the final guardian awaits: Jacobo, the Undead King.",
        "His skeletal form radiates an unholy power, and his hollow eyes burn with a fierce light.",
        '"You stand before the final trial, mortal."',
        '"I am Jacobo, the Undead King, master of the lost and forgotten."',
        '"To claim victory, you must decipher the oldest code of all,"',
        '"the language of life and death itself."'
    ],
    "ending": [
        "The tome releases a blinding light. When it fades, you're back on the beach.",
        "The island seems quiet, as if holding its breath. But something is differentyou can feel it.",
        "As you touch the sand, it shifts, forming into a new message:",
        '"Congratulations, you have proven yourself. But know this:"',
        '"The title of decoding master is not a prize, but a burden."',
        '"The codes you hold now contain secrets that even the spirits dare not speak."',
        '"Guard them well, for they will change everything."'
    ]
}

# Update LEVEL_DIALOGUES dictionary to add Level 0
LEVEL_DIALOGUES = {
    0: [
        "Tutorial Level: Learning the Basics",
        "Master the art of movement and key collection.",
        "Collect 3 keys to proceed to your first real challenge.",
        "Press SPACE to continue..."
    ],
    1: [
        "Level 1: The Assassin's Trial",
        "Find 4 keys while avoiding deadly traps.",
        "Press SPACE to continue..."
    ],
    2: [
        "Level 2: The Wizard's Tower",
        "Collect 5 keys hidden by magical illusions.",
        "Press SPACE to continue..."
    ],
    3: [
        "Level 3: The Autocrat's Domain",
        "Gather 6 keys from this sprawling fortress.",
        "Press SPACE to continue..."
    ],
    4: [
        "Level 4: The Wraith's Nightmare",
        "Find 8 keys in this realm of shadows.",
        "Press SPACE to continue..."
    ],
    5: [
        "Final Level: The Undead King's Castle",
        "Collect all 10 keys to complete your journey.",
        "Press SPACE to continue..."
    ]
}

LEVEL_DEADLY_DATA = {
    0: [

        
    ],
    1: [
        
    ],
    2: [
        (23.2, 3.6, 3, 1),
        (26.4, 10.2, 4.8, 1.3),
        (28, 34, 15, 1)
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6),
    ],
    4: [
        (10, 22.4, 11.3, 1.3),
        (22, 13.8, 2, 2),
        (20, 22.4, 2.4, 2),
    ],
    5: [
        (0.2, 34, 59, 4),
        (15.4, 28, 2.2, 3),
        (22, 25.4, 2, 2),
        (25, 12, 2.4, 2.7),
        (28.4, 18.7, 2.4, 2.3),
        (31.8, 25.2,  2.3, 2),
        (26.9, 32, 2, 2),
        (40.2, 25.3, 2, 2),
        (41.7, 30.3, 2, 2),
    ]
}

# Update LEVEL_ENEMY_DATA to include boundary information:
LEVEL_ENEMY_DATA = {
    0: [

        
    ],
    1: [
        (17, 33.4, "horizontal", 17, 32),
        (0.2, 5.5, "horizontal", 0.2, 8.5),
        (36.2, 22, "horizontal", 36.2, 41.2),
        (50.5, 10.6, "horizontal", 50.5, 56),    # x, y, direction, boundary_start, boundary_end
        (18.5, 19, "horizontal", 18.5, 27.2)  # x, y, direction, boundary_start, boundary_end
    ],
    2: [
        (8.5, 24, "horizontal", 8.5, 20),
        (0.2, 17.2, "horizontal", 0.2, 8.7),
        (44.5, 30.5, "horizontal", 44, 58.5),
        (35, 14, "horizontal", 35, 41),
        (52.3, 9.1, "horizontal", 52.3, 58.5),
        
    ],
    3: [
        (10.5, 24, "horizontal", 10.5, 20.5),
        (24, 34, "horizontal", 24, 43),
        (18, 13.6, "horizontal", 18, 26.5),
        (30, 3.6, "horizontal", 30, 38.5),
        (48, 6.4, "horizontal", 48, 57),
        (37.5, 15.8, "horizontal", 37.5, 43.5),
    ],
    4: [

    ],
    5: [

    ]
}

class DialogueBox:
    def __init__(self, screen):
        self.screen = screen
        self.animation_complete = False
        self.current_alpha = 0
        self.target_alpha = 230
        self.fade_speed = 10
        self.current_line = 0
        self.current_word = 0
        self.current_char = 0
        self.text_delay = 2  # Controls typing speed
        self.frame_counter = 0
        self.words_revealed = []  # List to store revealed words for each line
        
    def animate(self, dialogue_lines):
        # Create semi-transparent background
        dialogue_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        dialogue_surface.fill(BLACK)
        
        # Animate fade in
        if self.current_alpha < self.target_alpha:
            self.current_alpha = min(self.current_alpha + self.fade_speed, self.target_alpha)
        dialogue_surface.set_alpha(self.current_alpha)
        self.screen.blit(dialogue_surface, (0, 0))
        
        # Initialize words_revealed list if needed
        if not self.words_revealed:
            self.words_revealed = [[] for _ in dialogue_lines]
        
        # Calculate text position for centering
        total_height = len(dialogue_lines) * 60
        start_y = (SCREEN_HEIGHT - total_height) // 2
        
        # Update text animation
        self.frame_counter += 1
        if self.frame_counter >= self.text_delay:
            self.frame_counter = 0
            self.update_text(dialogue_lines)
        
        # Draw text
        for i, line in enumerate(dialogue_lines):
            # Split line into words
            words = line.split()
            revealed_text = ' '.join(self.words_revealed[i])
            
            text_surface = pygame.font.SysFont('Bauhaus 93', 40).render(
                revealed_text, True, WHITE)
            text_rect = text_surface.get_rect(center=(SCREEN_WIDTH // 2, start_y + i * 60))
            self.screen.blit(text_surface, text_rect)
        
        # Add "Press SPACE to continue" prompt when animation is complete
        if self.animation_complete:
            prompt = pygame.font.SysFont('Bauhaus 93', 30).render(
                "Press SPACE to continue...", True, (200, 200, 200))
            prompt_rect = prompt.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
            self.screen.blit(prompt, prompt_rect)
        
        return self.animation_complete
    
    def update_text(self, dialogue_lines):
        if self.current_line < len(dialogue_lines):
            words = dialogue_lines[self.current_line].split()
            
            if self.current_word < len(words):
                # Add next word
                self.words_revealed[self.current_line].append(words[self.current_word])
                self.current_word += 1
            else:
                # Move to next line
                self.current_line += 1
                self.current_word = 0
        else:
            self.animation_complete = True

# Update the show_dialogue function to properly handle space key:
def show_dialogue(dialogue_lines):
    dialogue_box = DialogueBox(screen)
    
    waiting = True
    space_pressed = False
    
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                    return True  # Always return True when space is pressed
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

class Ghost(pygame.sprite.Sprite):
    def __init__(self, screen_width, screen_height, player, level):
        super().__init__()
        # Load and scale ghost image
        self.image = pygame.image.load('img/ghost.png').convert_alpha()  # Added convert_alpha for better transparency
        # Make ghost slightly larger for better visibility
        self.image = pygame.transform.scale(self.image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 1.5)))
        self.rect = self.image.get_rect()
        
        # Ghost properties
        self.base_speed = 2.0  # Increased base speed
        self.level_speed_multiplier = 0.4  # Increased speed multiplier per level
        self.speed = self.base_speed + (level * self.level_speed_multiplier)
        self.player = player
        
        # Set initial position (farthest point from player)
        self.spawn_position(screen_width, screen_height)
        
        # Floating movement properties
        self.float_offset = 0
        self.float_speed = 0.05
        self.float_amplitude = 8  # Increased floating amplitude
        self.true_x = float(self.rect.x)
        self.true_y = float(self.rect.y)
        
        # Set minimum alpha for better visibility
        self.min_alpha = 120  # Increased minimum transparency
        
        # Add pulsing effect
        self.pulse_counter = 0
        self.pulse_speed = 0.05
        self.pulse_range = 40  # Range of alpha pulsing

    def spawn_position(self, screen_width, screen_height):
        """Spawn ghost at the farthest point from player"""
        # Get possible corner positions
        corners = [
            (0, 0),  # Top-left
            (screen_width - self.rect.width, 0),  # Top-right
            (0, screen_height - self.rect.height),  # Bottom-left
            (screen_width - self.rect.width, screen_height - self.rect.height)  # Bottom-right
        ]
        
        # Find the farthest corner from player
        max_distance = 0
        spawn_pos = corners[0]
        
        for corner in corners:
            distance = math.sqrt(
                (corner[0] - self.player.rect.x) ** 2 + 
                (corner[1] - self.player.rect.y) ** 2
            )
            if distance > max_distance:
                max_distance = distance
                spawn_pos = corner
        
        self.rect.x = spawn_pos[0]
        self.rect.y = spawn_pos[1]
        self.true_x = float(self.rect.x)
        self.true_y = float(self.rect.y)

    def update(self):
        # Only update if movement is enabled and not during door zoom
        if not movement_enabled or camera.door_zoom:
            return
            
        # Calculate direction to player
        dx = self.player.rect.centerx - self.rect.centerx
        dy = self.player.rect.centery - self.rect.centery
        
        # Normalize the direction
        distance = math.sqrt(dx ** 2 + dy ** 2)
        if distance > 0:
            dx = dx / distance
            dy = dy / distance
        
        # Update position with original tracking
        distance_factor = min(1.5, distance / 400)  # Keep original distance factor
        actual_speed = self.speed * distance_factor
        
        self.true_x += dx * actual_speed
        self.true_y += dy * actual_speed
        
        # Add floating movement
        self.float_offset += self.float_speed
        float_y = math.sin(self.float_offset) * self.float_amplitude
        
        # Update rect position
        self.rect.x = int(self.true_x)
        self.rect.y = int(self.true_y + float_y)
        
        # Update pulsing effect
        self.pulse_counter += self.pulse_speed
        pulse_alpha = math.sin(self.pulse_counter) * self.pulse_range
        
        # Calculate base alpha based on distance
        max_distance = 600  # Increased visibility range
        current_distance = math.sqrt(
            (self.player.rect.centerx - self.rect.centerx) ** 2 + 
            (self.player.rect.centery - self.rect.centery) ** 2
        )
        
        # Calculate alpha with pulsing effect
        base_alpha = max(self.min_alpha, min(255, (1 - current_distance / max_distance) * 255))
        final_alpha = min(255, max(self.min_alpha, base_alpha + pulse_alpha))
        
        # Create a copy of the image for alpha changes
        self.image.set_alpha(int(final_alpha))

    def check_collision(self, player):
        """Check for collision with player using a slightly smaller collision box"""
        collision_margin = 8  # Slightly reduced margin for more accurate collisions
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Camera:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.scroll_x = 0
        self.scroll_y = 0
        self.zoom = 1
        self.target_zoom = 1
        self.base_zoom = 2.5
        self.zoom_out_level = 1.3
        self.zoom_speed = 0.04
        self.transitioning = False
        self.transition_start_time = 0
        self.transition_delay = 2000
        self.transition_duration = 2000
        self.transition_total_time = self.transition_delay + self.transition_duration
        self.transition_complete = False
        self.manual_zoom_active = False
        self.initial_zoom_done = False
        
        # Door zoom properties
        self.door_zoom = False
        self.door_zoom_target = None
        self.door_zoom_speed = 0.02
        self.door_target_zoom = 3.5
        self.door_transition_start = 0
        self.door_transition_duration = 1500
        self.post_open_delay = 1000
        self.door_opened_time = 0
        self.reset_on_death = False
        self.death_reset_time = 0
        self.death_reset_duration = 1000  # 1 second for reset animation
        
        # Sound properties
        self.wind_sound = pygame.mixer.Sound('img/Gust of Wind.mp3')
        self.jungle_music = pygame.mixer.Sound('img/Background Music.MP3')
        self.zoom_out_sound = pygame.mixer.Sound('img/zoom_out.mp3')  # Add this line
        self.wind_sound.set_volume(0.8)
        self.jungle_music.set_volume(0.4)
        self.zoom_out_sound.set_volume(0.5)  # Add this line
        self.wind_sound_playing = False
        self.jungle_music_playing = False
        self.wind_sound_start_time = 0
        self.wind_sound_duration = int(self.wind_sound.get_length() * 1000)
        
        self.visible_width = width
        self.visible_height = height

    def reset_zoom(self):
        """Reset camera zoom when player dies"""
        self.reset_on_death = True
        self.death_reset_time = pygame.time.get_ticks()
        self.zoom = self.base_zoom
        self.target_zoom = self.base_zoom
        self.manual_zoom_active = False
        self.door_zoom = False
        self.door_zoom_target = None
        self.transitioning = False
        self.initial_zoom_done = True

    def start_door_zoom(self, door):
        if not self.door_zoom and not self.manual_zoom_active:
            self.door_zoom = True
            self.door_zoom_target = door
            self.door_transition_start = pygame.time.get_ticks()
            self.door_target_zoom = 3.5
            # All entities will freeze due to the door_zoom check in their update methods
        
    def start_transition(self):
        # Stop any existing sounds before starting new ones
        self.stop_sounds()
        self.transitioning = True
        self.transition_complete = False
        self.zoom = 1
        self.transition_start_time = pygame.time.get_ticks()
        
        # Start wind sound and track its start time
        self.wind_sound.play()
        self.wind_sound_playing = True
        self.wind_sound_start_time = pygame.time.get_ticks()
        self.jungle_music_playing = False
    
    def update(self, target, keys_collected, door, required_keys):
        current_time = pygame.time.get_ticks()
        
        # Handle manual zoom control with Enter key
        keys = pygame.key.get_pressed()
        if keys[pygame.K_RETURN]:
            self.manual_zoom_active = True
            self.target_zoom = self.zoom_out_level
            self.zoom_out_sound.play()
        elif self.manual_zoom_active:
            self.manual_zoom_active = False
            self.target_zoom = self.base_zoom if self.transition_complete else 1
        
        # Handle initial transition
        if self.transitioning and not self.initial_zoom_done:
            elapsed = current_time - self.transition_start_time
            
            if elapsed >= self.transition_delay:
                zoom_elapsed = elapsed - self.transition_delay
                progress = min(zoom_elapsed / self.transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                if not self.manual_zoom_active:
                    self.zoom = 1 + (self.base_zoom - 1) * progress
                
                if progress >= 1:
                    self.transitioning = False
                    self.transition_complete = True
                    self.initial_zoom_done = True
                    if not self.manual_zoom_active:
                        self.zoom = self.base_zoom
                        self.target_zoom = self.base_zoom
        
        # Handle smooth zoom transition
        elif not self.door_zoom:
            if self.zoom != self.target_zoom:
                diff = self.target_zoom - self.zoom
                self.zoom += diff * self.zoom_speed
        
        # Handle door zoom if active
        if self.door_zoom and self.door_zoom_target:
            elapsed = current_time - self.door_transition_start
            
            if not self.door_zoom_target.is_open:
                progress = min(elapsed / self.door_transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                self.zoom = 1 + (self.door_target_zoom - 1) * progress
                
                # Calculate center position for the door
                target_x = self.door_zoom_target.rect.centerx - (SCREEN_WIDTH // (2 * self.zoom))
                target_y = self.door_zoom_target.rect.centery - (SCREEN_HEIGHT // (2 * self.zoom))
                
                # Smoothly move camera to center the door
                self.scroll_x += (target_x - self.scroll_x) * 0.1
                self.scroll_y += (target_y - self.scroll_y) * 0.1
                
                if progress >= 1.0:
                    self.door_zoom_target.open_door()
                    self.door_opened_time = current_time
            else:
                hold_time = current_time - self.door_opened_time
                if hold_time >= self.post_open_delay:
                    zoom_out_progress = min((hold_time - self.post_open_delay) / 1000, 1.0)
                    zoom_out_progress = self.ease_out_cubic(zoom_out_progress)
                    
                    target_zoom = self.target_zoom
                    self.zoom = self.door_target_zoom - (self.door_target_zoom - target_zoom) * zoom_out_progress
                    
                    if zoom_out_progress >= 1.0:
                        self.door_zoom = False
                        self.zoom = target_zoom
        
        # Handle death reset
        if self.reset_on_death:
            elapsed = current_time - self.death_reset_time
            if elapsed <= self.death_reset_duration:
                # Smoothly transition zoom back to base level
                progress = elapsed / self.death_reset_duration
                progress = self.ease_out_cubic(progress)
                self.zoom = 1 + (self.base_zoom - 1) * progress
            else:
                self.reset_on_death = False
                self.zoom = self.base_zoom
                self.target_zoom = self.base_zoom
        
        # Update sound behavior
        if (self.wind_sound_playing and 
            current_time - self.wind_sound_start_time >= self.wind_sound_duration and 
            not self.jungle_music_playing):
            self.wind_sound_playing = False
            self.jungle_music.play()
            self.jungle_music_playing = True
        
        # Update visible area and camera position
        self.visible_width = self.width // self.zoom
        self.visible_height = self.height // self.zoom
        
        # Normal camera follow behavior when not zooming to door
        if not self.door_zoom:
            target_x = target.rect.centerx - self.visible_width // 2
            target_y = target.rect.centery - self.visible_height // 2
            
            self.scroll_x += (target_x - self.scroll_x) * 0.1
            self.scroll_y += (target_y - self.scroll_y) * 0.1
        
        # Keep the camera within bounds
        self.scroll_x = max(0, min(self.scroll_x, SCREEN_WIDTH - self.visible_width))
        self.scroll_y = max(0, min(self.scroll_y, SCREEN_HEIGHT - self.visible_height))
    
    def stop_sounds(self):
        """Stop all sounds and reset sound states"""
        try:
            if pygame.mixer.get_init():  # Check if mixer is initialized
                self.wind_sound.stop()
                self.jungle_music.stop()
                self.zoom_out_sound.stop()  # Add this line
        except (AttributeError, pygame.error):
            pass
        self.wind_sound_playing = False
        self.jungle_music_playing = False

        
    # Update the Camera class cleanup method:
    def cleanup(self):
        """Clean up all audio resources and reset camera state"""
        self.stop_sounds()
        self.transitioning = False
        self.transition_complete = False
        self.zoom = 1
        self.wind_sound_start_time = 0
        self.door_zoom = False
        self.door_zoom_target = None
        
    def __del__(self):
        """Destructor to ensure sounds are stopped when the camera object is destroyed"""
        try:
            self.stop_sounds()
        except:
            pass  # Ignore any errors during cleanup

    def ease_out_cubic(self, x):
        return 1 - pow(1 - x, 3)

    def apply(self, surface, entity):
        return pygame.Rect(
            entity.rect.x - self.scroll_x,
            entity.rect.y - self.scroll_y,
            entity.rect.width,
            entity.rect.height
        )

    def apply_sprite(self, surface, sprite):
        # Return the position where the sprite should be drawn
        return (sprite.rect.x - self.scroll_x,
                sprite.rect.y - self.scroll_y)
                
    def apply_rect(self, rect):
        # Apply camera offset to a rect
        return pygame.Rect(
            rect.x - self.scroll_x,
            rect.y - self.scroll_y,
            rect.width,
            rect.height
        )

# Update the video background handling code
def update_video_background(level):
    """Update video frame for video backgrounds"""
    if level in video_captures and video_captures[level] is not None:
        ret, frame = video_captures[level].read()
        if not ret:
            # Reset video to beginning if we've reached the end
            video_captures[level].set(cv2.CAP_PROP_POS_FRAMES, 0)
            ret, frame = video_captures[level].read()
        
        if ret:
            # Convert frame from BGR to RGB and flip to match Pygame's format
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame = cv2.resize(frame, (SCREEN_WIDTH, SCREEN_HEIGHT))
            frame = np.rot90(frame)
            frame = np.flipud(frame)
            frame = pygame.surfarray.make_surface(frame)
            return frame
    return None

# Update the initialization of video captures
# Initialize game assets
def init_game():
    """Initialize video captures and background surfaces"""
    global video_captures, background_surfaces
    video_captures = {}
    background_surfaces = {}
    
    for level, bg_data in level_backgrounds.items():
        if bg_data['type'] == 'video':
            try:
                cap = cv2.VideoCapture(bg_data['path'])
                if not cap.isOpened():
                    print(f"Failed to open video file for level {level}")
                    cap = None
                video_captures[level] = cap
            except Exception as e:
                print(f"Error loading video for level {level}: {e}")
                video_captures[level] = None
        else:
            try:
                img = pygame.image.load(bg_data['path']).convert()
                background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
            except Exception as e:
                print(f"Error loading image for level {level}: {e}")
                fallback = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
                fallback.fill((0, 0, 0))
                background_surfaces[level] = fallback

def get_background(level):
    """Get the current background surface for the given level"""
    if level_backgrounds[level]['type'] == 'video':
        return update_video_background(level)
    else:
        return background_surfaces[level]

# Update the cleanup function
def cleanup_backgrounds():
    """Release all video captures properly"""
    global video_captures
    if 'video_captures' in globals():
        for cap in video_captures.values():
            if cap is not None:
                cap.release()
        video_captures.clear()


# Update create_zoomed_view function to include ghost
def create_zoomed_view(screen, camera, player, world, keys_group, door, npc, moving_enemies, ghost):
    current_visible_width = int(SCREEN_WIDTH // camera.zoom)
    current_visible_height = int(SCREEN_HEIGHT // camera.zoom)
    
    view_surface = pygame.Surface((current_visible_width, current_visible_height))
    
    # Get and draw the current background
    current_background = get_background(current_level)
    if current_background:
        view_surface.blit(current_background, (-camera.scroll_x, -camera.scroll_y))
    
    # Draw all game objects on the zoomed surface
    for key in keys_group:
        pos = camera.apply_sprite(view_surface, key)
        if (0 <= pos[0] < current_visible_width and 
            0 <= pos[1] < current_visible_height):
            view_surface.blit(key.image, pos)
    
    # Draw door and NPC
    door_pos = camera.apply_sprite(view_surface, door)
    npc_pos = camera.apply_sprite(view_surface, npc)
    if (0 <= door_pos[0] < current_visible_width and 
        0 <= door_pos[1] < current_visible_height):
        view_surface.blit(door.image, door_pos)
    if (0 <= npc_pos[0] < current_visible_width and 
        0 <= npc_pos[1] < current_visible_height):
        view_surface.blit(npc.image, npc_pos)
    
    # Draw ghost
    ghost_pos = camera.apply_sprite(view_surface, ghost)
    if (0 <= ghost_pos[0] < current_visible_width and 
        0 <= ghost_pos[1] < current_visible_height):
        view_surface.blit(ghost.image, ghost_pos)
    
    # Draw enemies
    for enemy in moving_enemies:
        enemy_pos = camera.apply_sprite(view_surface, enemy)
        if (0 <= enemy_pos[0] < current_visible_width and 
            0 <= enemy_pos[1] < current_visible_height):
            view_surface.blit(enemy.image, enemy_pos)
    
    # Draw player
    player_pos = camera.apply_sprite(view_surface, player)
    if (0 <= player_pos[0] < current_visible_width and 
        0 <= player_pos[1] < current_visible_height):
        view_surface.blit(player.image, player_pos)
    
    # Scale the view surface to fill the screen
    scaled_surface = pygame.transform.scale(view_surface, (SCREEN_WIDTH, SCREEN_HEIGHT))
    screen.blit(scaled_surface, (0, 0))
    
    # Draw HUD elements
    draw_text(f"Level {current_level}", 40, WHITE, 10, 10)
    draw_text(f"Keys: {keys_collected}/{LEVEL_REQUIREMENTS[current_level]}", 40, WHITE, 10, 60)

    
class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Key(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.frames = key_frames  # Use the key_frames list we created earlier
        
        # Animation variables
        self.current_frame = 0
        self.animation_timer = 0
        self.animation_delay = 100  # Milliseconds between frame changes
        
        # Set initial image
        self.image = self.frames[self.current_frame] if self.frames else key_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        
        # Floating movement variables
        self.original_y = float(y)
        self.float_offset = 0
        self.float_speed = 0.03  # Slightly slower float speed
        
    def update(self):
        if self.frames:  # Only animate if we have frames
            # Update animation frame
            current_time = pygame.time.get_ticks()
            if current_time - self.animation_timer > self.animation_delay:
                self.animation_timer = current_time
                self.current_frame = (self.current_frame + 1) % len(self.frames)
                self.image = self.frames[self.current_frame]
        
        # Update floating movement with reduced amplitude (changed from 15 to 5)
        self.float_offset += self.float_speed
        self.rect.y = self.original_y + math.sin(self.float_offset) * 5  # Reduced from 15 to 5

# In the Door class, update the open_door method to handle the image transition properly:
class Door:
    def __init__(self, x, y):
        super().__init__()
        self.closed_image = pygame.image.load('img/closeddoor.PNG')
        self.open_image = pygame.image.load('img/opendoor_img.PNG')
        self.closed_image = pygame.transform.scale(self.closed_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
        self.open_image = pygame.transform.scale(self.open_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
        self.image = self.closed_image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.is_open = False
        self.door_sound = pygame.mixer.Sound('img/door_sound.MP3')
        self.door_sound.set_volume(0.5)
        self.sound_played = False
        self.collision_enabled = True
        self.entered = False  # Add this new property

    def open_door(self):
        if not self.is_open:
            self.image = self.open_image
            self.is_open = True
            self.collision_enabled = False
            if not self.sound_played:
                self.door_sound.play()
                self.sound_played = True

    def open_door(self):
        if not self.is_open:
            self.image = self.open_image
            self.is_open = True
            self.collision_enabled = False  # Disable collision when door is open
            if not self.sound_played:
                self.door_sound.play()
                self.sound_played = True

class NPC(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = npc_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y


class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2))
        
        # Load animations
        for i in range(1, 5):
            img = pygame.image.load(f'img/dino{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        # Load sound effects
        self.walking_sound = pygame.mixer.Sound('img/Character Walking.MP3')
        self.walking_sound.set_volume(0.5)
        self.is_walking_sound_playing = False
        
        self.key_collect_sound = pygame.mixer.Sound('img/key_collect.mp3')
        self.key_collect_sound.set_volume(0.4)
        
        self.falling_sound = pygame.mixer.Sound('img/falling_character.mp3')
        self.falling_sound.set_volume(2)
        self.is_falling_sound_playing = False
        self.falling_threshold = 10  # Number of frames to trigger falling sound
        self.falling_counter = 0
        
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, player_size)
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def stop_sounds(self):
        """Stop all player sounds"""
        if self.is_walking_sound_playing:
            self.walking_sound.stop()
            self.is_walking_sound_playing = False
        if self.is_falling_sound_playing:
            self.falling_sound.stop()
            self.is_falling_sound_playing = False

    def cleanup(self):
        """Clean up player resources"""
        self.stop_sounds()
        self.is_walking_sound_playing = False
        self.is_falling_sound_playing = False
        self.falling_counter = 0

    def __del__(self):
        """Ensure sounds are stopped when player object is destroyed"""
        self.stop_sounds()

    def update(self, game_over, world, keys_group, camera):
        global keys_collected
        dx = 0
        dy = 0
        walk_cooldown = 5
        
        if game_over == -1:
            # Handle death state
            if not hasattr(self, '_death_handled'):
                camera.reset_zoom()  # Reset camera when player dies
                self._death_handled = True
                self.stop_sounds()
            self.image = self.dead_image
            if self.rect.y > 200:
                self.rect.y -= 5
            return game_over
            
        # Reset death handling flag when game is restarted
        self._death_handled = False
        
        # Normal movement code here
        if camera.transition_complete:
            key = pygame.key.get_pressed()
            
            # Handle walking sound
            is_moving = False
            
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
                # Reset falling counter when jumping
                self.falling_counter = 0
                if self.is_falling_sound_playing:
                    self.falling_sound.stop()
                    self.is_falling_sound_playing = False
            
            if not key[pygame.K_SPACE]:
                self.jumped = False

            # Check for movement keys and play sound
            if key[pygame.K_LEFT] or key[pygame.K_a]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
                is_moving = True
            if key[pygame.K_RIGHT] or key[pygame.K_d]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
                is_moving = True
            
            # Handle walking sound
            if is_moving and not self.in_air and not self.is_walking_sound_playing:
                self.walking_sound.play(-1)
                self.is_walking_sound_playing = True
            elif (not is_moving or self.in_air) and self.is_walking_sound_playing:
                self.walking_sound.stop()
                self.is_walking_sound_playing = False

            if not (key[pygame.K_LEFT] or key[pygame.K_RIGHT] or key[pygame.K_a] or key[pygame.K_d]):
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

        # Always apply gravity regardless of camera state
        self.vel_y += GRAVITY
        if self.vel_y > 10:
            self.vel_y = 10
        dy += self.vel_y

        if not movement_enabled or camera.door_zoom:
            return game_over
        
        # Handle falling sound
        if self.in_air and self.vel_y > 0:  # If falling
            self.falling_counter += 1
            if self.falling_counter >= self.falling_threshold and not self.is_falling_sound_playing:
                self.falling_sound.play()
                self.is_falling_sound_playing = True
        elif not self.in_air:  # When landing
            self.falling_counter = 0
            if self.is_falling_sound_playing:
                self.falling_sound.stop()
                self.is_falling_sound_playing = False

        # Check for collision with keys
        key_hits = pygame.sprite.spritecollide(self, keys_group, True)
        if key_hits:
            self.key_collect_sound.play()
            keys_collected += len(key_hits)

        # Assume we're in the air unless collision detection proves otherwise
        self.in_air = True

        # Check for collision
        result = world.check_collision(self, dx, dy)
        if result == "deadly":
            return -1  # Return game over state
        else:
            dx, dy = result

        # Update player position
        self.rect.x += dx
        self.rect.y += dy

        # Keep player on screen
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH:
            self.rect.right = SCREEN_WIDTH
            
        # Check if player has fallen off the map
        if self.rect.top > SCREEN_HEIGHT:
            return -1  # Return game over state
            
        return game_over

class World:
    def __init__(self, level_data, deadly_data):
        self.collision_tiles = []
        self.deadly_tiles = []
        self.blue_tiles = []  # Initialize blue_tiles list

        # Create collision tiles
        for plat in level_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            
            offset_x = 0
            offset_y = 0
            
            collision_rect = pygame.Rect(
                x + offset_x,
                y + offset_y,
                width,
                height
            )
            self.collision_tiles.append(CollisionTile(x + offset_x, y + offset_y, width, height))

        # Create deadly tiles
        for deadly in deadly_data:
            x = deadly[0] * TILE_SIZE
            y = deadly[1] * TILE_SIZE
            width = deadly[2] * TILE_SIZE
            height = int(deadly[3] * TILE_SIZE)
            
            self.deadly_tiles.append(CollisionTile(x, y, width, height))

        # Create blue tiles
        if current_level in LEVEL_BLUE_DATA:
            for blue in LEVEL_BLUE_DATA[current_level]:
                x = blue[0] * TILE_SIZE
                y = blue[1] * TILE_SIZE
                width = blue[2] * TILE_SIZE
                height = int(blue[3] * TILE_SIZE)
                
                self.blue_tiles.append(CollisionTile(x, y, width, height))

                '''    def draw(self, screen):
                        # Draw regular collision tiles in red
                        for tile in self.collision_tiles:
                            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)
                        
                        # Draw deadly tiles in green
                        for tile in self.deadly_tiles:
                            pygame.draw.rect(screen, (0, 255, 0), tile.rect, 2)
                        
                        # Draw blue tiles in blue
                        for tile in self.blue_tiles:
                            pygame.draw.rect(screen, (0, 0, 255), tile.rect, 1)'''

    def check_collision(self, player, dx, dy):
        # Check collision with both regular and blue tiles
        for tile in self.collision_tiles + self.blue_tiles:
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False
                    
        # Check deadly collisions
        for tile in self.deadly_tiles:
            if tile.rect.colliderect(player.rect):
                return "deadly"
                
        return dx, dy

def init_level(level_num):
    global keys_collected, game_start_time, current_level, player, camera, ghost, movement_enabled
    
    # Initialize variables first
    keys_collected = 0
    current_level = level_num
    
    if game_start_time is None:
        game_start_time = time.time()
    
    # Reset movement state
    movement_enabled = False
    
    # Clean up previous player if it exists
    if 'player' in globals():
        player.cleanup()
    
    # Reset camera state
    camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
    camera.transitioning = False
    camera.transition_complete = False
    camera.manual_zoom_active = False
    camera.door_zoom = False
    camera.door_zoom_target = None
    camera.reset_on_death = False
    
    if game_start_time is None:
        game_start_time = time.time()
    
    # Initialize level objects
    keys_group = pygame.sprite.Group()
    key_positions = generate_key_positions(level_num)
    for pos in key_positions:
        adjusted_y = pos[1] + TILE_SIZE - 20
        keys_group.add(Key(pos[0], adjusted_y))

    platforms = LEVEL_PLATFORM_DATA[level_num]
    suitable_platform = find_suitable_platform(platforms)
    platform_x = suitable_platform[0]
    platform_y = suitable_platform[1]
    platform_width = suitable_platform[2]
    
    door_x = (platform_x + platform_width - 2) * TILE_SIZE
    door_y = (platform_y - 2) * TILE_SIZE
    
    if door_x > SCREEN_WIDTH - 3 * TILE_SIZE:
        door_x = SCREEN_WIDTH - 3 * TILE_SIZE
    
    door = Door(door_x, door_y)
    npc = NPC(door_x - TILE_SIZE * 2, door_y)
    
    deadly_tiles = LEVEL_DEADLY_DATA[level_num]
    world = World(platforms, deadly_tiles)
    
    # Set player spawn position
    spawn_x = 100
    spawn_y = 0
    
    # Find suitable ground platform for spawning
    ground_platforms = []
    for plat in platforms:
        if plat[1] > (SCREEN_HEIGHT / TILE_SIZE) * 0.7:  # Ground level platforms
            ground_platforms.append(plat)
    
    if ground_platforms:
        leftmost = sorted(ground_platforms, key=lambda p: p[0])[0]
        spawn_x = (leftmost[0] + 1) * TILE_SIZE
        # Adjust spawn height to be just above the platform
        player_height = int(TILE_SIZE * 1.2)  # Match the player's size
        spawn_y = (leftmost[1] * TILE_SIZE) - player_height
    
    # Create player first
    player = Player(spawn_x, spawn_y)
    
    # Create ghost after player
    ghost = Ghost(SCREEN_WIDTH, SCREEN_HEIGHT, player, level_num)
    
    # Initialize moving enemies
    moving_enemies = pygame.sprite.Group()
    for enemy_data in LEVEL_ENEMY_DATA[level_num]:
        x, y, direction, boundary_start, boundary_end = enemy_data
        enemy = MovingEnemy(x, y, direction, boundary_start, boundary_end)
        moving_enemies.add(enemy)
    
    return keys_group, door, npc, world, moving_enemies, player, ghost


class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(npc_img, (int(TILE_SIZE * 0.8), int(TILE_SIZE * 0.8)))
        self.rect = self.image.get_rect()
        self.rect.x = x * TILE_SIZE
        self.rect.y = y * TILE_SIZE
        self.direction = direction
        self.speed = 1.2  # Reduced from 2
        self.moving_right = True
        self.moving_down = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE
        self.initial_pos = self.rect.x if direction == "horizontal" else self.rect.y

    def update(self):
        # Only update if movement is enabled and not during door zoom
        if not movement_enabled or camera.door_zoom:
            return
            
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)
        else:  # vertical movement
            if self.moving_down:
                self.rect.y += self.speed
                if self.rect.y >= self.boundary_end:
                    self.moving_down = False
            else:
                self.rect.y -= self.speed
                if self.rect.y <= self.boundary_start:
                    self.moving_down = True

    def draw_boundaries(self, screen):
        # Draw movement boundaries (for debugging)
        if self.direction == "horizontal":
            pygame.draw.line(screen, (255, 0, 0),
                           (self.boundary_start, self.rect.centery),
                           (self.boundary_end, self.rect.centery), 2)
        else:
            pygame.draw.line(screen, (255, 0, 0),
                           (self.rect.centerx, self.boundary_start),
                           (self.rect.centerx, self.boundary_end), 2)

    def check_collision(self, player):
        # Create a slightly smaller collision rect for more forgiving collisions
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button:
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self, screen):
        action = False
        # Get mouse position
        pos = pygame.mouse.get_pos()  # This gets the (x, y) position of the mouse

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and not self.clicked:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font_size, color, x, y):
    font = pygame.font.SysFont('Bauhaus 93', font_size)
    img = font.render(text, True, color)
    screen.blit(img, (x, y))

# Update the show_dialogue function:
def show_dialogue(dialogue_lines):
    dialogue_box = DialogueBox(screen)
    
    waiting = True
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

def find_suitable_platform(platforms):
    """
    Find a suitable platform for door placement using better criteria:
    1. Platform must be wide enough for door and NPC
    2. Platform should be reasonably high up but not necessarily the highest
    3. Platform should have enough space above it
    """
    # Sort platforms by height (y-coordinate), from top to bottom
    sorted_platforms = sorted(platforms, key=lambda p: p[1])
    
    # Required width for door and NPC (in tile units)
    required_width = 4  # Space for door and NPC
    
    # Check top 1/3 of platforms for a suitable spot
    top_third = len(sorted_platforms) // 3
    if top_third < 1:
        top_third = 1
    
    for platform in sorted_platforms[:top_third]:
        # Get platform dimensions
        x, y, width, height = platform
        
        # Check if platform is wide enough
        if width >= required_width:
            # Check if there's another platform directly above
            has_obstruction = False
            platform_top = y
            platform_left = x
            platform_right = x + width
            
            # Check for obstructions above
            for other_platform in platforms:
                other_x, other_y, other_width, other_height = other_platform
                other_left = other_x
                other_right = other_x + other_width
                other_bottom = other_y + other_height
                
                # Check if there's a platform directly above
                if (other_bottom > platform_top - 4 and  # Leave space for door height
                    other_y < platform_top and
                    other_right > platform_left and
                    other_left < platform_right):
                    has_obstruction = True
                    break
            
            if not has_obstruction:
                return platform
                
    # Fallback to the widest platform in the top half if no perfect match
    top_half = sorted_platforms[:len(sorted_platforms)//2]
    widest_platform = max(top_half, key=lambda p: p[2])
    return widest_platform

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    deadly_tiles = LEVEL_DEADLY_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Function to check if position is safe from deadly tiles
    def is_safe_position(x, y):
        SAFE_DISTANCE = TILE_SIZE * 3  # Minimum distance from deadly tiles
        
        for deadly in deadly_tiles:
            deadly_x = deadly[0] * TILE_SIZE
            deadly_y = deadly[1] * TILE_SIZE
            deadly_width = deadly[2] * TILE_SIZE
            deadly_height = deadly[3] * TILE_SIZE
            
            # Calculate boundaries of the deadly area with safety margin
            deadly_left = deadly_x - SAFE_DISTANCE
            deadly_right = deadly_x + deadly_width + SAFE_DISTANCE
            deadly_top = deadly_y - SAFE_DISTANCE
            deadly_bottom = deadly_y + deadly_height + SAFE_DISTANCE
            
            # Check if key position is within the danger zone
            if (deadly_left < x < deadly_right and 
                deadly_top < y < deadly_bottom):
                return False
        return True
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    attempts = 0
    max_attempts = 100  # Prevent infinite loop
    
    while len(positions) < required_keys and attempts < max_attempts:
        for plat in viable_platforms:
            if len(positions) >= required_keys:
                break
                
            # Try multiple positions on each platform
            for _ in range(5):  # Try 5 times per platform
                # Place key somewhere along the platform
                key_x = plat[0] + random.uniform(TILE_SIZE, plat[2] - TILE_SIZE * 2)
                key_y = plat[1] - TILE_SIZE * 1.5
                
                # Only add position if it's safe
                if is_safe_position(key_x, key_y):
                    positions.append((key_x, key_y))
                    break
            
            attempts += 1
    
    # If we couldn't find enough safe positions, fill remaining with positions farther from platforms
    while len(positions) < required_keys:
        plat = random.choice(viable_platforms)
        key_x = plat[0] + random.uniform(TILE_SIZE * 2, plat[2] - TILE_SIZE * 2)
        key_y = plat[1] - TILE_SIZE * 2  # Place keys higher above platform
        if is_safe_position(key_x, key_y):
            positions.append((key_x, key_y))
    
    return positions

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    
    for i in range(min(required_keys, len(viable_platforms))):
        plat = viable_platforms[i]
        # Place key somewhere along the platform
        key_x = plat[0] + random.uniform(0, plat[2] - TILE_SIZE)
        key_y = plat[1] - TILE_SIZE * 1.5  # Place key above platform
        positions.append((key_x, key_y))
    
    return positions

# Initialize game objects
start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)
camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
player = Player(100, SCREEN_HEIGHT - 130)
world = World(LEVEL_PLATFORM_DATA[1], LEVEL_DEADLY_DATA[1])
moving_enemies = pygame.sprite.Group()
keys_group = pygame.sprite.Group()
game_over = 0
current_state = "start_screen"
movement_enabled = False 

# Initialize game resources
init_game()

# Game loop
clock = pygame.time.Clock()
fps = 60
running = True

while running:
    clock.tick(fps)
    
    # Single event handling section
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                running = False
                break

    if not running:
        break
        
    # State updates based on current_state
    if current_state == "start_screen":
        screen.blit(start_bg, (0, 0))
        current_state = "intro_dialogue"
        
    elif current_state == "intro_dialogue":
        if show_dialogue(STORYLINE["intro"]) and show_dialogue(STORYLINE["level0"]):
            current_state = "playing"
            current_level = 0
            keys_group, door, npc, world, moving_enemies, player, ghost = init_level(current_level)
        else:
            current_state = "playing"
            current_level = 0
            keys_group, door, npc, world, moving_enemies, player, ghost = init_level(current_level)
            
    elif current_state == "playing":
        # Handle dialogue states
        storyline_key = f'storyline_{current_level}'
        level_key = f'level_{current_level}'
        
        if not dialogue_states.get(storyline_key, False):
            if show_dialogue(STORYLINE[f"level{current_level}"]):
                dialogue_states[storyline_key] = True
                
        elif not dialogue_states.get(level_key, False):
            if show_dialogue(LEVEL_DIALOGUES[current_level]):
                dialogue_states[level_key] = True
                camera.start_transition()
        
        # Enable movement when camera transition is complete
        if camera.transition_complete and not movement_enabled:
            movement_enabled = True  # This ensures movement is enabled after transitions
        
        # Update game objects only when movement is enabled
        if movement_enabled:
            # Game updates
            camera.update(player, keys_collected, door, LEVEL_REQUIREMENTS[current_level])
            
            if not camera.door_zoom:
                # Update entities only when not zooming to door
                ghost.update()
                moving_enemies.update()
                game_over = player.update(game_over, world, keys_group, camera)
                
                # Check collisions
                if ghost.check_collision(player):
                    game_over = -1
                    game_over_fx.play()
                
                for enemy in moving_enemies:
                    if enemy.check_collision(player):
                        game_over = -1
                        game_over_fx.play()
                        break
        
        # Always update these regardless of movement state
        keys_group.update()
        camera.update(player, keys_collected, door, LEVEL_REQUIREMENTS[current_level])
        create_zoomed_view(screen, camera, player, world, keys_group, door, npc, moving_enemies, ghost)
        
        # Handle collisions and game over
        if game_over == 0:
            # Check deadly collisions
            deadly_collision = world.check_collision(player, 0, 0)
            if deadly_collision == "deadly":
                game_over = -1
                game_over_fx.play()
            
            # Update game objects
            game_over = player.update(game_over, world, keys_group, camera)
            moving_enemies.update()
            keys_group.update()  # Add this line to animate the keys
            
            # Check enemy collisions
            for enemy in moving_enemies:
                if enemy.check_collision(player):
                    game_over = -1
                    game_over_fx.play()
                    break
                    
            # Level completion
            if keys_collected >= LEVEL_REQUIREMENTS[current_level]:
                if not door.is_open:
                    camera.start_door_zoom(door)
                elif pygame.sprite.collide_rect(player, door):
                    door.entered = True
                    camera.stop_sounds()
                    
                    if current_level == 0:
                        # Tutorial completion
                        if door.entered and show_dialogue([
                            "Tutorial Complete! ",
                            "You've mastered the basics! ",
                            "Press SPACE to begin your real journey..."
                        ]):
                            current_level = 1
                            storyline_key = f'storyline_{current_level}'
                            level_key = f'level_{current_level}'
                            dialogue_states[storyline_key] = False
                            dialogue_states[level_key] = False
                            camera.cleanup()
                            if game_start_time:
                                elapsed_time = int(time.time() - game_start_time)
                                level_times.append(elapsed_time)
                            keys_group, door, npc, world, moving_enemies, player, ghost = init_level(current_level)  # Added ghost
                            camera.start_transition()
                    else:
                        # Regular level completion
                        if door.entered:
                            current_display = screen.copy()
                            camera.stop_sounds()
                            
                            if show_dialogue([
                                "To proceed to the next level,",
                                "you must complete the challenge! ",
                                "Press SPACE to begin..."
                            ]):
                                try:
                                    minigame_result = load_minigame(current_level)
                                    # And in the regular level completion section:
                                    if minigame_result:
                                        if current_level < 5:
                                            if show_dialogue([
                                                f"Level {current_level} Complete! ",
                                                "You've conquered both challenges! ",
                                                "Press SPACE to continue..."
                                            ]):
                                                current_level += 1
                                                storyline_key = f'storyline_{current_level}'
                                                level_key = f'level_{current_level}'
                                                dialogue_states[storyline_key] = False
                                                dialogue_states[level_key] = False
                                                camera.cleanup()
                                                if game_start_time:
                                                    elapsed_time = int(time.time() - game_start_time)
                                                    level_times.append(elapsed_time)
                                                keys_group, door, npc, world, moving_enemies, player, ghost = init_level(current_level)  # Added ghost
                                                camera.start_transition()
                                        else:
                                            camera.cleanup()
                                            if show_dialogue(STORYLINE["ending"]):
                                                current_state = "game_complete"
                                    else:
                                        if show_dialogue([
                                            "Challenge failed! ",
                                            "You must complete this trial to proceed. ",
                                            "Press SPACE to try again..."
                                        ]):
                                            screen.blit(current_display, (0,0))
                                            pygame.display.flip()
                                except Exception as e:
                                    print(f"Error running minigame {current_level}: {e}")
                                    if show_dialogue([
                                        "An error occurred! ",
                                        "Please try again. ",
                                        "Press SPACE to continue..."
                                    ]):
                                        screen.blit(current_display, (0,0))
                                        pygame.display.flip()
            pass
        else:
            # Game over state
            draw_text('GAME OVER!', 70, BLUE, (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
            if restart_button.draw(screen):
                # Properly reset all necessary variables
                game_over = 0
                keys_collected = 0
                
                # Stop any ongoing sounds
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                    
                # Reset camera state
                camera.cleanup()
                camera.reset_zoom()
                
                # Reinitialize level
                keys_group, door, npc, world, moving_enemies, player, ghost = init_level(current_level)
                
                # Ensure camera starts fresh
                camera.start_transition()
                
                
    elif current_state == "game_complete":
        screen.fill(BLACK)
        total_time = int(time.time() - game_start_time)
        minutes = total_time // 60
        seconds = total_time % 60
        
        draw_text("Congratulations!", 70, WHITE, SCREEN_WIDTH // 2 - 250, SCREEN_HEIGHT // 3)
        draw_text(f"You've completed Decoding Island!", 50, WHITE, SCREEN_WIDTH // 2 - 300, SCREEN_HEIGHT // 2)
        draw_text(f"Total Time: {minutes:02d}:{seconds:02d}", 50, WHITE, SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 100)
        
        if restart_button.draw(screen):
            current_state = "start_screen"
            game_start_time = None
            current_level = 0
            keys_collected = 0
            level_times = []
    
    pygame.display.update()

cleanup_backgrounds()
pygame.quit()

================
File: Archive/FINAL_GAME1.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os
import time
import cv2
import numpy as np

def load_minigame(level):
    """Load a minigame module when needed"""
    try:
        if level == 1:
            from mini_game1 import main  # Change to your actual game file/function
            return main()
        elif level == 2:
            from mini_game2 import main  # Change to your actual game file/function
            return main()
        elif level == 3:
            from mini_game3 import main  # Change to your actual game file/function
            return main()
        elif level == 4:
            from mini_game4 import main  # Change to your actual game file/function
            return main()
        elif level == 5:
            from mini_game5 import main  # Change to your actual game file/function
            return main()
    except ImportError as e:
        print(f"Warning: Could not load minigame {level}: {e}")
        return False
    return False


# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Set the desired resolution
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Decoding Island')

# Define tile size based on background height
TILE_SIZE = SCREEN_HEIGHT // 36  # 36 is the number of tiles vertically
GRAVITY = 0.79
JUMP_SPEED = -15
MOVE_SPEED = 7
game_over = 0
current_level = 0  # 0 for start screen, 1-5 for levels
keys_collected = 0
game_start_time = None
level_times = []
dialogue_states = {}


# You may need to adjust other elements (buttons, player size, etc.) to fit the new resolution
# For example:
# start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
# restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Define colors
WHITE = (255, 255, 255)
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)

# Load images
start_bg = pygame.image.load('img/background.png')
start_bg = pygame.transform.scale(start_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
start_btn = pygame.image.load('img/start_btn.png')
restart_img = pygame.image.load('img/restart_btn.png')
closeddoor_img = pygame.image.load('img/closeddoor.PNG')
opendoor_img = pygame.image.load('img/opendoor_img.PNG')
key_img = pygame.image.load('img/key.png')
npc_img = pygame.image.load('img/skeleton.png')

# Scale images
closeddoor_img = pygame.transform.scale(closeddoor_img, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
key_img = pygame.transform.scale(key_img, (10, 25 ))
npc_img = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2)))

# Load sounds
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

# Add new constant for blue platforms
LEVEL_BLUE_DATA = {
    0: [


    ],
    1: [

    ],
    2: [
        (23.2, 3.6, 3, 1.1),
        (26.4, 10.2, 4.8, 1.4),
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6),
    ],
    4: [
        (10, 23.4, 11.3, 1.3),
        (18.5, 23.4, 1, 7.6),
    ],
    5: [
        (26.2, 13.5, 1.7, 1.3),
        (26.4, 20, 4.8, 1.3),
        (19.6, 26.7, 5.3, 1.5),
        (41, 26.7, 5, 1.5),
        (31.1, 26.7, 3.3, 1.5),
    ]
}

# Level platform data (you'll need to adjust these coordinates based on your level designs)
LEVEL_PLATFORM_DATA = {
    0: [
            # Top platforms
            (5.2, 13.4, 6, 2.5),    
            (48, 13.4, 6, 2.5),   

            # small-top platform
            (13.3, 15.5, 1.4, 1.0), 
            (44.4, 15.5, 1.6, 1.0), 
            
            # semi-top platform
            (16.7, 16.6, 4.5, 1.0), 
            (38, 16.6, 4.5, 1.0), 

            # Middle platform
            (26.5, 18.3, 6.2, 2.5),  
            
            # Lower platforms
            (34.6, 23.2, 4.8, 2.5),
            (19.9, 23.2, 4.7, 2.5),
            
            # Bottom platforms
            (11.8, 28, 6.2, 2.5),
            (26.6, 28, 6.2, 2.5),
            (41.3, 28, 8, 1.),
            
            # Ground level
            (0, 33, 8, 3.0),
            (51, 33, 8.2, 3.0),
    ],
    1: [
            # 5th layer
            (23.1, 8.4, 4.8, 1.4),
            (44.5, 8.4, 4.8, 1.4),
            (15, 5.1, 6.2, 3),
            (0, 6.8, 9.8, 1.3),

            # 4th layer
            (28.1, 11.7, 6.4, 3),
            (51.2, 11.7, 6.3, 3),

            # 3rd layer
            (24.8, 15.5, 1.4, 1.7),
            (36.3, 16.6, 4.8, 1.3),
            (44.5, 16.6, 4.8, 1.3),

            # 2nd layer
            (51.1, 21.5, 6.4, 3),
            (36.3, 23.2, 6.4, 1),
            (18.3, 19.9, 9.6, 3),
            (31.3, 19.9, 3.3, 1.4),

            # Ground level
            (44.6, 26.4, 6.4, 3),
            (33, 29.7, 9.7, 3),
            (16.6, 28.1, 4.8, 1.4),
            (16.6, 34.7, 16, 12),

            # Ground Pillars
            (11.7, 23.2, 3.1, 12),
            (6.7, 26.4, 3.1, 9),
            (1.7, 29.8, 3.1, 6)
    ],
    2: [
            # 7th layer
            (13.5, 2, 7.6, 4),
            (10.1, 3.7, 3, 1),
            (0.3, 3.7, 4.6, 1),
            (5.2, 5.3, 1.3, 1),

            # 6th layer
            (51.3, 10.2, 7.5, 5.7),
            (5.2, 8.6, 4.6, 1),

            # 5th layer
            (43, 11.9, 6.3, 1),
            (11.8, 13.5, 4.6, 1),
            (0.2, 13.5, 4.6, 1),

            # 4th layer
            (31.7, 18.1, 1.8, 1.3),
            (42.3, 18.1, 1.8, 1.3),
            (33.3, 15.2, 9.2, 4),
            (0, 18.4, 9.5, 2.5),

            # 3rd layer
            (47.9, 20, 4.7, 1),
            (29.85, 20, 1.3, 1),
            (13.4, 21.7, 6.2, 1),
            (9.9, 20.1, 1.7, 1),

            # 2nd layer
            (48, 26.7, 6.2, 1),
            (41.4, 23.4, 4.6, 1),
            (26.7, 23.4, 7.6, 2.5),
            (7, 25, 14, 5),

            # Ground level
            (0.5, 28.4, 6.6, 8.0),
            (21, 28.4, 6.7, 8.0),
            (43.2, 31.7, 27, 5.0),

            # Ground Pillars
            (39.8, 31.7, 1.2, 3),
            (34.8, 31.7, 1.2, 3),
            (29.9, 31.7, 1.2, 3)
    ],
    3: [
            # 6th layer
            (3.5, 7, 6.2, 1),
            (0.3, 2, 4.3, 2.5),
            (20, 8.5, 3, 1),
            (46.4, 8.5, 11.4, 1),
            (57.8, 0.4, 1.3, 9),
            (29.9, 3.7, 9.5, 1),
            (48, 3.7, 4.6, 1),
            

            # 5th layer
            (26.4, 11.5, 2.8, 1.3),
            (25, 8.6, 1.4, 4.3),
            (11.5, 10.2, 5, 1),


            # 4th layer
            (18.1, 10.3, 1.7, 5.8),
            (7.1, 14.8, 10.9, 1.3),
            (31.5, 13.6, 3, 0.8),
            (36.5, 16.8, 7.8, 0.8),

            # 3rd layer
            (51.3, 20.1, 2.8, 5.7),
            (44.8, 20.1, 2.8, 5.7),
            (47.6, 24.8, 3.8, 1),
            (33.2, 23.4, 7.8, 1),
            (9.9, 25, 11.3, 1),
            (1.4, 20.1, 6.5, 5.8),
            (23.4, 18.5, 7.5, 4.2),
            (11.8, 21.8, 3, 0.8),
            (1.7, 13.6, 1.6, 1),
            (37.9, 11.9, 1.6, 1),
            (43, 10.3, 1.2, 2.7),
            (16.7, 13.5, 1.3, 1.3),
            

            # 2nd layer
            (34.8, 30, 2.9, 1),
            (26.7, 26.7, 5.9, 1),
            (31.3, 26.7, 1.4, 5.8),
            (23.6, 31.3, 7.7, 1.2),
            (10, 28.4, 4.8, 1),
            (21.6, 21.9, 1.4, 2.3),
            (19.8, 18.5, 1.6, 1),
            (8.3, 20, 1.6, 1),
            (0.1, 18.4, 1.6, 1),


            # Ground level
            (0.3, 35, 19, 6),
            (23.4, 35, 20.6, 6),
            (46.6, 35, 12.6, 6)
    ],
    4: [
            # 4th layer
            (33.2, 15.2, 7.8, 5.8),
            (31.3, 16.8, 2, 1),

            (6.8, 11.9, 5, 1),
            (10.2, 5.3, 3, 2.4),
            (15, 21.9, 1.2, 2),
            (13, 7, 1.8, 2.3),

            (19.9, 7, 1.2, 2.3),
            (21.4, 5.2, 1.3, 11),
            (22.6, 7, 1.8, 1),
            (11.9, 5.3, 1.1, 10.9),
            (13, 14.9, 8.4, 1.3),
            (16.4, 8.5, 1.7, 1),
            (14.9, 11.9, 5, 1),

            (24.8, 11.9, 3, 1),
            (46, 11.9, 5, 1),
            (44.4, 16.8, 6.6, 1),

            (51, 20, 8, 1),
            (38.1, 0, 1.3, 8),
            (39.3, 6.8, 6.3, 1.2),
            (39.3, 3.5, 1.7, 1),



            # 3rd layer
            (8.5, 21.8, 1.5, 1),
            (21.2, 21.8, 1.5, 1),
            (16.9, 29.5, 1.6, 1.5),
            (19.4, 29.5, 1.6, 1.5),
            (26.4, 20, 1.8, 1),
            (29.4, 20, 1.8, 1),
            (28.2, 15.2, 1.2, 9.3),
            (26.4, 23.4, 1.8, 1),
            (29.4, 23.4, 3.3, 1),
            

            # 2nd layer
            (6.9, 28.3, 4.3, 1),
            (1.7, 25, 6.3, 1),
            (0, 20, 8, 1),
            (0, 15.1, 5, 1),
            (11.9, 26.7, 1.3, 6),
            (13, 31.2, 1.3, 1.4),
            (11.9, 26.6, 6.7, 1),
            (23, 26.7, 5, 1),
            (33, 26.7, 3, 1),
            (39, 38.2, 5, 1),
            (29.8, 30, 3, 1),
            (56, 30, 3, 1),
            (41, 23.4, 5, 1),
            (52.9, 33.1, 2.9, 4),
            (38, 28.2, 5, 1),
            (46, 26.7, 6.7, 5.8),
            (44.7, 31.2, 1.5, 1.3),


            # Ground level
            (0, 33.3, 6.3, 6),
            (6.7, 34.9, 3, 6),
            (11.6, 34.9, 8.1, 6),
            (21.6, 34.9, 1.3, 6),
            (23, 33.2, 6.5, 0.9),
            (34.7, 33.3, 9.5, 6)
    ],
    5: [

            (0, 5.2, 9.5, 1),
            (0, 13.5, 11.4, 1),
            (0.2, 23.4, 1.1, 14),
            (3.5, 26.7, 1.4, 11),

            (6.8, 30, 3, 1),
            (6.7, 23.4, 3, 1),
            (10, 18.5, 4.6, 1),
            (10, 26.7, 8.2, 1.5),
            (26.3, 26.7, 5.3, 1.5),
            (36.1, 26.7, 3.7, 1.5), 

            (15, 13.5, 3, 1), 
            (18, 8.5, 5, 1),
            (49.3, 30, 3.3, 1.1), 
            (46, 23.3, 6.5, 1),
            (44.4, 18.5, 4.8, 1),

            (16.5, 20, 5, 1.3),
            (23, 20, 1.7, 1.3),
            (33, 20, 3.3, 1.3),
            (38, 20, 4.7, 1.3),
            (41.2, 13.5, 3.2, 1),
            (29.7, 7, 6.5, 1.1),
            (22.9, 7, 5, 1.2),

            (19.8, 13.5, 5, 1.3),
            (29.6, 13.5, 1.7, 1.3),
            (34.4, 13.5, 5.2, 1.3),
            (36.4, 8.5, 4.5, 1.2),
            (42.9, 5.3, 6.5, 1),
            (51, 15, 8, 1),

            (15.1, 26.8, 1, 8),
            (43.1, 26.8, 1, 8),
            (21.7, 13.6, 1.2, 7.7),
            (36.5, 13.6, 1.2, 7.7),
            (18.4, 20, 1, 8.1), 
            (39.9, 20, 1, 8.1),
            (25, 7, 1, 7.8),
            (33.3, 7, 1, 7.8),

            (54.5, 26.8, 1.2, 11),
            (57.9, 23.4, 1.2, 14),
            (51.3, 3.2, 1.5, 6.3),
            (53, 8.3, 4.4, 1.3),
            (57.6, 3.3, 1.5, 6),
            (54.3, 5, 1.7, 1.3),

            (28.2, 12, 1.2, 2.5), 
            (31.5, 18.5, 1.3, 2.5),
            (25, 25, 1, 3),
            (34.9, 31.7, 1, 3),
            (17.7, 31.5, 1.8, 1),

            (9.9, 33.2, 5, 1.3),
            (19.4, 33.2, 7.3, 1.3),
            (29.4, 33.2, 5.4, 1.3),
            (36, 33.2, 5.5, 1.3),
            (44, 33.2, 5.3, 1.3)
    ]
}

# 1. Fix the level_backgrounds initialization
level_backgrounds = {
    0: {'type': 'video', 'path': 'Level Data/Level Image/Level1_Background.mp4'},
    1: {'type': 'image', 'path': 'Level Data/Level Image/LEVEL1.png'},
    2: {'type': 'image', 'path': 'Level Data/Level Image/Level2game!.png'},
    3: {'type': 'image', 'path': 'Level Data/Level Image/Level3game!!.png'},
    4: {'type': 'image', 'path': 'Level Data/Level Image/Level4.png'},
    5: {'type': 'image', 'path': 'Level Data/Level Image/Level5.png'}
}

# Initialize video capture and load images
background_surfaces = {}
video_captures = {}

for level, bg_data in level_backgrounds.items():
    if bg_data['type'] == 'video':
        try:
            video_captures[level] = cv2.VideoCapture(bg_data['path'])
        except Exception as e:
            print(f"Error loading video for level {level}: {e}")
            # Fallback to a solid color or default image
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))
    else:
        try:
            img = pygame.image.load(bg_data['path']).convert()
            background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
        except Exception as e:
            print(f"Error loading image for level {level}: {e}")
            # Fallback to a solid color
            background_surfaces[level] = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
            background_surfaces[level].fill((0, 0, 0))

# Update collision tile creation (in World class):
def __init__(self, level_data, deadly_data):
    self.collision_tiles = []
    self.deadly_tiles = []

    for plat in level_data:
        # Adjust coordinates to align with background
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        height = int(plat[3] * TILE_SIZE)
        
        # Add small margin for better collision
        margin = 2
        collision_rect = pygame.Rect(
            x + margin,
            y + margin,
            width - margin * 2,
            height - margin * 2
        )
        self.collision_tiles.append(CollisionTile(x, y, width, height))

    for deadly in deadly_data:
        x = deadly[0] * TILE_SIZE
        y = deadly[1] * TILE_SIZE
        width = deadly[2] * TILE_SIZE
        height = int(deadly[3] * TILE_SIZE)
        
        # Add similar margin for deadly tiles
        margin = 2
        self.deadly_tiles.append(CollisionTile(
            x + margin, 
            y + margin, 
            width - margin * 2, 
            height - margin * 2
        ))

    
# Add Level 0 to LEVEL_REQUIREMENTS
LEVEL_REQUIREMENTS = {
    0: 3,  # For tutorial level
    1: 4,
    2: 5,
    3: 6,
    4: 8,
    5: 10
}

# Update STORYLINE dictionary to match story document
STORYLINE = {
    "intro": [
        "You remember the moment you stumbled upon the ancient artifact, half-buried in the basement of that old library.",
        "It was a stone box, covered in intricate, interlocking symbols that seemed to shift if you stared too long.",
        "As you worked, carefully pressing and turning parts of the stone, the symbols clicked into alignment.",
        "The box opened, releasing a chill that seeped straight to your bones.",
        "Inside was a brittle parchment with haunting words: 'Whoever unlocks these secrets is bound to us.'",
        "'Your presence is now required. The island awaits.'"
    ],
    "level0": [
        "The ghostly voice of Eralt lingers in the air as you begin.",
        '"Beware, young master. The island knows your fears, your weaknesses."',
        '"Solve the code, and move closer to your destiny."',
        '"Fail, and join the lost souls who could not decode the island\'s secrets."',
        '"Master?.." With your heart pounding, you take a deep breath and step forward,',
        "ready to solve the first of many mysteries in this shadowy realm."
    ],
    "level1": [
        "As you decipher the shifting symbols on the stone slab, a sudden flash of blinding light erupts.",
        "When it fades, a figure steps forward with silent, lethal grace.",
        "Dressed in dark, flowing robes and wielding twin daggers that glint in the moonlight,",
        "she introduces herself with a cold smile.",
        '"I am Palak, the Assassin, Guardian of the First Level."',
        '"To pass my challenge, you must prove you can see through deception and lies."',
        '"Codes are more than wordsthey\'re veils of truth and deceit. Decipher mine, or face the consequences."'
    ],
    "level2": [
        "The mist pulls you forward to a spiraling tower covered in ancient runes.",
        "At the top waits Russ, the Wizard. His eyes hold the gleam of forbidden knowledge.",
        '"Ah, the new champion has arrived."',
        "He gestures to a puzzle box floating in mid-air, surrounded by a shimmering aura.",
        '"This test is one of patience and intellect."',
        '"You must unlock this box without using brute force; the wrong twist will reset it."',
        '"Fail, and your mind will be trapped in an endless loop."'
    ],
    "level3": [
        "The scenery morphs into a grand, oppressive throne room.",
        "Seated on the throne is Geoff, the Autocrat, draped in black, a crown of thorns upon his brow.",
        '"So you\'ve passed the others. But codes are not just puzzles; they\'re tools of control, of power."',
        '"I rule through secrets."',
        "He gestures to an enormous map with encrypted marks scattered across it.",
        '"Your task is to decipher the locations on this map."',
        '"Fail, and you will be exiled into the barren lands."'
    ],
    "level4": [
        "The shadows deepen, and you're surrounded by a ghostly fog.",
        "From it, a figure in tattered, ethereal robes emergesJessica, the Wraith.",
        "Her eyes glow with an eerie, otherworldly light as she glides toward you.",
        '"You are brave, but bravery means nothing in the face of fear."',
        '"This trial is not of logic, but of your darkest nightmares."',
        "A mirror appears, showing twisted images of your deepest fears.",
        '"Face your fears, or be lost to them forever."'
    ],
    "level5": [
        "You arrive at a shadowy castle ruin where the final guardian awaits: Jacobo, the Undead King.",
        "His skeletal form radiates an unholy power, and his hollow eyes burn with a fierce light.",
        '"You stand before the final trial, mortal."',
        '"I am Jacobo, the Undead King, master of the lost and forgotten."',
        '"To claim victory, you must decipher the oldest code of all,"',
        '"the language of life and death itself."'
    ],
    "ending": [
        "The tome releases a blinding light. When it fades, you're back on the beach.",
        "The island seems quiet, as if holding its breath. But something is differentyou can feel it.",
        "As you touch the sand, it shifts, forming into a new message:",
        '"Congratulations, you have proven yourself. But know this:"',
        '"The title of decoding master is not a prize, but a burden."',
        '"The codes you hold now contain secrets that even the spirits dare not speak."',
        '"Guard them well, for they will change everything."'
    ]
}

# Update LEVEL_DIALOGUES dictionary to add Level 0
LEVEL_DIALOGUES = {
    0: [
        "Tutorial Level: Learning the Basics",
        "Master the art of movement and key collection.",
        "Collect 3 keys to proceed to your first real challenge.",
        "Press SPACE to continue..."
    ],
    1: [
        "Level 1: The Assassin's Trial",
        "Find 4 keys while avoiding deadly traps.",
        "Press SPACE to continue..."
    ],
    2: [
        "Level 2: The Wizard's Tower",
        "Collect 5 keys hidden by magical illusions.",
        "Press SPACE to continue..."
    ],
    3: [
        "Level 3: The Autocrat's Domain",
        "Gather 6 keys from this sprawling fortress.",
        "Press SPACE to continue..."
    ],
    4: [
        "Level 4: The Wraith's Nightmare",
        "Find 8 keys in this realm of shadows.",
        "Press SPACE to continue..."
    ],
    5: [
        "Final Level: The Undead King's Castle",
        "Collect all 10 keys to complete your journey.",
        "Press SPACE to continue..."
    ]
}

LEVEL_DEADLY_DATA = {
    0: [

        
    ],
    1: [
        
    ],
    2: [
        (23.2, 3.6, 3, 1),
        (26.4, 10.2, 4.8, 1.3),
        (28, 34, 15, 1)
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6),
    ],
    4: [
        (10, 22.4, 11.3, 1.3),
        (22, 13.8, 2, 2),
        (20, 22.4, 2.4, 2),
    ],
    5: [
        (0.2, 34, 59, 4),
        (15.4, 28, 2.2, 3),
        (22, 25.4, 2, 2),
        (25, 12, 2.4, 2.7),
        (28.4, 18.7, 2.4, 2.3),
        (31.8, 25.2,  2.3, 2),
        (26.9, 32, 2, 2),
        (40.2, 25.3, 2, 2),
        (41.7, 30.3, 2, 2),
    ]
}

# Update LEVEL_ENEMY_DATA to include boundary information:
LEVEL_ENEMY_DATA = {
    0: [

        
    ],
    1: [
        (17, 33.4, "horizontal", 17, 32),
        (0.2, 5.5, "horizontal", 0.2, 8.5),
        (36.2, 22, "horizontal", 36.2, 41.2),
        (50.5, 10.6, "horizontal", 50.5, 56),    # x, y, direction, boundary_start, boundary_end
        (18.5, 19, "horizontal", 18.5, 27.2)  # x, y, direction, boundary_start, boundary_end
    ],
    2: [
        (8.5, 24, "horizontal", 8.5, 20),
        (0.2, 17.2, "horizontal", 0.2, 8.7),
        (44.5, 30.5, "horizontal", 44, 58.5),
        (35, 14, "horizontal", 35, 41),
        (52.3, 9.1, "horizontal", 52.3, 58.5),
        
    ],
    3: [
        (10.5, 24, "horizontal", 10.5, 20.5),
        (24, 34, "horizontal", 24, 43),
        (18, 13.6, "horizontal", 18, 26.5),
        (30, 3.6, "horizontal", 30, 38.5),
        (48, 6.4, "horizontal", 48, 57),
        (37.5, 15.8, "horizontal", 37.5, 43.5),
    ],
    4: [

    ],
    5: [

    ]
}

class DialogueBox:
    def __init__(self, screen):
        self.screen = screen
        self.animation_complete = False
        self.current_alpha = 0
        self.target_alpha = 230
        self.fade_speed = 10
        self.current_line = 0
        self.current_word = 0
        self.current_char = 0
        self.text_delay = 2  # Controls typing speed
        self.frame_counter = 0
        self.words_revealed = []  # List to store revealed words for each line
        
    def animate(self, dialogue_lines):
        # Create semi-transparent background
        dialogue_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        dialogue_surface.fill(BLACK)
        
        # Animate fade in
        if self.current_alpha < self.target_alpha:
            self.current_alpha = min(self.current_alpha + self.fade_speed, self.target_alpha)
        dialogue_surface.set_alpha(self.current_alpha)
        self.screen.blit(dialogue_surface, (0, 0))
        
        # Initialize words_revealed list if needed
        if not self.words_revealed:
            self.words_revealed = [[] for _ in dialogue_lines]
        
        # Calculate text position for centering
        total_height = len(dialogue_lines) * 60
        start_y = (SCREEN_HEIGHT - total_height) // 2
        
        # Update text animation
        self.frame_counter += 1
        if self.frame_counter >= self.text_delay:
            self.frame_counter = 0
            self.update_text(dialogue_lines)
        
        # Draw text
        for i, line in enumerate(dialogue_lines):
            # Split line into words
            words = line.split()
            revealed_text = ' '.join(self.words_revealed[i])
            
            text_surface = pygame.font.SysFont('Bauhaus 93', 40).render(
                revealed_text, True, WHITE)
            text_rect = text_surface.get_rect(center=(SCREEN_WIDTH // 2, start_y + i * 60))
            self.screen.blit(text_surface, text_rect)
        
        # Add "Press SPACE to continue" prompt when animation is complete
        if self.animation_complete:
            prompt = pygame.font.SysFont('Bauhaus 93', 30).render(
                "Press SPACE to continue...", True, (200, 200, 200))
            prompt_rect = prompt.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
            self.screen.blit(prompt, prompt_rect)
        
        return self.animation_complete
    
    def update_text(self, dialogue_lines):
        if self.current_line < len(dialogue_lines):
            words = dialogue_lines[self.current_line].split()
            
            if self.current_word < len(words):
                # Add next word
                self.words_revealed[self.current_line].append(words[self.current_word])
                self.current_word += 1
            else:
                # Move to next line
                self.current_line += 1
                self.current_word = 0
        else:
            self.animation_complete = True

# Update the show_dialogue function to properly handle space key:
def show_dialogue(dialogue_lines):
    dialogue_box = DialogueBox(screen)
    
    waiting = True
    space_pressed = False
    
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                    return True  # Always return True when space is pressed
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

class Camera:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.scroll_x = 0
        self.scroll_y = 0
        self.zoom = 1
        self.target_zoom = 1
        self.base_zoom = 2.5
        self.zoom_out_level = 1.3
        self.zoom_speed = 0.04
        self.transitioning = False
        self.transition_start_time = 0
        self.transition_delay = 2000
        self.transition_duration = 2000
        self.transition_total_time = self.transition_delay + self.transition_duration
        self.transition_complete = False
        self.manual_zoom_active = False
        self.initial_zoom_done = False
        
        # Door zoom properties
        self.door_zoom = False
        self.door_zoom_target = None
        self.door_zoom_speed = 0.02
        self.door_target_zoom = 3.5
        self.door_transition_start = 0
        self.door_transition_duration = 1500
        self.post_open_delay = 1000
        self.door_opened_time = 0
        self.reset_on_death = False
        self.death_reset_time = 0
        self.death_reset_duration = 1000  # 1 second for reset animation
        
        # Sound properties
        self.wind_sound = pygame.mixer.Sound('img/Gust of Wind.mp3')
        self.jungle_music = pygame.mixer.Sound('img/Background Music.MP3')
        self.zoom_out_sound = pygame.mixer.Sound('img/zoom_out.mp3')  # Add this line
        self.wind_sound.set_volume(0.8)
        self.jungle_music.set_volume(0.4)
        self.zoom_out_sound.set_volume(0.5)  # Add this line
        self.wind_sound_playing = False
        self.jungle_music_playing = False
        self.wind_sound_start_time = 0
        self.wind_sound_duration = int(self.wind_sound.get_length() * 1000)
        
        self.visible_width = width
        self.visible_height = height

    def reset_zoom(self):
        """Reset camera zoom when player dies"""
        self.reset_on_death = True
        self.death_reset_time = pygame.time.get_ticks()
        self.zoom = self.base_zoom
        self.target_zoom = self.base_zoom
        self.manual_zoom_active = False
        self.door_zoom = False
        self.door_zoom_target = None
        self.transitioning = False
        self.initial_zoom_done = True

    def start_door_zoom(self, door):
        if not self.door_zoom and not self.manual_zoom_active:  # Added check for manual zoom
            self.door_zoom = True
            self.door_zoom_target = door
            self.door_transition_start = pygame.time.get_ticks()
            self.door_target_zoom = 3.5
        
    def start_transition(self):
        # Stop any existing sounds before starting new ones
        self.stop_sounds()
        self.transitioning = True
        self.transition_complete = False
        self.zoom = 1
        self.transition_start_time = pygame.time.get_ticks()
        
        # Start wind sound and track its start time
        self.wind_sound.play()
        self.wind_sound_playing = True
        self.wind_sound_start_time = pygame.time.get_ticks()
        self.jungle_music_playing = False
    
    def update(self, target, keys_collected, door, required_keys):
        current_time = pygame.time.get_ticks()
        
        # Handle manual zoom control with Enter key
        keys = pygame.key.get_pressed()
        if keys[pygame.K_RETURN]:
            self.manual_zoom_active = True
            self.target_zoom = self.zoom_out_level
            self.zoom_out_sound.play()
        elif self.manual_zoom_active:
            self.manual_zoom_active = False
            self.target_zoom = self.base_zoom if self.transition_complete else 1
        
        # Handle initial transition
        if self.transitioning and not self.initial_zoom_done:
            elapsed = current_time - self.transition_start_time
            
            if elapsed >= self.transition_delay:
                zoom_elapsed = elapsed - self.transition_delay
                progress = min(zoom_elapsed / self.transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                if not self.manual_zoom_active:
                    self.zoom = 1 + (self.base_zoom - 1) * progress
                
                if progress >= 1:
                    self.transitioning = False
                    self.transition_complete = True
                    self.initial_zoom_done = True
                    if not self.manual_zoom_active:
                        self.zoom = self.base_zoom
                        self.target_zoom = self.base_zoom
        
        # Handle smooth zoom transition
        elif not self.door_zoom:
            if self.zoom != self.target_zoom:
                diff = self.target_zoom - self.zoom
                self.zoom += diff * self.zoom_speed
        
        # Handle door zoom if active
        if self.door_zoom and self.door_zoom_target:
            elapsed = current_time - self.door_transition_start
            
            if not self.door_zoom_target.is_open:
                progress = min(elapsed / self.door_transition_duration, 1.0)
                progress = self.ease_out_cubic(progress)
                
                self.zoom = 1 + (self.door_target_zoom - 1) * progress
                
                # Calculate center position for the door
                target_x = self.door_zoom_target.rect.centerx - (SCREEN_WIDTH // (2 * self.zoom))
                target_y = self.door_zoom_target.rect.centery - (SCREEN_HEIGHT // (2 * self.zoom))
                
                # Smoothly move camera to center the door
                self.scroll_x += (target_x - self.scroll_x) * 0.1
                self.scroll_y += (target_y - self.scroll_y) * 0.1
                
                if progress >= 1.0:
                    self.door_zoom_target.open_door()
                    self.door_opened_time = current_time
            else:
                hold_time = current_time - self.door_opened_time
                if hold_time >= self.post_open_delay:
                    zoom_out_progress = min((hold_time - self.post_open_delay) / 1000, 1.0)
                    zoom_out_progress = self.ease_out_cubic(zoom_out_progress)
                    
                    target_zoom = self.target_zoom
                    self.zoom = self.door_target_zoom - (self.door_target_zoom - target_zoom) * zoom_out_progress
                    
                    if zoom_out_progress >= 1.0:
                        self.door_zoom = False
                        self.zoom = target_zoom
        
        # Handle death reset
        if self.reset_on_death:
            elapsed = current_time - self.death_reset_time
            if elapsed <= self.death_reset_duration:
                # Smoothly transition zoom back to base level
                progress = elapsed / self.death_reset_duration
                progress = self.ease_out_cubic(progress)
                self.zoom = 1 + (self.base_zoom - 1) * progress
            else:
                self.reset_on_death = False
                self.zoom = self.base_zoom
                self.target_zoom = self.base_zoom
        
        # Update sound behavior
        if (self.wind_sound_playing and 
            current_time - self.wind_sound_start_time >= self.wind_sound_duration and 
            not self.jungle_music_playing):
            self.wind_sound_playing = False
            self.jungle_music.play()
            self.jungle_music_playing = True
        
        # Update visible area and camera position
        self.visible_width = self.width // self.zoom
        self.visible_height = self.height // self.zoom
        
        # Normal camera follow behavior when not zooming to door
        if not self.door_zoom:
            target_x = target.rect.centerx - self.visible_width // 2
            target_y = target.rect.centery - self.visible_height // 2
            
            self.scroll_x += (target_x - self.scroll_x) * 0.1
            self.scroll_y += (target_y - self.scroll_y) * 0.1
        
        # Keep the camera within bounds
        self.scroll_x = max(0, min(self.scroll_x, SCREEN_WIDTH - self.visible_width))
        self.scroll_y = max(0, min(self.scroll_y, SCREEN_HEIGHT - self.visible_height))
    
    def stop_sounds(self):
        """Stop all sounds and reset sound states"""
        try:
            if pygame.mixer.get_init():  # Check if mixer is initialized
                self.wind_sound.stop()
                self.jungle_music.stop()
                self.zoom_out_sound.stop()  # Add this line
        except (AttributeError, pygame.error):
            pass
        self.wind_sound_playing = False
        self.jungle_music_playing = False

        
    # Update the Camera class cleanup method:
    def cleanup(self):
        """Clean up all audio resources and reset camera state"""
        self.stop_sounds()
        self.transitioning = False
        self.transition_complete = False
        self.zoom = 1
        self.wind_sound_start_time = 0
        self.door_zoom = False
        self.door_zoom_target = None
        
    def __del__(self):
        """Destructor to ensure sounds are stopped when the camera object is destroyed"""
        try:
            self.stop_sounds()
        except:
            pass  # Ignore any errors during cleanup

    def ease_out_cubic(self, x):
        return 1 - pow(1 - x, 3)

    def apply(self, surface, entity):
        return pygame.Rect(
            entity.rect.x - self.scroll_x,
            entity.rect.y - self.scroll_y,
            entity.rect.width,
            entity.rect.height
        )

    def apply_sprite(self, surface, sprite):
        # Return the position where the sprite should be drawn
        return (sprite.rect.x - self.scroll_x,
                sprite.rect.y - self.scroll_y)
                
    def apply_rect(self, rect):
        # Apply camera offset to a rect
        return pygame.Rect(
            rect.x - self.scroll_x,
            rect.y - self.scroll_y,
            rect.width,
            rect.height
        )

# Update the video background handling code
def update_video_background(level):
    """Update video frame for video backgrounds"""
    if level in video_captures and video_captures[level] is not None:
        ret, frame = video_captures[level].read()
        if not ret:
            # Reset video to beginning if we've reached the end
            video_captures[level].set(cv2.CAP_PROP_POS_FRAMES, 0)
            ret, frame = video_captures[level].read()
        
        if ret:
            # Convert frame from BGR to RGB and flip to match Pygame's format
            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            frame = cv2.resize(frame, (SCREEN_WIDTH, SCREEN_HEIGHT))
            frame = np.rot90(frame)
            frame = np.flipud(frame)
            frame = pygame.surfarray.make_surface(frame)
            return frame
    return None

# Update the initialization of video captures
# Initialize game assets
def init_game():
    """Initialize video captures and background surfaces"""
    global video_captures, background_surfaces
    video_captures = {}
    background_surfaces = {}
    
    for level, bg_data in level_backgrounds.items():
        if bg_data['type'] == 'video':
            try:
                cap = cv2.VideoCapture(bg_data['path'])
                if not cap.isOpened():
                    print(f"Failed to open video file for level {level}")
                    cap = None
                video_captures[level] = cap
            except Exception as e:
                print(f"Error loading video for level {level}: {e}")
                video_captures[level] = None
        else:
            try:
                img = pygame.image.load(bg_data['path']).convert()
                background_surfaces[level] = pygame.transform.scale(img, (SCREEN_WIDTH, SCREEN_HEIGHT))
            except Exception as e:
                print(f"Error loading image for level {level}: {e}")
                fallback = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
                fallback.fill((0, 0, 0))
                background_surfaces[level] = fallback

def get_background(level):
    """Get the current background surface for the given level"""
    if level_backgrounds[level]['type'] == 'video':
        return update_video_background(level)
    else:
        return background_surfaces[level]

# Update the cleanup function
def cleanup_backgrounds():
    """Release all video captures properly"""
    global video_captures
    if 'video_captures' in globals():
        for cap in video_captures.values():
            if cap is not None:
                cap.release()
        video_captures.clear()


# 2. Fix create_zoomed_view function to properly handle backgrounds
def create_zoomed_view(screen, camera, player, world, keys_group, door, npc, moving_enemies):
    current_visible_width = int(SCREEN_WIDTH // camera.zoom)
    current_visible_height = int(SCREEN_HEIGHT // camera.zoom)
    
    view_surface = pygame.Surface((current_visible_width, current_visible_height))
    
    # Get and draw the current background
    current_background = get_background(current_level)
    if current_background:
        view_surface.blit(current_background, (-camera.scroll_x, -camera.scroll_y))
    
    # Draw all game objects on the zoomed surface
    for key in keys_group:
        pos = camera.apply_sprite(view_surface, key)
        if (0 <= pos[0] < current_visible_width and 
            0 <= pos[1] < current_visible_height):
            view_surface.blit(key.image, pos)
    
    # Draw door and NPC with visibility check
    door_pos = camera.apply_sprite(view_surface, door)
    npc_pos = camera.apply_sprite(view_surface, npc)
    if (0 <= door_pos[0] < current_visible_width and 
        0 <= door_pos[1] < current_visible_height):
        view_surface.blit(door.image, door_pos)
    if (0 <= npc_pos[0] < current_visible_width and 
        0 <= npc_pos[1] < current_visible_height):
        view_surface.blit(npc.image, npc_pos)
    
    # Draw enemies
    for enemy in moving_enemies:
        enemy_pos = camera.apply_sprite(view_surface, enemy)
        if (0 <= enemy_pos[0] < current_visible_width and 
            0 <= enemy_pos[1] < current_visible_height):
            view_surface.blit(enemy.image, enemy_pos)
    
    # Draw player
    player_pos = camera.apply_sprite(view_surface, player)
    if (0 <= player_pos[0] < current_visible_width and 
        0 <= player_pos[1] < current_visible_height):
        view_surface.blit(player.image, player_pos)
    
    # Scale the view surface to fill the screen
    scaled_surface = pygame.transform.scale(view_surface, (SCREEN_WIDTH, SCREEN_HEIGHT))
    screen.blit(scaled_surface, (0, 0))
    
    # Draw HUD elements
    draw_text(f"Level {current_level}", 40, WHITE, 10, 10)
    draw_text(f"Keys: {keys_collected}/{LEVEL_REQUIREMENTS[current_level]}", 40, WHITE, 10, 60)

    
class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Key(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = key_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

# In the Door class, update the open_door method to handle the image transition properly:
class Door:
    def __init__(self, x, y):
        super().__init__()
        self.closed_image = pygame.image.load('img/closeddoor.PNG')
        self.open_image = pygame.image.load('img/opendoor_img.PNG')
        self.closed_image = pygame.transform.scale(self.closed_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
        self.open_image = pygame.transform.scale(self.open_image, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
        self.image = self.closed_image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.is_open = False
        self.door_sound = pygame.mixer.Sound('img/door_sound.MP3')
        self.door_sound.set_volume(0.5)
        self.sound_played = False
        self.collision_enabled = True
        self.entered = False  # Add this new property

    def open_door(self):
        if not self.is_open:
            self.image = self.open_image
            self.is_open = True
            self.collision_enabled = False
            if not self.sound_played:
                self.door_sound.play()
                self.sound_played = True

    def open_door(self):
        if not self.is_open:
            self.image = self.open_image
            self.is_open = True
            self.collision_enabled = False  # Disable collision when door is open
            if not self.sound_played:
                self.door_sound.play()
                self.sound_played = True

class NPC(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = npc_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y


class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2))
        
        # Load animations
        for i in range(1, 5):
            img = pygame.image.load(f'img/dino{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        # Load sound effects
        self.walking_sound = pygame.mixer.Sound('img/Character Walking.MP3')
        self.walking_sound.set_volume(0.5)
        self.is_walking_sound_playing = False
        
        self.key_collect_sound = pygame.mixer.Sound('img/key_collect.mp3')
        self.key_collect_sound.set_volume(0.4)
        
        self.falling_sound = pygame.mixer.Sound('img/falling_character.mp3')
        self.falling_sound.set_volume(2)
        self.is_falling_sound_playing = False
        self.falling_threshold = 10  # Number of frames to trigger falling sound
        self.falling_counter = 0
        
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, player_size)
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def stop_sounds(self):
        """Stop all player sounds"""
        if self.is_walking_sound_playing:
            self.walking_sound.stop()
            self.is_walking_sound_playing = False
        if self.is_falling_sound_playing:
            self.falling_sound.stop()
            self.is_falling_sound_playing = False

    def cleanup(self):
        """Clean up player resources"""
        self.stop_sounds()
        self.is_walking_sound_playing = False
        self.is_falling_sound_playing = False
        self.falling_counter = 0

    def __del__(self):
        """Ensure sounds are stopped when player object is destroyed"""
        self.stop_sounds()

    def update(self, game_over, world, keys_group, camera):
        global keys_collected
        dx = 0
        dy = 0
        walk_cooldown = 5
        
        if game_over == -1:
            # Handle death state
            if not hasattr(self, '_death_handled'):
                camera.reset_zoom()  # Reset camera when player dies
                self._death_handled = True
                self.stop_sounds()
            self.image = self.dead_image
            if self.rect.y > 200:
                self.rect.y -= 5
            return game_over
            
        # Reset death handling flag when game is restarted
        self._death_handled = False
        
        # Normal movement code here
        if camera.transition_complete:
            key = pygame.key.get_pressed()
            
            # Handle walking sound
            is_moving = False
            
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
                # Reset falling counter when jumping
                self.falling_counter = 0
                if self.is_falling_sound_playing:
                    self.falling_sound.stop()
                    self.is_falling_sound_playing = False
            
            if not key[pygame.K_SPACE]:
                self.jumped = False

            # Check for movement keys and play sound
            if key[pygame.K_LEFT] or key[pygame.K_a]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
                is_moving = True
            if key[pygame.K_RIGHT] or key[pygame.K_d]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
                is_moving = True
            
            # Handle walking sound
            if is_moving and not self.in_air and not self.is_walking_sound_playing:
                self.walking_sound.play(-1)
                self.is_walking_sound_playing = True
            elif (not is_moving or self.in_air) and self.is_walking_sound_playing:
                self.walking_sound.stop()
                self.is_walking_sound_playing = False

            if not (key[pygame.K_LEFT] or key[pygame.K_RIGHT] or key[pygame.K_a] or key[pygame.K_d]):
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

        # Always apply gravity regardless of camera state
        self.vel_y += GRAVITY
        if self.vel_y > 10:
            self.vel_y = 10
        dy += self.vel_y

        # Handle falling sound
        if self.in_air and self.vel_y > 0:  # If falling
            self.falling_counter += 1
            if self.falling_counter >= self.falling_threshold and not self.is_falling_sound_playing:
                self.falling_sound.play()
                self.is_falling_sound_playing = True
        elif not self.in_air:  # When landing
            self.falling_counter = 0
            if self.is_falling_sound_playing:
                self.falling_sound.stop()
                self.is_falling_sound_playing = False

        # Check for collision with keys
        key_hits = pygame.sprite.spritecollide(self, keys_group, True)
        if key_hits:
            self.key_collect_sound.play()
            keys_collected += len(key_hits)

        # Assume we're in the air unless collision detection proves otherwise
        self.in_air = True

        # Check for collision
        result = world.check_collision(self, dx, dy)
        if result == "deadly":
            return -1  # Return game over state
        else:
            dx, dy = result

        # Update player position
        self.rect.x += dx
        self.rect.y += dy

        # Keep player on screen
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH:
            self.rect.right = SCREEN_WIDTH
            
        # Check if player has fallen off the map
        if self.rect.top > SCREEN_HEIGHT:
            return -1  # Return game over state
            
        return game_over

class World:
    def __init__(self, level_data, deadly_data):
        self.collision_tiles = []
        self.deadly_tiles = []
        self.blue_tiles = []  # Initialize blue_tiles list

        # Create collision tiles
        for plat in level_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            
            offset_x = 0
            offset_y = 0
            
            collision_rect = pygame.Rect(
                x + offset_x,
                y + offset_y,
                width,
                height
            )
            self.collision_tiles.append(CollisionTile(x + offset_x, y + offset_y, width, height))

        # Create deadly tiles
        for deadly in deadly_data:
            x = deadly[0] * TILE_SIZE
            y = deadly[1] * TILE_SIZE
            width = deadly[2] * TILE_SIZE
            height = int(deadly[3] * TILE_SIZE)
            
            self.deadly_tiles.append(CollisionTile(x, y, width, height))

        # Create blue tiles
        if current_level in LEVEL_BLUE_DATA:
            for blue in LEVEL_BLUE_DATA[current_level]:
                x = blue[0] * TILE_SIZE
                y = blue[1] * TILE_SIZE
                width = blue[2] * TILE_SIZE
                height = int(blue[3] * TILE_SIZE)
                
                self.blue_tiles.append(CollisionTile(x, y, width, height))

                '''    def draw(self, screen):
                        # Draw regular collision tiles in red
                        for tile in self.collision_tiles:
                            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)
                        
                        # Draw deadly tiles in green
                        for tile in self.deadly_tiles:
                            pygame.draw.rect(screen, (0, 255, 0), tile.rect, 2)
                        
                        # Draw blue tiles in blue
                        for tile in self.blue_tiles:
                            pygame.draw.rect(screen, (0, 0, 255), tile.rect, 1)'''

    def check_collision(self, player, dx, dy):
        # Check collision with both regular and blue tiles
        for tile in self.collision_tiles + self.blue_tiles:
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False
                    
        # Check deadly collisions
        for tile in self.deadly_tiles:
            if tile.rect.colliderect(player.rect):
                return "deadly"
                
        return dx, dy

def init_level(level_num):
    global keys_collected, game_start_time, current_level, player, camera
    
    # Clean up previous player if it exists
    if 'player' in globals():
        player.cleanup()
    
    # Reset camera state completely
    camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
    camera.transitioning = False
    camera.transition_complete = False
    camera.manual_zoom_active = False
    camera.door_zoom = False
    camera.door_zoom_target = None
    camera.reset_on_death = False
    
    # Clean up previous player if it exists
    if 'player' in globals():
        player.cleanup()
    
    keys_collected = 0
    current_level = level_num
    
    if game_start_time is None:
        game_start_time = time.time()
    
    # Rest of the initialization code...
    keys_group = pygame.sprite.Group()
    key_positions = generate_key_positions(level_num)
    for pos in key_positions:
        keys_group.add(Key(pos[0], pos[1]))
    
    platforms = LEVEL_PLATFORM_DATA[level_num]
    suitable_platform = find_suitable_platform(platforms)
    
    platform_x = suitable_platform[0]
    platform_y = suitable_platform[1]
    platform_width = suitable_platform[2]
    
    door_x = (platform_x + platform_width - 2) * TILE_SIZE
    door_y = (platform_y - 2) * TILE_SIZE
    
    if door_x > SCREEN_WIDTH - 3 * TILE_SIZE:
        door_x = SCREEN_WIDTH - 3 * TILE_SIZE
    
    door = Door(door_x, door_y)
    npc = NPC(door_x - TILE_SIZE * 2, door_y)
    
    deadly_tiles = LEVEL_DEADLY_DATA[level_num]
    world = World(platforms, deadly_tiles)
    
    spawn_x = 100
    spawn_y = 0
    
    ground_platforms = []
    for plat in platforms:
        if plat[1] > (SCREEN_HEIGHT / TILE_SIZE) * 0.7:
            ground_platforms.append(plat)
    
    if ground_platforms:
        leftmost = sorted(ground_platforms, key=lambda p: p[0])[0]
        spawn_x = (leftmost[0] + 1) * TILE_SIZE
        spawn_y = leftmost[1] * TILE_SIZE - TILE_SIZE * 2
    
    player = Player(spawn_x, spawn_y)
    
    moving_enemies.empty()
    for enemy_data in LEVEL_ENEMY_DATA[level_num]:
        x, y, direction, boundary_start, boundary_end = enemy_data
        enemy = MovingEnemy(x, y, direction, boundary_start, boundary_end)
        moving_enemies.add(enemy)
    
    return keys_group, door, npc, world, moving_enemies, player


class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(npc_img, (TILE_SIZE, TILE_SIZE))
        self.rect = self.image.get_rect()
        self.rect.x = x * TILE_SIZE
        self.rect.y = y * TILE_SIZE
        self.direction = direction
        self.speed = 2
        self.moving_right = True
        self.moving_down = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE
        self.initial_pos = self.rect.x if direction == "horizontal" else self.rect.y

    def update(self):
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)
        else:  # vertical movement
            if self.moving_down:
                self.rect.y += self.speed
                if self.rect.y >= self.boundary_end:
                    self.moving_down = False
            else:
                self.rect.y -= self.speed
                if self.rect.y <= self.boundary_start:
                    self.moving_down = True

    def draw_boundaries(self, screen):
        # Draw movement boundaries (for debugging)
        if self.direction == "horizontal":
            pygame.draw.line(screen, (255, 0, 0),
                           (self.boundary_start, self.rect.centery),
                           (self.boundary_end, self.rect.centery), 2)
        else:
            pygame.draw.line(screen, (255, 0, 0),
                           (self.rect.centerx, self.boundary_start),
                           (self.rect.centerx, self.boundary_end), 2)

    def check_collision(self, player):
        # Create a slightly smaller collision rect for more forgiving collisions
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button:
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self, screen):
        action = False
        # Get mouse position
        pos = pygame.mouse.get_pos()  # This gets the (x, y) position of the mouse

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and not self.clicked:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font_size, color, x, y):
    font = pygame.font.SysFont('Bauhaus 93', font_size)
    img = font.render(text, True, color)
    screen.blit(img, (x, y))

# Update the show_dialogue function:
def show_dialogue(dialogue_lines):
    dialogue_box = DialogueBox(screen)
    
    waiting = True
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

def find_suitable_platform(platforms):
    """
    Find a suitable platform for door placement using better criteria:
    1. Platform must be wide enough for door and NPC
    2. Platform should be reasonably high up but not necessarily the highest
    3. Platform should have enough space above it
    """
    # Sort platforms by height (y-coordinate), from top to bottom
    sorted_platforms = sorted(platforms, key=lambda p: p[1])
    
    # Required width for door and NPC (in tile units)
    required_width = 4  # Space for door and NPC
    
    # Check top 1/3 of platforms for a suitable spot
    top_third = len(sorted_platforms) // 3
    if top_third < 1:
        top_third = 1
    
    for platform in sorted_platforms[:top_third]:
        # Get platform dimensions
        x, y, width, height = platform
        
        # Check if platform is wide enough
        if width >= required_width:
            # Check if there's another platform directly above
            has_obstruction = False
            platform_top = y
            platform_left = x
            platform_right = x + width
            
            # Check for obstructions above
            for other_platform in platforms:
                other_x, other_y, other_width, other_height = other_platform
                other_left = other_x
                other_right = other_x + other_width
                other_bottom = other_y + other_height
                
                # Check if there's a platform directly above
                if (other_bottom > platform_top - 4 and  # Leave space for door height
                    other_y < platform_top and
                    other_right > platform_left and
                    other_left < platform_right):
                    has_obstruction = True
                    break
            
            if not has_obstruction:
                return platform
                
    # Fallback to the widest platform in the top half if no perfect match
    top_half = sorted_platforms[:len(sorted_platforms)//2]
    widest_platform = max(top_half, key=lambda p: p[2])
    return widest_platform

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    deadly_tiles = LEVEL_DEADLY_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Function to check if position is safe from deadly tiles
    def is_safe_position(x, y):
        SAFE_DISTANCE = TILE_SIZE * 3  # Minimum distance from deadly tiles
        
        for deadly in deadly_tiles:
            deadly_x = deadly[0] * TILE_SIZE
            deadly_y = deadly[1] * TILE_SIZE
            deadly_width = deadly[2] * TILE_SIZE
            deadly_height = deadly[3] * TILE_SIZE
            
            # Calculate boundaries of the deadly area with safety margin
            deadly_left = deadly_x - SAFE_DISTANCE
            deadly_right = deadly_x + deadly_width + SAFE_DISTANCE
            deadly_top = deadly_y - SAFE_DISTANCE
            deadly_bottom = deadly_y + deadly_height + SAFE_DISTANCE
            
            # Check if key position is within the danger zone
            if (deadly_left < x < deadly_right and 
                deadly_top < y < deadly_bottom):
                return False
        return True
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    attempts = 0
    max_attempts = 100  # Prevent infinite loop
    
    while len(positions) < required_keys and attempts < max_attempts:
        for plat in viable_platforms:
            if len(positions) >= required_keys:
                break
                
            # Try multiple positions on each platform
            for _ in range(5):  # Try 5 times per platform
                # Place key somewhere along the platform
                key_x = plat[0] + random.uniform(TILE_SIZE, plat[2] - TILE_SIZE * 2)
                key_y = plat[1] - TILE_SIZE * 1.5
                
                # Only add position if it's safe
                if is_safe_position(key_x, key_y):
                    positions.append((key_x, key_y))
                    break
            
            attempts += 1
    
    # If we couldn't find enough safe positions, fill remaining with positions farther from platforms
    while len(positions) < required_keys:
        plat = random.choice(viable_platforms)
        key_x = plat[0] + random.uniform(TILE_SIZE * 2, plat[2] - TILE_SIZE * 2)
        key_y = plat[1] - TILE_SIZE * 2  # Place keys higher above platform
        if is_safe_position(key_x, key_y):
            positions.append((key_x, key_y))
    
    return positions

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    
    for i in range(min(required_keys, len(viable_platforms))):
        plat = viable_platforms[i]
        # Place key somewhere along the platform
        key_x = plat[0] + random.uniform(0, plat[2] - TILE_SIZE)
        key_y = plat[1] - TILE_SIZE * 1.5  # Place key above platform
        positions.append((key_x, key_y))
    
    return positions

# Initialize game objects
start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)
camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)
player = Player(100, SCREEN_HEIGHT - 130)
world = World(LEVEL_PLATFORM_DATA[1], LEVEL_DEADLY_DATA[1])
moving_enemies = pygame.sprite.Group()
keys_group = pygame.sprite.Group()
game_over = 0
current_state = "start_screen"

# Initialize game resources
init_game()

# Game loop
clock = pygame.time.Clock()
fps = 60
running = True

while running:
    clock.tick(fps)
    
    # Single event handling section
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
            break
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                running = False
                break

    if not running:
        break
        
    # State updates based on current_state
    if current_state == "start_screen":
        screen.blit(start_bg, (0, 0))
        current_state = "intro_dialogue"
        
    elif current_state == "intro_dialogue":
        if show_dialogue(STORYLINE["intro"]) and show_dialogue(STORYLINE["level0"]):
            current_state = "playing"
            current_level = 0
            keys_group, door, npc, world, moving_enemies, player = init_level(current_level)
        else:
            current_state = "playing"
            current_level = 0
            keys_group, door, npc, world, moving_enemies, player = init_level(current_level)
            
    elif current_state == "playing":
        # Handle dialogue states
        storyline_key = f'storyline_{current_level}'
        level_key = f'level_{current_level}'
        
        if not dialogue_states.get(storyline_key, False):
            if show_dialogue(STORYLINE[f"level{current_level}"]):
                dialogue_states[storyline_key] = True
                
        elif not dialogue_states.get(level_key, False):
            if show_dialogue(LEVEL_DIALOGUES[current_level]):
                dialogue_states[level_key] = True
                camera.start_transition()
                
        # Game updates
        camera.update(player, keys_collected, door, LEVEL_REQUIREMENTS[current_level])
        create_zoomed_view(screen, camera, player, world, keys_group, door, npc, moving_enemies)
        
        # Handle collisions and game over
        if game_over == 0:
            # Check deadly collisions
            deadly_collision = world.check_collision(player, 0, 0)
            if deadly_collision == "deadly":
                game_over = -1
                game_over_fx.play()
            
            # Update game objects
            game_over = player.update(game_over, world, keys_group, camera)
            moving_enemies.update()
            
            # Check enemy collisions
            for enemy in moving_enemies:
                if enemy.check_collision(player):
                    game_over = -1
                    game_over_fx.play()
                    break
                    
            # Level completion
            if keys_collected >= LEVEL_REQUIREMENTS[current_level]:
                if not door.is_open:
                    camera.start_door_zoom(door)
                elif pygame.sprite.collide_rect(player, door):
                    door.entered = True
                    camera.stop_sounds()
                    
                    if current_level == 0:
                        # Tutorial completion
                        if door.entered and show_dialogue([
                            "Tutorial Complete! ",
                            "You've mastered the basics! ",
                            "Press SPACE to begin your real journey..."
                        ]):
                            current_level = 1
                            storyline_key = f'storyline_{current_level}'
                            level_key = f'level_{current_level}'
                            dialogue_states[storyline_key] = False
                            dialogue_states[level_key] = False
                            camera.cleanup()
                            if game_start_time:
                                elapsed_time = int(time.time() - game_start_time)
                                level_times.append(elapsed_time)
                            keys_group, door, npc, world, moving_enemies, player = init_level(current_level)
                            camera.start_transition()
                    else:
                        # Regular level completion
                        if door.entered:
                            current_display = screen.copy()
                            camera.stop_sounds()
                            
                            if show_dialogue([
                                "To proceed to the next level,",
                                "you must complete the challenge! ",
                                "Press SPACE to begin..."
                            ]):
                                try:
                                    minigame_result = load_minigame(current_level)
                                    if minigame_result:
                                        if current_level < 5:
                                            if show_dialogue([
                                                f"Level {current_level} Complete! ",
                                                "You've conquered both challenges! ",
                                                "Press SPACE to continue..."
                                            ]):
                                                current_level += 1
                                                storyline_key = f'storyline_{current_level}'
                                                level_key = f'level_{current_level}'
                                                dialogue_states[storyline_key] = False
                                                dialogue_states[level_key] = False
                                                camera.cleanup()
                                                if game_start_time:
                                                    elapsed_time = int(time.time() - game_start_time)
                                                    level_times.append(elapsed_time)
                                                keys_group, door, npc, world, moving_enemies, player = init_level(current_level)
                                                camera.start_transition()
                                        else:
                                            camera.cleanup()
                                            if show_dialogue(STORYLINE["ending"]):
                                                current_state = "game_complete"
                                    else:
                                        if show_dialogue([
                                            "Challenge failed! ",
                                            "You must complete this trial to proceed. ",
                                            "Press SPACE to try again..."
                                        ]):
                                            screen.blit(current_display, (0,0))
                                            pygame.display.flip()
                                except Exception as e:
                                    print(f"Error running minigame {current_level}: {e}")
                                    if show_dialogue([
                                        "An error occurred! ",
                                        "Please try again. ",
                                        "Press SPACE to continue..."
                                    ]):
                                        screen.blit(current_display, (0,0))
                                        pygame.display.flip()
            pass
        else:
            # Game over state
            draw_text('GAME OVER!', 70, BLUE, (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
            if restart_button.draw(screen):
                # Properly reset all necessary variables
                game_over = 0
                keys_collected = 0
                
                # Stop any ongoing sounds
                if hasattr(player, 'stop_sounds'):
                    player.stop_sounds()
                if hasattr(camera, 'stop_sounds'):
                    camera.stop_sounds()
                    
                # Reset camera state
                camera.cleanup()
                camera.reset_zoom()
                
                # Reinitialize level
                keys_group, door, npc, world, moving_enemies, player = init_level(current_level)
                
                # Ensure camera starts fresh
                camera.start_transition()
                
                
    elif current_state == "game_complete":
        screen.fill(BLACK)
        total_time = int(time.time() - game_start_time)
        minutes = total_time // 60
        seconds = total_time % 60
        
        draw_text("Congratulations!", 70, WHITE, SCREEN_WIDTH // 2 - 250, SCREEN_HEIGHT // 3)
        draw_text(f"You've completed Decoding Island!", 50, WHITE, SCREEN_WIDTH // 2 - 300, SCREEN_HEIGHT // 2)
        draw_text(f"Total Time: {minutes:02d}:{seconds:02d}", 50, WHITE, SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 100)
        
        if restart_button.draw(screen):
            current_state = "start_screen"
            game_start_time = None
            current_level = 0
            keys_collected = 0
            level_times = []
    
    pygame.display.update()

cleanup_backgrounds()
pygame.quit()

================
File: Archive/AAAAMain.py
================
import pygame
from pygame.locals import *
import os


# Initialize Pygame
pygame.init()

# Get the screen resolution
infoObject = pygame.display.Info()
monitor_width = infoObject.current_w
monitor_height = infoObject.current_h

# Calculate the game window size (90% of screen size while maintaining aspect ratio)
SCREEN_SCALE = 0.9  # This will make the window 90% of the screen size
target_width = int(monitor_width * SCREEN_SCALE)
target_height = int(monitor_height * SCREEN_SCALE)

# Load and scale the background
original_bg = pygame.image.load('Level0.png')
bg_aspect_ratio = original_bg.get_width() / original_bg.get_height()

# Adjust window size to maintain aspect ratio
if target_width / target_height > bg_aspect_ratio:
    SCREEN_WIDTH = int(target_height * bg_aspect_ratio)
    SCREEN_HEIGHT = target_height
else:
    SCREEN_WIDTH = target_width
    SCREEN_HEIGHT = int(target_width / bg_aspect_ratio)

# Scale background to fit the calculated screen size
bg = pygame.transform.scale(original_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Platformer Game')

# Define colors and constants
TILE_SIZE = SCREEN_HEIGHT // 36  # Assuming the image is 36 tiles high
GRAVITY = 0.8
JUMP_SPEED = -15
MOVE_SPEED = 8

# Add this new class for collision tiles
class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        # Load all dino animations and scale them
        self.animations_right = []
        self.animations_left = []
        # Adjust player size to match visual appearance
        player_size = (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2))  # Slightly smaller than before
        
        for i in range(1, 5):
            img = pygame.image.load(f'img/dino{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        # Create a smaller collision rect for more precise collisions
        self.collision_rect = pygame.Rect(0, 0, 
                                        int(player_size[0] * 0.7),  # 70% of image width
                                        int(player_size[1] * 0.9))  # 90% of image height
        self.rect.x = x
        self.rect.y = y
        # Center the collision rect within the sprite
        self.collision_rect.centerx = self.rect.centerx
        self.collision_rect.bottom = self.rect.bottom
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def update(self):
        dx = 0
        dy = 0
        walk_cooldown = 5

        # Get keypresses
        key = pygame.key.get_pressed()
        if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
            self.vel_y = JUMP_SPEED
            self.jumped = True
        if not key[pygame.K_SPACE]:
            self.jumped = False
        if key[pygame.K_LEFT]:
            dx -= MOVE_SPEED
            self.counter += 1
            self.direction = -1
        if key[pygame.K_RIGHT]:
            dx += MOVE_SPEED
            self.counter += 1
            self.direction = 1
        if not key[pygame.K_LEFT] and not key[pygame.K_RIGHT]:
            self.counter = 0
            self.index = 0
            if self.direction == 1:
                self.image = self.animations_right[self.index]
            else:
                self.image = self.animations_left[self.index]

        # Handle animation
        if self.counter > walk_cooldown:
            self.counter = 0
            self.index += 1
            if self.index >= len(self.animations_right):
                self.index = 0
            if self.direction == 1:
                self.image = self.animations_right[self.index]
            else:
                self.image = self.animations_left[self.index]

        # Add gravity
        self.vel_y += GRAVITY
        if self.vel_y > 10:
            self.vel_y = 10
        dy += self.vel_y

        dx, dy = world.check_collision(self.rect, dx, dy)

        # Update player position
        self.rect.x += dx
        self.rect.y += dy

        # Keep player on screen
        if self.rect.left < 0:
            self.rect.left = 0
        if self.rect.right > SCREEN_WIDTH:
            self.rect.right = SCREEN_WIDTH

        # Update in_air status
        self.in_air = dy != 0

class World:
    def __init__(self):
        self.collision_tiles = []
        
        # Create collision tiles based on LEVEL0GAME.tmx data
        # Adjusted platform coordinates and sizes for larger platforms
        platform_data = [
            # Top platforms
            (3, 8, 6, 1.0),    # Left platform (wider)
            (28, 8, 6, 1.0),   # Right platform (wider)
            
            # Middle platform
            (15, 13, 6, 1.0),  # Middle platform (wider)
            
            # Lower platforms
            (35, 23.2, 5, 1.0),  # Lower left (wider)
            (20, 23.2, 4, 1.0),  # Lower middle (wider)
            
            # Bottom platforms
            (11.8, 28, 6.2, 2.5),   # Bottom left (wider)
            (26.6, 28, 6.2, 2.5),  # Bottom middle (wider)
            (41.3, 28, 8, 1.),  # Bottom right (wider)
            
            # Ground level
            (0, 33, 8, 3.0),  # Ground (thicker)
            (51, 33, 8.2, 3.0),  # Ground (thicker)
        ]
        
        # Convert tile positions to screen coordinates with adjusted collision boxes
        for plat in platform_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            # Add slight offset to collision boxes for better visual alignment
            collision_rect = pygame.Rect(
                x + 2,  # Small offset from left
                y + 2,  # Small offset from top
                width - 4,  # Slightly narrower
                height - 4  # Slightly shorter
            )
            self.collision_tiles.append(CollisionTile(x, y, width, height))

    def check_collision(self, player_rect, dx, dy):
        for tile in self.collision_tiles:
            # Update collision checks to use the player's collision rect
            if tile.rect.colliderect(player_rect.x + dx, player_rect.y, player_rect.width, player_rect.height):
                dx = 0
            
            if tile.rect.colliderect(player_rect.x, player_rect.y + dy, player_rect.width, player_rect.height):
                # Adjust collision response for better feel
                if player_rect.bottom + dy > tile.rect.top and dy > 0:
                    player_rect.bottom = tile.rect.top - 1  # Slight offset to prevent sticking
                    dy = 0
                elif player_rect.top + dy < tile.rect.bottom and dy < 0:
                    player_rect.top = tile.rect.bottom + 1  # Slight offset to prevent sticking
                    dy = 0
                
        return dx, dy

def find_lowest_platform(world):
    lowest_y = 0
    for tile in world.collision_tiles:
        if tile.rect.y > lowest_y:
            lowest_y = tile.rect.y
    return lowest_y

# Create world
world = World()

# Find the lowest platform
lowest_platform_y = find_lowest_platform(world)

# Create player and set initial position
player_start_x = 100  # You can adjust this value as needed
player_start_y = lowest_platform_y - TILE_SIZE * 2  # Position player two tiles above the lowest platform
player = Player(player_start_x, player_start_y)
player_group = pygame.sprite.Group()
player_group.add(player)

# Game loop
clock = pygame.time.Clock()
run = True

while run:
    clock.tick(60)

    # Draw background
    screen.blit(bg, (0, 0))

    # Update and draw player
    player_group.update()
    player_group.draw(screen)

    # Uncomment this section to see the collision boxes (for debugging)
    for tile in world.collision_tiles:
        pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)

    # Event handler
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                run = False

    pygame.display.update()

pygame.quit()

================
File: Archive/FINAL_GAME.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os
import time

def load_minigame(level):
    """Load a minigame module when needed"""
    try:
        if level == 1:
            from mini_game1 import main  # Change to your actual game file/function
            return main()
        elif level == 2:
            from mini_game2 import main  # Change to your actual game file/function
            return main()
        elif level == 3:
            from mini_game3 import main  # Change to your actual game file/function
            return main()
        elif level == 4:
            from mini_game4 import main  # Change to your actual game file/function
            return main()
        elif level == 5:
            from mini_game5 import main  # Change to your actual game file/function
            return main()
    except ImportError as e:
        print(f"Warning: Could not load minigame {level}: {e}")
        return False
    return False


# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Set the desired resolution
SCREEN_WIDTH = 1539
SCREEN_HEIGHT = 940

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Decoding Island')

# Define tile size based on background height
TILE_SIZE = SCREEN_HEIGHT // 36  # 36 is the number of tiles vertically
GRAVITY = 0.79
JUMP_SPEED = -15
MOVE_SPEED = 7
game_over = 0
current_level = 0  # 0 for start screen, 1-5 for levels
keys_collected = 0
game_start_time = None
level_times = []
dialogue_states = {}

# Load and scale the background for each level
level_backgrounds = {}
for i in range(0, 6):  # Changed to include Level 0
    original_bg = pygame.image.load(f'Level Data/Level Image/LEVEL{i}.png')
    level_backgrounds[i] = pygame.transform.scale(original_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))

# You may need to adjust other elements (buttons, player size, etc.) to fit the new resolution
# For example:
# start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
# restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Define colors
WHITE = (255, 255, 255)
BLUE = (0, 0, 255)
BLACK = (0, 0, 0)

# Load images
start_bg = pygame.image.load('img/background.png')
start_bg = pygame.transform.scale(start_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
start_btn = pygame.image.load('img/start_btn.png')
restart_img = pygame.image.load('img/restart_btn.png')
door_img = pygame.image.load('img/exit.png')
key_img = pygame.image.load('img/key.png')
npc_img = pygame.image.load('img/skeleton.png')

# Scale images
door_img = pygame.transform.scale(door_img, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))
key_img = pygame.transform.scale(key_img, (TILE_SIZE, TILE_SIZE))
npc_img = pygame.transform.scale(npc_img, (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2)))

# Load sounds
pygame.mixer.music.load('Audio/Louie Zong - BOSS RUSH/Louie Zong - BOSS RUSH - 05 ______REST ZONE______.mp3')
pygame.mixer.music.play(-1, 0.0, 5000)
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

# Add new constant for blue platforms
LEVEL_BLUE_DATA = {
    0: [


    ],
    1: [

    ],
    2: [
        (23.2, 3.6, 3, 1.1),
        (26.4, 10.2, 4.8, 1.4),
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6),
    ],
    4: [
        (10, 23.4, 11.3, 1.3),
        (18.5, 23.4, 1, 7.6),
    ],
    5: [
        (26.2, 13.5, 1.7, 1.3),
        (26.4, 20, 4.8, 1.3),
        (19.6, 26.7, 5.3, 1.5),
        (41, 26.7, 5, 1.5),
        (31.1, 26.7, 3.3, 1.5),
    ]
}

# Level platform data (you'll need to adjust these coordinates based on your level designs)
LEVEL_PLATFORM_DATA = {
    0: [
            # Top platforms
            (5.2, 13.4, 6, 2.5),    
            (48, 13.4, 6, 2.5),   

            # small-top platform
            (13.3, 15.5, 1.4, 1.0), 
            (44.4, 15.5, 1.6, 1.0), 
            
            # semi-top platform
            (16.7, 16.6, 4.5, 1.0), 
            (38, 16.6, 4.5, 1.0), 

            # Middle platform
            (26.5, 18.3, 6.2, 2.5),  
            
            # Lower platforms
            (34.6, 23.2, 4.8, 2.5),
            (19.9, 23.2, 4.7, 2.5),
            
            # Bottom platforms
            (11.8, 28, 6.2, 2.5),
            (26.6, 28, 6.2, 2.5),
            (41.3, 28, 8, 1.),
            
            # Ground level
            (0, 33, 8, 3.0),
            (51, 33, 8.2, 3.0),
    ],
    1: [
            # 5th layer
            (23.1, 8.4, 4.8, 1.4),
            (44.5, 8.4, 4.8, 1.4),
            (15, 5.1, 6.2, 3),
            (0, 6.8, 9.8, 1.3),

            # 4th layer
            (28.1, 11.7, 6.4, 3),
            (51.2, 11.7, 6.3, 3),

            # 3rd layer
            (24.8, 15.5, 1.4, 1.7),
            (36.3, 16.6, 4.8, 1.3),
            (44.5, 16.6, 4.8, 1.3),

            # 2nd layer
            (51.1, 21.5, 6.4, 3),
            (36.3, 23.2, 6.4, 1),
            (18.3, 19.9, 9.6, 3),
            (31.3, 19.9, 3.3, 1.4),

            # Ground level
            (44.6, 26.4, 6.4, 3),
            (33, 29.7, 9.7, 3),
            (16.6, 28.1, 4.8, 1.4),
            (16.6, 34.7, 16, 12),

            # Ground Pillars
            (11.7, 23.2, 3.1, 12),
            (6.7, 26.4, 3.1, 9),
            (1.7, 29.8, 3.1, 6)
    ],
    2: [
            # 7th layer
            (13.5, 2, 7.6, 4),
            (10.1, 3.7, 3, 1),
            (0.3, 3.7, 4.6, 1),
            (5.2, 5.3, 1.3, 1),

            # 6th layer
            (51.3, 10.2, 7.5, 5.7),
            (5.2, 8.6, 4.6, 1),

            # 5th layer
            (43, 11.9, 6.3, 1),
            (11.8, 13.5, 4.6, 1),
            (0.2, 13.5, 4.6, 1),

            # 4th layer
            (31.7, 18.1, 1.8, 1.3),
            (42.3, 18.1, 1.8, 1.3),
            (33.3, 15.2, 9.2, 4),
            (0, 18.4, 9.5, 2.5),

            # 3rd layer
            (47.9, 20, 4.7, 1),
            (29.85, 20, 1.3, 1),
            (13.4, 21.7, 6.2, 1),
            (9.9, 20.1, 1.7, 1),

            # 2nd layer
            (48, 26.7, 6.2, 1),
            (41.4, 23.4, 4.6, 1),
            (26.7, 23.4, 7.6, 2.5),
            (7, 25, 14, 5),

            # Ground level
            (0.5, 28.4, 6.6, 8.0),
            (21, 28.4, 6.7, 8.0),
            (43.2, 31.7, 27, 5.0),

            # Ground Pillars
            (39.8, 31.7, 1.2, 3),
            (34.8, 31.7, 1.2, 3),
            (29.9, 31.7, 1.2, 3)
    ],
    3: [
            # 6th layer
            (3.5, 7, 6.2, 1),
            (0.3, 2, 4.3, 2.5),
            (20, 8.5, 3, 1),
            (46.4, 8.5, 11.4, 1),
            (57.8, 0.4, 1.3, 9),
            (29.9, 3.7, 9.5, 1),
            (48, 3.7, 4.6, 1),
            

            # 5th layer
            (26.4, 11.5, 2.8, 1.3),
            (25, 8.6, 1.4, 4.3),
            (11.5, 10.2, 5, 1),


            # 4th layer
            (18.1, 10.3, 1.7, 5.8),
            (7.1, 14.8, 10.9, 1.3),
            (31.5, 13.6, 3, 0.8),
            (36.5, 16.8, 7.8, 0.8),

            # 3rd layer
            (51.3, 20.1, 2.8, 5.7),
            (44.8, 20.1, 2.8, 5.7),
            (47.6, 24.8, 3.8, 1),
            (33.2, 23.4, 7.8, 1),
            (9.9, 25, 11.3, 1),
            (1.4, 20.1, 6.5, 5.8),
            (23.4, 18.5, 7.5, 4.2),
            (11.8, 21.8, 3, 0.8),
            (1.7, 13.6, 1.6, 1),
            (37.9, 11.9, 1.6, 1),
            (43, 10.3, 1.2, 2.7),
            (16.7, 13.5, 1.3, 1.3),
            

            # 2nd layer
            (34.8, 30, 2.9, 1),
            (26.7, 26.7, 5.9, 1),
            (31.3, 26.7, 1.4, 5.8),
            (23.6, 31.3, 7.7, 1.2),
            (10, 28.4, 4.8, 1),
            (21.6, 21.9, 1.4, 2.3),
            (19.8, 18.5, 1.6, 1),
            (8.3, 20, 1.6, 1),
            (0.1, 18.4, 1.6, 1),


            # Ground level
            (0.3, 35, 19, 6),
            (23.4, 35, 20.6, 6),
            (46.6, 35, 12.6, 6)
    ],
    4: [
            # 4th layer
            (33.2, 15.2, 7.8, 5.8),
            (31.3, 16.8, 2, 1),

            (6.8, 11.9, 5, 1),
            (10.2, 5.3, 3, 2.4),
            (15, 21.9, 1.2, 2),
            (13, 7, 1.8, 2.3),

            (19.9, 7, 1.2, 2.3),
            (21.4, 5.2, 1.3, 11),
            (22.6, 7, 1.8, 1),
            (11.9, 5.3, 1.1, 10.9),
            (13, 14.9, 8.4, 1.3),
            (16.4, 8.5, 1.7, 1),
            (14.9, 11.9, 5, 1),

            (24.8, 11.9, 3, 1),
            (46, 11.9, 5, 1),
            (44.4, 16.8, 6.6, 1),

            (51, 20, 8, 1),
            (38.1, 0, 1.3, 8),
            (39.3, 6.8, 6.3, 1.2),
            (39.3, 3.5, 1.7, 1),



            # 3rd layer
            (8.5, 21.8, 1.5, 1),
            (21.2, 21.8, 1.5, 1),
            (16.9, 29.5, 1.6, 1.5),
            (19.4, 29.5, 1.6, 1.5),
            (26.4, 20, 1.8, 1),
            (29.4, 20, 1.8, 1),
            (28.2, 15.2, 1.2, 9.3),
            (26.4, 23.4, 1.8, 1),
            (29.4, 23.4, 3.3, 1),
            

            # 2nd layer
            (6.9, 28.3, 4.3, 1),
            (1.7, 25, 6.3, 1),
            (0, 20, 8, 1),
            (0, 15.1, 5, 1),
            (11.9, 26.7, 1.3, 6),
            (13, 31.2, 1.3, 1.4),
            (11.9, 26.6, 6.7, 1),
            (23, 26.7, 5, 1),
            (33, 26.7, 3, 1),
            (39, 38.2, 5, 1),
            (29.8, 30, 3, 1),
            (56, 30, 3, 1),
            (41, 23.4, 5, 1),
            (52.9, 33.1, 2.9, 4),
            (38, 28.2, 5, 1),
            (46, 26.7, 6.7, 5.8),
            (44.7, 31.2, 1.5, 1.3),


            # Ground level
            (0, 33.3, 6.3, 6),
            (6.7, 34.9, 3, 6),
            (11.6, 34.9, 8.1, 6),
            (21.6, 34.9, 1.3, 6),
            (23, 33.2, 6.5, 0.9),
            (34.7, 33.3, 9.5, 6)
    ],
    5: [

            (0, 5.2, 9.5, 1),
            (0, 13.5, 11.4, 1),
            (0.2, 23.4, 1.1, 14),
            (3.5, 26.7, 1.4, 11),

            (6.8, 30, 3, 1),
            (6.7, 23.4, 3, 1),
            (10, 18.5, 4.6, 1),
            (10, 26.7, 8.2, 1.5),
            (26.3, 26.7, 5.3, 1.5),
            (36.1, 26.7, 3.7, 1.5), 

            (15, 13.5, 3, 1), 
            (18, 8.5, 5, 1),
            (49.3, 30, 3.3, 1.1), 
            (46, 23.3, 6.5, 1),
            (44.4, 18.5, 4.8, 1),

            (16.5, 20, 5, 1.3),
            (23, 20, 1.7, 1.3),
            (33, 20, 3.3, 1.3),
            (38, 20, 4.7, 1.3),
            (41.2, 13.5, 3.2, 1),
            (29.7, 7, 6.5, 1.1),
            (22.9, 7, 5, 1.2),

            (19.8, 13.5, 5, 1.3),
            (29.6, 13.5, 1.7, 1.3),
            (34.4, 13.5, 5.2, 1.3),
            (36.4, 8.5, 4.5, 1.2),
            (42.9, 5.3, 6.5, 1),
            (51, 15, 8, 1),

            (15.1, 26.8, 1, 8),
            (43.1, 26.8, 1, 8),
            (21.7, 13.6, 1.2, 7.7),
            (36.5, 13.6, 1.2, 7.7),
            (18.4, 20, 1, 8.1), 
            (39.9, 20, 1, 8.1),
            (25, 7, 1, 7.8),
            (33.3, 7, 1, 7.8),

            (54.5, 26.8, 1.2, 11),
            (57.9, 23.4, 1.2, 14),
            (51.3, 3.2, 1.5, 6.3),
            (53, 8.3, 4.4, 1.3),
            (57.6, 3.3, 1.5, 6),
            (54.3, 5, 1.7, 1.3),

            (28.2, 12, 1.2, 2.5), 
            (31.5, 18.5, 1.3, 2.5),
            (25, 25, 1, 3),
            (34.9, 31.7, 1, 3),
            (17.7, 31.5, 1.8, 1),

            (9.9, 33.2, 5, 1.3),
            (19.4, 33.2, 7.3, 1.3),
            (29.4, 33.2, 5.4, 1.3),
            (36, 33.2, 5.5, 1.3),
            (44, 33.2, 5.3, 1.3)
    ]
}

# Level backgrounds
level_backgrounds = {
    0: pygame.image.load('Level Data/Level Image/LEVEL0.png'),
    1: pygame.image.load('Level Data/Level Image/LEVEL1.png'),
    2: pygame.image.load('Level Data/Level Image/Level2game!.png'),
    3: pygame.image.load('Level Data/Level Image/Level3game!!.png'),
    4: pygame.image.load('Level Data/Level Image/Level4.png'),
    5: pygame.image.load('Level Data/Level Image/Level5.png')
}

# Update the background scaling code:
for level in level_backgrounds:
    orig_bg = level_backgrounds[level]
    level_backgrounds[level] = pygame.transform.scale(orig_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))

# Update collision tile creation (in World class):
def __init__(self, level_data, deadly_data):
    self.collision_tiles = []
    self.deadly_tiles = []

    for plat in level_data:
        # Adjust coordinates to align with background
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        height = int(plat[3] * TILE_SIZE)
        
        # Add small margin for better collision
        margin = 2
        collision_rect = pygame.Rect(
            x + margin,
            y + margin,
            width - margin * 2,
            height - margin * 2
        )
        self.collision_tiles.append(CollisionTile(x, y, width, height))

    for deadly in deadly_data:
        x = deadly[0] * TILE_SIZE
        y = deadly[1] * TILE_SIZE
        width = deadly[2] * TILE_SIZE
        height = int(deadly[3] * TILE_SIZE)
        
        # Add similar margin for deadly tiles
        margin = 2
        self.deadly_tiles.append(CollisionTile(
            x + margin, 
            y + margin, 
            width - margin * 2, 
            height - margin * 2
        ))

    
# Add Level 0 to LEVEL_REQUIREMENTS
LEVEL_REQUIREMENTS = {
    0: 3,  # For tutorial level
    1: 4,
    2: 5,
    3: 6,
    4: 8,
    5: 10
}

# Update STORYLINE dictionary to match story document
STORYLINE = {
    "intro": [
        "You remember the moment you stumbled upon the ancient artifact, half-buried in the basement of that old library.",
        "It was a stone box, covered in intricate, interlocking symbols that seemed to shift if you stared too long.",
        "As you worked, carefully pressing and turning parts of the stone, the symbols clicked into alignment.",
        "The box opened, releasing a chill that seeped straight to your bones.",
        "Inside was a brittle parchment with haunting words: 'Whoever unlocks these secrets is bound to us.'",
        "'Your presence is now required. The island awaits.'"
    ],
    "level0": [
        "The ghostly voice of Eralt lingers in the air as you begin.",
        '"Beware, young master. The island knows your fears, your weaknesses."',
        '"Solve the code, and move closer to your destiny."',
        '"Fail, and join the lost souls who could not decode the island\'s secrets."',
        '"Master?.." With your heart pounding, you take a deep breath and step forward,',
        "ready to solve the first of many mysteries in this shadowy realm."
    ],
    "level1": [
        "As you decipher the shifting symbols on the stone slab, a sudden flash of blinding light erupts.",
        "When it fades, a figure steps forward with silent, lethal grace.",
        "Dressed in dark, flowing robes and wielding twin daggers that glint in the moonlight,",
        "she introduces herself with a cold smile.",
        '"I am Palak, the Assassin, Guardian of the First Level."',
        '"To pass my challenge, you must prove you can see through deception and lies."',
        '"Codes are more than wordsthey\'re veils of truth and deceit. Decipher mine, or face the consequences."'
    ],
    "level2": [
        "The mist pulls you forward to a spiraling tower covered in ancient runes.",
        "At the top waits Russ, the Wizard. His eyes hold the gleam of forbidden knowledge.",
        '"Ah, the new champion has arrived."',
        "He gestures to a puzzle box floating in mid-air, surrounded by a shimmering aura.",
        '"This test is one of patience and intellect."',
        '"You must unlock this box without using brute force; the wrong twist will reset it."',
        '"Fail, and your mind will be trapped in an endless loop."'
    ],
    "level3": [
        "The scenery morphs into a grand, oppressive throne room.",
        "Seated on the throne is Geoff, the Autocrat, draped in black, a crown of thorns upon his brow.",
        '"So you\'ve passed the others. But codes are not just puzzles; they\'re tools of control, of power."',
        '"I rule through secrets."',
        "He gestures to an enormous map with encrypted marks scattered across it.",
        '"Your task is to decipher the locations on this map."',
        '"Fail, and you will be exiled into the barren lands."'
    ],
    "level4": [
        "The shadows deepen, and you're surrounded by a ghostly fog.",
        "From it, a figure in tattered, ethereal robes emergesJessica, the Wraith.",
        "Her eyes glow with an eerie, otherworldly light as she glides toward you.",
        '"You are brave, but bravery means nothing in the face of fear."',
        '"This trial is not of logic, but of your darkest nightmares."',
        "A mirror appears, showing twisted images of your deepest fears.",
        '"Face your fears, or be lost to them forever."'
    ],
    "level5": [
        "You arrive at a shadowy castle ruin where the final guardian awaits: Jacobo, the Undead King.",
        "His skeletal form radiates an unholy power, and his hollow eyes burn with a fierce light.",
        '"You stand before the final trial, mortal."',
        '"I am Jacobo, the Undead King, master of the lost and forgotten."',
        '"To claim victory, you must decipher the oldest code of all,"',
        '"the language of life and death itself."'
    ],
    "ending": [
        "The tome releases a blinding light. When it fades, you're back on the beach.",
        "The island seems quiet, as if holding its breath. But something is differentyou can feel it.",
        "As you touch the sand, it shifts, forming into a new message:",
        '"Congratulations, you have proven yourself. But know this:"',
        '"The title of decoding master is not a prize, but a burden."',
        '"The codes you hold now contain secrets that even the spirits dare not speak."',
        '"Guard them well, for they will change everything."'
    ]
}

# Update LEVEL_DIALOGUES dictionary to add Level 0
LEVEL_DIALOGUES = {
    0: [
        "Tutorial Level: Learning the Basics",
        "Master the art of movement and key collection.",
        "Collect 3 keys to proceed to your first real challenge.",
        "Press SPACE to continue..."
    ],
    1: [
        "Level 1: The Assassin's Trial",
        "Find 4 keys while avoiding deadly traps.",
        "Press SPACE to continue..."
    ],
    2: [
        "Level 2: The Wizard's Tower",
        "Collect 5 keys hidden by magical illusions.",
        "Press SPACE to continue..."
    ],
    3: [
        "Level 3: The Autocrat's Domain",
        "Gather 6 keys from this sprawling fortress.",
        "Press SPACE to continue..."
    ],
    4: [
        "Level 4: The Wraith's Nightmare",
        "Find 8 keys in this realm of shadows.",
        "Press SPACE to continue..."
    ],
    5: [
        "Final Level: The Undead King's Castle",
        "Collect all 10 keys to complete your journey.",
        "Press SPACE to continue..."
    ]
}

LEVEL_DEADLY_DATA = {
    0: [

        
    ],
    1: [
        
    ],
    2: [
        (23.2, 3.6, 3, 1),
        (26.4, 10.2, 4.8, 1.3),
        (28, 34, 15, 1)
    ],
    3: [
        (19.9, 1.9, 3, 1.4),
        (47.7, 13.5, 3.2, 1.3),
        (19.5, 35, 3.7, 6),
        (44.2, 35, 2.2, 6),
    ],
    4: [
        (10, 22.4, 11.3, 1.3),
        (22, 13.8, 2, 2),
        (20, 22.4, 2.4, 2),
    ],
    5: [
        (0.2, 34, 59, 4),
        (15.4, 28, 2.2, 3),
        (22, 25.4, 2, 2),
        (25, 12, 2.4, 2.7),
        (28.4, 18.7, 2.4, 2.3),
        (31.8, 25.2,  2.3, 2),
        (26.9, 32, 2, 2),
        (40.2, 25.3, 2, 2),
        (41.7, 30.3, 2, 2),
    ]
}

# Update LEVEL_ENEMY_DATA to include boundary information:
LEVEL_ENEMY_DATA = {
    0: [

        
    ],
    1: [
        (17, 33.4, "horizontal", 17, 32),
        (0.2, 5.5, "horizontal", 0.2, 8.5),
        (36.2, 22, "horizontal", 36.2, 41.2),
        (50.5, 10.6, "horizontal", 50.5, 56),    # x, y, direction, boundary_start, boundary_end
        (18.5, 19, "horizontal", 18.5, 27.2)  # x, y, direction, boundary_start, boundary_end
    ],
    2: [
        (8.5, 24, "horizontal", 8.5, 20),
        (0.2, 17.2, "horizontal", 0.2, 8.7),
        (44.5, 30.5, "horizontal", 44, 58.5),
        (35, 14, "horizontal", 35, 41),
        (52.3, 9.1, "horizontal", 52.3, 58.5),
        
    ],
    3: [
        (10.5, 24, "horizontal", 10.5, 20.5),
        (24, 34, "horizontal", 24, 43),
        (18, 13.6, "horizontal", 18, 26.5),
        (30, 3.6, "horizontal", 30, 38.5),
        (48, 6.4, "horizontal", 48, 57),
        (37.5, 15.8, "horizontal", 37.5, 43.5),
    ],
    4: [

    ],
    5: [

    ]
}

class DialogueBox:
    def __init__(self, screen):
        self.screen = screen
        self.animation_complete = False
        self.current_alpha = 0
        self.target_alpha = 230
        self.fade_speed = 10
        self.current_line = 0
        self.current_word = 0
        self.current_char = 0
        self.text_delay = 2  # Controls typing speed
        self.frame_counter = 0
        self.words_revealed = []  # List to store revealed words for each line
        
    def animate(self, dialogue_lines):
        # Create semi-transparent background
        dialogue_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT))
        dialogue_surface.fill(BLACK)
        
        # Animate fade in
        if self.current_alpha < self.target_alpha:
            self.current_alpha = min(self.current_alpha + self.fade_speed, self.target_alpha)
        dialogue_surface.set_alpha(self.current_alpha)
        self.screen.blit(dialogue_surface, (0, 0))
        
        # Initialize words_revealed list if needed
        if not self.words_revealed:
            self.words_revealed = [[] for _ in dialogue_lines]
        
        # Calculate text position for centering
        total_height = len(dialogue_lines) * 60
        start_y = (SCREEN_HEIGHT - total_height) // 2
        
        # Update text animation
        self.frame_counter += 1
        if self.frame_counter >= self.text_delay:
            self.frame_counter = 0
            self.update_text(dialogue_lines)
        
        # Draw text
        for i, line in enumerate(dialogue_lines):
            # Split line into words
            words = line.split()
            revealed_text = ' '.join(self.words_revealed[i])
            
            text_surface = pygame.font.SysFont('Bauhaus 93', 40).render(
                revealed_text, True, WHITE)
            text_rect = text_surface.get_rect(center=(SCREEN_WIDTH // 2, start_y + i * 60))
            self.screen.blit(text_surface, text_rect)
        
        # Add "Press SPACE to continue" prompt when animation is complete
        if self.animation_complete:
            prompt = pygame.font.SysFont('Bauhaus 93', 30).render(
                "Press SPACE to continue...", True, (200, 200, 200))
            prompt_rect = prompt.get_rect(center=(SCREEN_WIDTH // 2, SCREEN_HEIGHT - 50))
            self.screen.blit(prompt, prompt_rect)
        
        return self.animation_complete
    
    def update_text(self, dialogue_lines):
        if self.current_line < len(dialogue_lines):
            words = dialogue_lines[self.current_line].split()
            
            if self.current_word < len(words):
                # Add next word
                self.words_revealed[self.current_line].append(words[self.current_word])
                self.current_word += 1
            else:
                # Move to next line
                self.current_line += 1
                self.current_word = 0
        else:
            self.animation_complete = True

# Update the show_dialogue function to properly handle space key:
def show_dialogue(dialogue_lines):
    dialogue_box = DialogueBox(screen)
    
    waiting = True
    space_pressed = False
    
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                    return True  # Always return True when space is pressed
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

class Camera:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.scroll_x = 0
        self.scroll_y = 0
        self.zoom = 1  # Start at no zoom
        self.target_zoom = 2  # Target zoom level
        self.zoom_speed = 0.02  # Speed of zoom animation
        self.transitioning = False
        self.transition_start_time = 0
        self.transition_delay = 2000  # 2 second delay before starting zoom
        self.transition_duration = 2000  # 2 seconds for the actual zoom
        self.transition_total_time = self.transition_delay + self.transition_duration
        self.transition_complete = False  # New flag to track completion
        
        # Calculate the visible area dimensions
        self.visible_width = width
        self.visible_height = height
        
    def start_transition(self):
        self.transitioning = True
        self.transition_complete = False
        self.zoom = 1
        self.transition_start_time = pygame.time.get_ticks()
    
    def update(self, target):
        current_time = pygame.time.get_ticks()
        
        # Handle zoom transition
        if self.transitioning:
            elapsed = current_time - self.transition_start_time
            
            # Wait for delay before starting zoom
            if elapsed >= self.transition_delay:
                # Calculate progress only for the zoom portion
                zoom_elapsed = elapsed - self.transition_delay
                progress = min(zoom_elapsed / self.transition_duration, 1.0)
                
                # Use easing function for smooth transition
                progress = self.ease_out_cubic(progress)
                self.zoom = 1 + (self.target_zoom - 1) * progress
                
                if progress >= 1:
                    self.transitioning = False
                    self.zoom = self.target_zoom
                    self.transition_complete = True  # Mark transition as complete
            
        # Update visible area based on current zoom
        self.visible_width = self.width // self.zoom
        self.visible_height = self.height // self.zoom
        
        # Center the camera on the target (player)
        self.scroll_x = target.rect.centerx - self.visible_width // 2
        self.scroll_y = target.rect.centery - self.visible_height // 2
        
        # Keep the camera within the level bounds
        self.scroll_x = max(0, min(self.scroll_x, SCREEN_WIDTH - self.visible_width))
        self.scroll_y = max(0, min(self.scroll_y, SCREEN_HEIGHT - self.visible_height))
    
    def ease_out_cubic(self, x):
        # Cubic easing function for smooth animation
        return 1 - pow(1 - x, 3)

    def apply(self, surface, entity):
        # Create a new rect for the entity's position relative to the camera
        return pygame.Rect(
            entity.rect.x - self.scroll_x,
            entity.rect.y - self.scroll_y,
            entity.rect.width,
            entity.rect.height
        )

    def apply_sprite(self, surface, sprite):
        # Return the position where the sprite should be drawn
        return (sprite.rect.x - self.scroll_x,
                sprite.rect.y - self.scroll_y)
                
    def apply_rect(self, rect):
        # Apply camera offset to a rect
        return pygame.Rect(
            rect.x - self.scroll_x,
            rect.y - self.scroll_y,
            rect.width,
            rect.height
        )


def create_zoomed_view(screen, camera, player, world, keys_group, door, npc, moving_enemies):
    # Calculate current visible area based on zoom level
    current_visible_width = int(SCREEN_WIDTH // camera.zoom)
    current_visible_height = int(SCREEN_HEIGHT // camera.zoom)
    
    # Create a subsurface for the visible area
    view_surface = pygame.Surface((current_visible_width, current_visible_height))
    
    # Draw the background portion that's visible
    view_surface.blit(level_backgrounds[current_level], 
                     (-camera.scroll_x, -camera.scroll_y))
    
    # Draw all game objects on the zoomed surface
    for key in keys_group:
        pos = camera.apply_sprite(view_surface, key)
        if (0 <= pos[0] < current_visible_width and 
            0 <= pos[1] < current_visible_height):
            view_surface.blit(key.image, pos)
    
    # Draw door and NPC with visibility check
    door_pos = camera.apply_sprite(view_surface, door)
    npc_pos = camera.apply_sprite(view_surface, npc)
    if (0 <= door_pos[0] < current_visible_width and 
        0 <= door_pos[1] < current_visible_height):
        view_surface.blit(door.image, door_pos)
    if (0 <= npc_pos[0] < current_visible_width and 
        0 <= npc_pos[1] < current_visible_height):
        view_surface.blit(npc.image, npc_pos)
    
    # Draw enemies
    for enemy in moving_enemies:
        enemy_pos = camera.apply_sprite(view_surface, enemy)
        if (0 <= enemy_pos[0] < current_visible_width and 
            0 <= enemy_pos[1] < current_visible_height):
            view_surface.blit(enemy.image, enemy_pos)
    
    # Draw player
    player_pos = camera.apply_sprite(view_surface, player)
    if (0 <= player_pos[0] < current_visible_width and 
        0 <= player_pos[1] < current_visible_height):
        view_surface.blit(player.image, player_pos)
    
    # Scale the view surface to fill the screen
    scaled_surface = pygame.transform.scale(view_surface, (SCREEN_WIDTH, SCREEN_HEIGHT))
    screen.blit(scaled_surface, (0, 0))
    
    # Draw HUD elements
    draw_text(f"Level {current_level}", 40, WHITE, 10, 10)
    draw_text(f"Keys: {keys_collected}/{LEVEL_REQUIREMENTS[current_level]}", 40, WHITE, 10, 60)

    
class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Key(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = key_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

class Door(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = door_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

class NPC(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = npc_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y


class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2))
        
        for i in range(1, 5):
            img = pygame.image.load(f'img/dino{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, player_size)
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def update(self, game_over, world, keys_group, camera):  # Add camera parameter
        global keys_collected
        
        dx = 0
        dy = 0
        walk_cooldown = 5

        if game_over == 0:
            # Only process movement if camera transition is complete
            if camera.transition_complete:
                key = pygame.key.get_pressed()
                
                if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                    jump_fx.play()
                    self.vel_y = JUMP_SPEED
                    self.jumped = True
                    self.in_air = True
                
                if not key[pygame.K_SPACE]:
                    self.jumped = False

                if key[pygame.K_LEFT]:
                    dx -= MOVE_SPEED
                    self.counter += 1
                    self.direction = -1
                if key[pygame.K_RIGHT]:
                    dx += MOVE_SPEED
                    self.counter += 1
                    self.direction = 1
                if not key[pygame.K_LEFT] and not key[pygame.K_RIGHT]:
                    self.counter = 0
                    self.index = 0
                    if self.direction == 1:
                        self.image = self.animations_right[self.index]
                    else:
                        self.image = self.animations_left[self.index]

                # Handle animation
                if self.counter > walk_cooldown:
                    self.counter = 0
                    self.index += 1
                    if self.index >= len(self.animations_right):
                        self.index = 0
                    if self.direction == 1:
                        self.image = self.animations_right[self.index]
                    else:
                        self.image = self.animations_left[self.index]

            # Always apply gravity regardless of camera state
            self.vel_y += GRAVITY
            if self.vel_y > 10:
                self.vel_y = 10
            dy += self.vel_y

            # Check for collision with keys
            key_hits = pygame.sprite.spritecollide(self, keys_group, True)
            keys_collected += len(key_hits)

            # Assume we're in the air unless collision detection proves otherwise
            self.in_air = True

            # Check for collision
            dx, dy = world.check_collision(self, dx, dy)

            # Update player position
            self.rect.x += dx
            self.rect.y += dy

            # Keep player on screen
            if self.rect.left < 0:
                self.rect.left = 0
            if self.rect.right > SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH
                
            # Check if player has fallen off the map
            if self.rect.top > SCREEN_HEIGHT:
                game_over = -1
                game_over_fx.play()

        elif game_over == -1:
            self.image = self.dead_image
            if self.rect.y > 200:
                self.rect.y -= 5

        return game_over

class World:
    def __init__(self, level_data, deadly_data):
        self.collision_tiles = []
        self.deadly_tiles = []
        self.blue_tiles = []  # Initialize blue_tiles list

        # Create collision tiles
        for plat in level_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            
            offset_x = 0
            offset_y = 0
            
            collision_rect = pygame.Rect(
                x + offset_x,
                y + offset_y,
                width,
                height
            )
            self.collision_tiles.append(CollisionTile(x + offset_x, y + offset_y, width, height))

        # Create deadly tiles
        for deadly in deadly_data:
            x = deadly[0] * TILE_SIZE
            y = deadly[1] * TILE_SIZE
            width = deadly[2] * TILE_SIZE
            height = int(deadly[3] * TILE_SIZE)
            
            self.deadly_tiles.append(CollisionTile(x, y, width, height))

        # Create blue tiles
        if current_level in LEVEL_BLUE_DATA:
            for blue in LEVEL_BLUE_DATA[current_level]:
                x = blue[0] * TILE_SIZE
                y = blue[1] * TILE_SIZE
                width = blue[2] * TILE_SIZE
                height = int(blue[3] * TILE_SIZE)
                
                self.blue_tiles.append(CollisionTile(x, y, width, height))

                '''    def draw(self, screen):
                        # Draw regular collision tiles in red
                        for tile in self.collision_tiles:
                            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)
                        
                        # Draw deadly tiles in green
                        for tile in self.deadly_tiles:
                            pygame.draw.rect(screen, (0, 255, 0), tile.rect, 2)
                        
                        # Draw blue tiles in blue
                        for tile in self.blue_tiles:
                            pygame.draw.rect(screen, (0, 0, 255), tile.rect, 1)'''

    def check_collision(self, player, dx, dy):
        # Check collision with both regular and blue tiles
        for tile in self.collision_tiles + self.blue_tiles:
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False
                    
        # Check deadly collisions
        for tile in self.deadly_tiles:
            if tile.rect.colliderect(player.rect):
                return "deadly"
                
        return dx, dy

def init_level(level_num):
    global keys_collected, game_start_time, current_level
    keys_collected = 0
    current_level = level_num
    
    if game_start_time is None:
        game_start_time = time.time()
    
    # Create and initialize level objects as before
    keys_group = pygame.sprite.Group()
    key_positions = generate_key_positions(level_num)
    for pos in key_positions:
        keys_group.add(Key(pos[0], pos[1]))
    
    platforms = LEVEL_PLATFORM_DATA[level_num]
    suitable_platform = find_suitable_platform(platforms)
    
    platform_x = suitable_platform[0]
    platform_y = suitable_platform[1]
    platform_width = suitable_platform[2]
    
    door_x = (platform_x + platform_width - 2) * TILE_SIZE
    door_y = (platform_y - 2) * TILE_SIZE
    
    if door_x > SCREEN_WIDTH - 3 * TILE_SIZE:
        door_x = SCREEN_WIDTH - 3 * TILE_SIZE
    
    door = Door(door_x, door_y)
    npc = NPC(door_x - TILE_SIZE * 2, door_y)
    
    deadly_tiles = LEVEL_DEADLY_DATA[level_num]
    world = World(platforms, deadly_tiles)
    
    spawn_x = 100
    spawn_y = 0
    
    ground_platforms = []
    for plat in platforms:
        if plat[1] > (SCREEN_HEIGHT / TILE_SIZE) * 0.7:
            ground_platforms.append(plat)
    
    if ground_platforms:
        leftmost = sorted(ground_platforms, key=lambda p: p[0])[0]
        spawn_x = (leftmost[0] + 1) * TILE_SIZE
        spawn_y = leftmost[1] * TILE_SIZE - TILE_SIZE * 2
    
    player = Player(spawn_x, spawn_y)
    
    moving_enemies.empty()
    for enemy_data in LEVEL_ENEMY_DATA[level_num]:
        x, y, direction, boundary_start, boundary_end = enemy_data
        enemy = MovingEnemy(x, y, direction, boundary_start, boundary_end)
        moving_enemies.add(enemy)
    
    # Don't start camera transition here anymore
    return keys_group, door, npc, world, moving_enemies, player


class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(npc_img, (TILE_SIZE, TILE_SIZE))
        self.rect = self.image.get_rect()
        self.rect.x = x * TILE_SIZE
        self.rect.y = y * TILE_SIZE
        self.direction = direction
        self.speed = 2
        self.moving_right = True
        self.moving_down = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE
        self.initial_pos = self.rect.x if direction == "horizontal" else self.rect.y

    def update(self):
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)
        else:  # vertical movement
            if self.moving_down:
                self.rect.y += self.speed
                if self.rect.y >= self.boundary_end:
                    self.moving_down = False
            else:
                self.rect.y -= self.speed
                if self.rect.y <= self.boundary_start:
                    self.moving_down = True

    def draw_boundaries(self, screen):
        # Draw movement boundaries (for debugging)
        if self.direction == "horizontal":
            pygame.draw.line(screen, (255, 0, 0),
                           (self.boundary_start, self.rect.centery),
                           (self.boundary_end, self.rect.centery), 2)
        else:
            pygame.draw.line(screen, (255, 0, 0),
                           (self.rect.centerx, self.boundary_start),
                           (self.rect.centerx, self.boundary_end), 2)

    def check_collision(self, player):
        # Create a slightly smaller collision rect for more forgiving collisions
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button:
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self, screen):
        action = False
        # Get mouse position
        pos = pygame.mouse.get_pos()  # This gets the (x, y) position of the mouse

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and not self.clicked:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font_size, color, x, y):
    font = pygame.font.SysFont('Bauhaus 93', font_size)
    img = font.render(text, True, color)
    screen.blit(img, (x, y))

# Update the show_dialogue function:
def show_dialogue(dialogue_lines):
    dialogue_box = DialogueBox(screen)
    
    waiting = True
    while waiting:
        clock.tick(60)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_SPACE and dialogue_box.animation_complete:
                    waiting = False
                elif event.key == pygame.K_ESCAPE:
                    return False
        
        dialogue_box.animate(dialogue_lines)
        pygame.display.update()
    
    return True

def find_suitable_platform(platforms):
    """
    Find a suitable platform for door placement using better criteria:
    1. Platform must be wide enough for door and NPC
    2. Platform should be reasonably high up but not necessarily the highest
    3. Platform should have enough space above it
    """
    # Sort platforms by height (y-coordinate), from top to bottom
    sorted_platforms = sorted(platforms, key=lambda p: p[1])
    
    # Required width for door and NPC (in tile units)
    required_width = 4  # Space for door and NPC
    
    # Check top 1/3 of platforms for a suitable spot
    top_third = len(sorted_platforms) // 3
    if top_third < 1:
        top_third = 1
    
    for platform in sorted_platforms[:top_third]:
        # Get platform dimensions
        x, y, width, height = platform
        
        # Check if platform is wide enough
        if width >= required_width:
            # Check if there's another platform directly above
            has_obstruction = False
            platform_top = y
            platform_left = x
            platform_right = x + width
            
            # Check for obstructions above
            for other_platform in platforms:
                other_x, other_y, other_width, other_height = other_platform
                other_left = other_x
                other_right = other_x + other_width
                other_bottom = other_y + other_height
                
                # Check if there's a platform directly above
                if (other_bottom > platform_top - 4 and  # Leave space for door height
                    other_y < platform_top and
                    other_right > platform_left and
                    other_left < platform_right):
                    has_obstruction = True
                    break
            
            if not has_obstruction:
                return platform
                
    # Fallback to the widest platform in the top half if no perfect match
    top_half = sorted_platforms[:len(sorted_platforms)//2]
    widest_platform = max(top_half, key=lambda p: p[2])
    return widest_platform

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    deadly_tiles = LEVEL_DEADLY_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Function to check if position is safe from deadly tiles
    def is_safe_position(x, y):
        SAFE_DISTANCE = TILE_SIZE * 3  # Minimum distance from deadly tiles
        
        for deadly in deadly_tiles:
            deadly_x = deadly[0] * TILE_SIZE
            deadly_y = deadly[1] * TILE_SIZE
            deadly_width = deadly[2] * TILE_SIZE
            deadly_height = deadly[3] * TILE_SIZE
            
            # Calculate boundaries of the deadly area with safety margin
            deadly_left = deadly_x - SAFE_DISTANCE
            deadly_right = deadly_x + deadly_width + SAFE_DISTANCE
            deadly_top = deadly_y - SAFE_DISTANCE
            deadly_bottom = deadly_y + deadly_height + SAFE_DISTANCE
            
            # Check if key position is within the danger zone
            if (deadly_left < x < deadly_right and 
                deadly_top < y < deadly_bottom):
                return False
        return True
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    attempts = 0
    max_attempts = 100  # Prevent infinite loop
    
    while len(positions) < required_keys and attempts < max_attempts:
        for plat in viable_platforms:
            if len(positions) >= required_keys:
                break
                
            # Try multiple positions on each platform
            for _ in range(5):  # Try 5 times per platform
                # Place key somewhere along the platform
                key_x = plat[0] + random.uniform(TILE_SIZE, plat[2] - TILE_SIZE * 2)
                key_y = plat[1] - TILE_SIZE * 1.5
                
                # Only add position if it's safe
                if is_safe_position(key_x, key_y):
                    positions.append((key_x, key_y))
                    break
            
            attempts += 1
    
    # If we couldn't find enough safe positions, fill remaining with positions farther from platforms
    while len(positions) < required_keys:
        plat = random.choice(viable_platforms)
        key_x = plat[0] + random.uniform(TILE_SIZE * 2, plat[2] - TILE_SIZE * 2)
        key_y = plat[1] - TILE_SIZE * 2  # Place keys higher above platform
        if is_safe_position(key_x, key_y):
            positions.append((key_x, key_y))
    
    return positions

def generate_key_positions(level):
    positions = []
    required_keys = LEVEL_REQUIREMENTS[level]
    platforms = LEVEL_PLATFORM_DATA[level]
    
    # Get viable platform positions (excluding ground platforms)
    viable_platforms = []
    for plat in platforms:
        # Convert platform coordinates to screen coordinates
        x = plat[0] * TILE_SIZE
        y = plat[1] * TILE_SIZE
        width = plat[2] * TILE_SIZE
        
        # Skip very low platforms (ground level)
        if y < SCREEN_HEIGHT * 0.8:  # Only use platforms in upper 80% of screen
            viable_platforms.append((x, y, width))
    
    # Randomly select platforms and place keys on them
    import random
    random.shuffle(viable_platforms)
    
    for i in range(min(required_keys, len(viable_platforms))):
        plat = viable_platforms[i]
        # Place key somewhere along the platform
        key_x = plat[0] + random.uniform(0, plat[2] - TILE_SIZE)
        key_y = plat[1] - TILE_SIZE * 1.5  # Place key above platform
        positions.append((key_x, key_y))
    
    return positions

# Initialize game state
current_state = "start_screen"
start_button = Button(SCREEN_WIDTH // 2 - 150, SCREEN_HEIGHT // 2, start_btn)
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)
camera = Camera(SCREEN_WIDTH, SCREEN_HEIGHT)

# Create initial player and world objects
player = Player(100, SCREEN_HEIGHT - 130)
world = World(LEVEL_PLATFORM_DATA[1], LEVEL_DEADLY_DATA[1])  # Initialize with level 1 data

# Game loop
clock = pygame.time.Clock()
fps = 60
running = True
moving_enemies = pygame.sprite.Group()
game_over = 0  # Make sure game_over is initialized

while running:
    clock.tick(fps)
    print(f"Current resolution: {screen.get_width()}x{screen.get_height()}")
        # Also add these variables at the start of the game loop section:
    if 'elapsed_time' not in locals():
        elapsed_time = 0
    if 'keys_group' not in locals():
        keys_group = pygame.sprite.Group()
    
    # Event handling at the start of the loop
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            running = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                running = False

    if current_state == "start_screen":
        screen.blit(start_bg, (0, 0))
        current_state = "intro_dialogue"

    elif current_state == "intro_dialogue":
        if show_dialogue(STORYLINE["intro"]):
            if show_dialogue(STORYLINE["level0"]):  # Show Level 0 dialog first
                current_state = "playing"
                current_level = 0
                keys_group, door, npc, world, moving_enemies, player = init_level(current_level)
        else:
            current_state = "playing"
            current_level = 0  # Start with Level 0 instead of Level 1
            keys_group, door, npc, world, moving_enemies, player = init_level(current_level)
    
    elif current_state == "playing":
        # Create unique keys for tracking dialogue states
        storyline_key = f'storyline_{current_level}'
        level_key = f'level_{current_level}'
        transition_key = f'transition_{current_level}'
        
        # Initialize states if needed
        if storyline_key not in dialogue_states:
            dialogue_states[storyline_key] = False
        if level_key not in dialogue_states:
            dialogue_states[level_key] = False
        if transition_key not in dialogue_states:
            dialogue_states[transition_key] = False
        
        # Show storyline dialogue first
        if not dialogue_states[storyline_key]:
            if show_dialogue(STORYLINE[f"level{current_level}"]):
                dialogue_states[storyline_key] = True
            else:
                dialogue_states[storyline_key] = True
        
        # Then show level instructions
        elif not dialogue_states[level_key]:
            if show_dialogue(LEVEL_DIALOGUES[current_level]):
                dialogue_states[level_key] = True
                # Start camera transition after dialogues are complete
                camera.start_transition()
            else:
                dialogue_states[level_key] = True
                camera.start_transition()
        
        # Update and draw game
        camera.update(player)
        create_zoomed_view(screen, camera, player, world, keys_group, door, npc, moving_enemies)
        
        # Check collisions and handle game over
        deadly_collision = world.check_collision(player, 0, 0)
        if deadly_collision == "deadly":
            game_over = -1
            game_over_fx.play()
        
        # Update game objects
        game_over = player.update(game_over, world, keys_group, camera)
        moving_enemies.update()
        
        # Check enemy collisions
        for enemy in moving_enemies:
            if enemy.check_collision(player):
                game_over = -1
                game_over_fx.play()
                break
        
        # Handle game over state
        if game_over == -1:
            draw_text('GAME OVER!', 70, BLUE, (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
            if restart_button.draw(screen):
                game_over = 0
                keys_collected = 0
                keys_group, door, npc, world, moving_enemies, player = init_level(current_level)
        
                # Handle level completion
        # Modify the game loop section that handles level completion:
        # In your game loop, replace the level completion section with:
        # In your game loop, replace the level completion section with:
        elif keys_collected >= LEVEL_REQUIREMENTS[current_level] and pygame.sprite.collide_rect(player, door):
            if current_level == 0:
                # After tutorial completion
                if show_dialogue([f"Tutorial Complete! ",
                                "You've mastered the basics! ",
                                "Press SPACE to begin your real journey..."]):
                    current_level = 1
                    storyline_key = f'storyline_{current_level}'
                    level_key = f'level_{current_level}'
                    dialogue_states[storyline_key] = False
                    dialogue_states[level_key] = False
                    if game_start_time:
                        elapsed_time = int(time.time() - game_start_time)
                        level_times.append(elapsed_time)
                    keys_group, door, npc, world, moving_enemies, player = init_level(current_level)
            else:
                # Save current game state
                current_display = screen.copy()

                # Show pre-minigame dialogue
                if show_dialogue([f"To proceed to the next level,",
                                f"you must complete the challenge! ",
                                "Press SPACE to begin..."]):
                    
                    try:
                        # Run the minigame
                        minigame_result = load_minigame(current_level)

                        if minigame_result:
                            # Player won the minigame
                            if current_level < 5:
                                if show_dialogue([f"Level {current_level} Complete! ",
                                                "You've conquered both challenges! ",
                                                "Press SPACE to continue..."]):
                                    current_level += 1
                                    storyline_key = f'storyline_{current_level}'
                                    level_key = f'level_{current_level}'
                                    dialogue_states[storyline_key] = False
                                    dialogue_states[level_key] = False
                                    if game_start_time:
                                        elapsed_time = int(time.time() - game_start_time)
                                        level_times.append(elapsed_time)
                                    keys_group, door, npc, world, moving_enemies, player = init_level(current_level)
                            else:
                                # Game complete
                                if show_dialogue(["Congratulations! ",
                                                "You've completed all levels! ",
                                                "Press SPACE to see your results..."]):
                                    current_state = "game_complete"
                        else:
                            # Player lost the minigame
                            if show_dialogue([f"Challenge failed! ",
                                            "You must complete this trial to proceed. ",
                                            "Press SPACE to try again..."]):
                                # Restore the main game display
                                screen.blit(current_display, (0,0))
                                pygame.display.flip()

                    except Exception as e:
                        print(f"Error running minigame {current_level}: {e}")
                        if show_dialogue([f"An error occurred! ",
                                        "Please try again. ",
                                        "Press SPACE to continue..."]):
                            # Restore the main game display
                            screen.blit(current_display, (0,0))
                            pygame.display.flip()

    elif current_state == "game_complete":
        screen.fill(BLACK)
        total_time = int(time.time() - game_start_time)
        minutes = total_time // 60
        seconds = total_time % 60
        
        draw_text("Congratulations!", 70, WHITE, SCREEN_WIDTH // 2 - 250, SCREEN_HEIGHT // 3)
        draw_text(f"You've completed Decoding Island!", 50, WHITE, SCREEN_WIDTH // 2 - 300, SCREEN_HEIGHT // 2)
        draw_text(f"Total Time: {minutes:02d}:{seconds:02d}", 50, WHITE, SCREEN_WIDTH // 2 - 200, SCREEN_HEIGHT // 2 + 100)
        
        if restart_button.draw(screen):
            current_state = "start_screen"
            game_start_time = None
            current_level = 0
            keys_collected = 0
            level_times = []
    
    pygame.display.update()

pygame.quit()

================
File: Archive/player.py
================
import pygame
from Archive.settings import *

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.reset(x, y)

    def update(self, game_over, world):
        dx, dy = 0, 0
        if game_over == 0:
            key = pygame.key.get_pressed()
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                JUMP_FX.play()
                self.vel_y = -15
                self.jumped = True

            if key[pygame.K_LEFT]:
                dx = -5
            if key[pygame.K_RIGHT]:
                dx = 5

            self.vel_y += 1
            if self.vel_y > 10:
                self.vel_y = 10
            dy += self.vel_y

            for tile in world.tile_list:
                if tile[1].colliderect(self.rect.x + dx, self.rect.y, self.width, self.height):
                    dx = 0
                if tile[1].colliderect(self.rect.x, self.rect.y + dy, self.width, self.height):
                    dy = tile[1].top - self.rect.bottom
                    self.vel_y = 0
                    self.in_air = False

            self.rect.x += dx
            self.rect.y += dy

        screen.blit(self.image, self.rect)
        return game_over

    def reset(self, x, y):
        self.image = pygame.image.load('img/dino1.png')
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.vel_y = 0
        self.jumped = False
        self.in_air = True

================
File: Archive/settings.py
================
import pygame

# Initialize Pygame and Mixer
pygame.mixer.pre_init(44100, -16, 2, 512)
pygame.init()
pygame.mixer.init()

# Constants
SCREEN_WIDTH = 1000
SCREEN_HEIGHT = 1000
TILE_SIZE = 50
FPS = 60

# Colors
WHITE = (255, 255, 255)
BLUE = (0, 0, 255)

# Game Variables
LEVEL = 3
MAX_LEVELS = 7
SCORE = 0
GAME_OVER = 0
MAIN_MENU = True

# Load Fonts
FONT = pygame.font.SysFont('Bauhaus 93', 70)
FONT_SCORE = pygame.font.SysFont('Bauhaus 93', 30)

# Load Images
SUN_IMG = pygame.image.load('img/sun.png')
BG_IMG = pygame.image.load('img/sky.png')
RESTART_IMG = pygame.image.load('img/restart_btn.png')
START_IMG = pygame.image.load('img/start_btn.png')
EXIT_IMG = pygame.image.load('img/exit_btn.png')

# Load Sounds
pygame.mixer.music.load('img/music.wav')
pygame.mixer.music.play(-1, 0.0, 5000)
key_FX = pygame.mixer.Sound('img/key.png')
JUMP_FX = pygame.mixer.Sound('img/jump.wav')
GAME_OVER_FX = pygame.mixer.Sound('img/game_over.wav')

# Create the screen
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Platformer Game')

# Clock to control frame rate
CLOCK = pygame.time.Clock()

# Main Game Loop
run = True
while run:
    CLOCK.tick(FPS)
    
    # Event Handling
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    # Draw Background
    screen.blit(BG_IMG, (0, 0))
    screen.blit(SUN_IMG, (100, 100))

    # Update the display
    pygame.display.update()

# Quit Pygame
pygame.quit()

================
File: Archive/A1main.py
================
import pygame
from pygame.locals import *
import pickle
from os import path
from Archive.settings import *
from Archive.player import Player
from world import World, key, Button

# Initialize Pygame
pygame.init()

# Set up the screen
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Platformer')

# Create player and groups
player = Player(100, SCREEN_HEIGHT - 130)
blob_group = pygame.sprite.Group()
platform_group = pygame.sprite.Group()
lava_group = pygame.sprite.Group()
key_group = pygame.sprite.Group()
exit_group = pygame.sprite.Group()
score_key = key(TILE_SIZE // 2, TILE_SIZE // 2)
key_group.add(score_key)

# Load level data
if path.exists(f'level{LEVEL}_data'):
    with open(f'level{LEVEL}_data', 'rb') as f:
        world_data = pickle.load(f)

world = World(world_data)

# Load button images
RESTART_IMG = pygame.image.load('img/restart_btn.png').convert_alpha()
START_IMG = pygame.image.load('img/start_btn.png').convert_alpha()
EXIT_IMG = pygame.image.load('img/exit_btn.png').convert_alpha()

# Create buttons
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, RESTART_IMG)
start_button = Button(SCREEN_WIDTH // 2 - 350, SCREEN_HEIGHT // 2, START_IMG)
exit_button = Button(SCREEN_WIDTH // 2 + 150, SCREEN_HEIGHT // 2, EXIT_IMG)

# Main game loop
run = True
while run:
    CLOCK.tick(FPS)
    screen.blit(BG_IMG, (0, 0))
    screen.blit(SUN_IMG, (100, 100))

    if MAIN_MENU:
        # Draw the buttons on the main menu
        if exit_button.draw(screen):
            run = False
        if start_button.draw(screen):
            MAIN_MENU = False
    else:
        world.draw(screen)

        if GAME_OVER == 0:
            blob_group.update()
            platform_group.update()
            if pygame.sprite.spritecollide(player, key_group, True):
                SCORE += 1
                key_FX.play()
            draw_text(f'X {SCORE}', FONT_SCORE, WHITE, TILE_SIZE - 10, 10, screen)

        blob_group.draw(screen)
        platform_group.draw(screen)
        lava_group.draw(screen)
        key_group.draw(screen)
        exit_group.draw(screen)

        GAME_OVER = player.update(GAME_OVER, world)

        if GAME_OVER == -1 and restart_button.draw(screen):
            world_data = []
            world = reset_level(LEVEL, player, world_data, blob_group, platform_group, lava_group, exit_group)
            GAME_OVER = 0
            SCORE = 0

        if GAME_OVER == 1:
            LEVEL += 1
            if LEVEL <= MAX_LEVELS:
                world_data = []
                world = reset_level(LEVEL, player, world_data, blob_group, platform_group, lava_group, exit_group)
                GAME_OVER = 0
            else:
                draw_text('YOU WIN!', FONT, BLUE, SCREEN_WIDTH // 2 - 140, SCREEN_HEIGHT // 2, screen)
                if restart_button.draw(screen):
                    LEVEL = 1
                    world_data = []
                    world = reset_level(LEVEL, player, world_data, blob_group, platform_group, lava_group, exit_group)
                    GAME_OVER = 0
                    SCORE = 0

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    pygame.display.update()

pygame.quit()

================
File: Archive/AAMain.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import pickle
from os import path
import time
from Archive.Wordle import main as wordle_game  # Import the Wordle game
import pytmx

pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

clock = pygame.time.Clock()
fps = 60

screen_width = 1000
screen_height = 1000

screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption('Platformer')

#define font
font = pygame.font.SysFont('Bauhaus 93', 70)
font_score = pygame.font.SysFont('Bauhaus 93', 30)


#define game variables
tile_size = 50
game_over = 0
main_menu = True
level = 1
max_levels = 7
score = 0

# In your settings.py or at the top of your main file
TILE_SIZE = 64  # TMX file uses 64x64 tiles
GRID_WIDTH = 36  # TMX map is 36 tiles wide
GRID_HEIGHT = 22  # TMX map is 22 tiles high
SCREEN_WIDTH = TILE_SIZE * GRID_WIDTH  # 36 * 64 = 2304
SCREEN_HEIGHT = TILE_SIZE * GRID_HEIGHT  # 22 * 64 = 1408


KEYS_REQUIRED = {
    1: 3,  # Level 1 requires 2 keys
    2: 2,  # Level 2 requires 3 keys
    3: 4,  # Level 3 requires 4 keys
    4: 5,  # Level 4 requires 5 keys
    5: 6,  # Level 5 requires 6 keys
    6: 7,  # Level 6 requires 7 keys
    7: 10   # Level 7 requires 8 keys
}

LEVEL_SOUNDTRACKS = {
    1: 'Louie Zong - BOSS RUSH/Louie Zong - BOSS RUSH - 01 Harvest Tyrant- ORCHARD OGRE.mp3',
    2: 'Louie Zong - BOSS RUSH/Louie Zong - BOSS RUSH - 02 Porcine Pilot- HOGWYLLD.mp3',
    3: 'Louie Zong - BOSS RUSH/Louie Zong - BOSS RUSH - 03 Maladaptive Mallard- KWACKPOT.mp3',
    4: 'Louie Zong - BOSS RUSH/Louie Zong - BOSS RUSH - 04 Corrupted Comrade- CITRUS KNIGHT.mp3',
    5: 'Louie Zong - BOSS RUSH/Louie Zong - BOSS RUSH - 05 ______REST ZONE______.mp3',
    6: 'Louie Zong - BOSS RUSH/Louie Zong - BOSS RUSH - 06 Mini Boss- MINNIE BUS.mp3',
    7: 'Louie Zong - BOSS RUSH/Louie Zong - BOSS RUSH - 07 Digital Goblin- LAN GNOME.mp3'
}

# Store original spawn point
original_spawn_x = 100
original_spawn_y = screen_height - 130

#define colours
white = (255, 255, 255)
blue = (0, 0, 255)



#load images
sun_img = pygame.image.load('img/sun.png')
bg_img = pygame.image.load('img/Background.png')
bg_img = pygame.transform.scale(bg_img, (screen_width, screen_height))
restart_img = pygame.image.load('img/restart_btn.png')
start_img = pygame.image.load('img/start_btn.png')
exit_img = pygame.image.load('img/exit_btn.png')

#load sounds
pygame.mixer.music.load('img/music.wav')
pygame.mixer.music.play(-1, 0.0, 5000)
key_fx = pygame.mixer.Sound('img/coin.wav')
key_fx.set_volume(0.5)
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)


class DialogueBox:
	def __init__(self, screen, font):
		self.screen = screen
		self.font = font
		self.box_color = (0, 0, 0, 180)  # Semi-transparent black
		self.text_color = (255, 255, 255)  # White text
		self.box_rect = pygame.Rect(50, screen_height - 300, screen_width - 100, 200)
		self.active = False
		self.current_text = ""
		self.text_surface = None
		self.waiting_for_input = False  # Add this line
        
	def show_dialogue(self, text, duration = 3000, wait_for_input=False):
		print(f"Showing dialogue: {text}")
		self.active = True
		self.current_text = text
		self.waiting_for_input = wait_for_input  # Set the flag based on the parameter

		screen.blit(bg_img, (0, 0))
		screen.blit(sun_img, (100, 100))
    
		# Create semi-transparent surface for dialogue box
		s = pygame.Surface((self.box_rect.width, self.box_rect.height))
		s.set_alpha(128)
		s.fill(self.box_color)
		screen.blit(s, self.box_rect)
    
		# Render text
		words = text.split()
		lines = []
		current_line = []
		for word in words:
			current_line.append(word)
			test_line = ' '.join(current_line)
			if self.font.size(test_line)[0] > self.box_rect.width - 20:
				lines.append(' '.join(current_line[:-1]))
				current_line = [word]
		lines.append(' '.join(current_line))
    
		# Draw text
		for i, line in enumerate(lines):
			text_surface = self.font.render(line, True, self.text_color)
			screen.blit(text_surface, (self.box_rect.x + 10, self.box_rect.y + 10 + i * 30))
		
		# Only show continue prompt for non-input dialogues
		if not self.waiting_for_input:
			continue_text = self.font.render("Press SPACE to continue...", True, (255, 255, 255))
			screen.blit(continue_text, (self.box_rect.x + 10, self.box_rect.bottom - 30))
		
		pygame.display.update()
    
		# Only wait for space if not in input mode
		if wait_for_input:
			return
		start_time = pygame.time.get_ticks()
		while self.active:
			current_time = pygame.time.get_ticks()
			if current_time - start_time >= duration:
				self.active = False  # End the dialogue
				break
			for event in pygame.event.get():
				if event.type == pygame.QUIT:
					pygame.quit()
					return
				if event.type == pygame.KEYDOWN:
					if event.key == pygame.K_SPACE:
						self.active = False
						break 
					
		self.active = False
		
	def update(self):
		if self.current_message:
			current_time = pygame.time.get_ticks()
			if current_time - self.message_timer > self.message_duration:
				self.current_message = None
			else:
				# Create semi-transparent surface for dialogue box
				s = pygame.Surface((self.box_rect.width, self.box_rect.height))
				s.set_alpha(128)
				s.fill(self.box_color)
				screen.blit(s, self.box_rect)
				
				# Render text
				words = self.current_message.split()
				lines = []
				current_line = []
				for word in words:
					current_line.append(word)
					test_line = ' '.join(current_line)
					if self.font.size(test_line)[0] > self.box_rect.width - 20:
						lines.append(' '.join(current_line[:-1]))
						current_line = [word]
				lines.append(' '.join(current_line))
				
				# Draw text
				for i, line in enumerate(lines):
					text_surface = self.font.render(line, True, self.text_color)
					screen.blit(text_surface, (self.box_rect.x + 10, self.box_rect.y + 10 + i * 30))
	
	def get_player_name(self):
		input_text = ""
		input_active = True
		prompt = "Enter your name:"
		
		while input_active:
			for event in pygame.event.get():
				if event.type == pygame.QUIT:
					pygame.quit()
					return None
				if event.type == pygame.KEYDOWN:
					if event.key == pygame.K_RETURN and input_text.strip():
						input_active = False
					elif event.key == pygame.K_BACKSPACE:
						input_text = input_text[:-1]
					else:
						if len(input_text) < 20:  # Limit name length
							input_text += event.unicode
							
			screen.blit(bg_img, (0, 0))
			screen.blit(sun_img, (100, 100))
			
			# Draw input box
			s = pygame.Surface((self.box_rect.width, self.box_rect.height))
			s.set_alpha(128)
			s.fill(self.box_color)
			screen.blit(s, self.box_rect)
			
			# Draw prompt
			prompt_surface = self.font.render(prompt, True, self.text_color)
			screen.blit(prompt_surface, (self.box_rect.x + 10, self.box_rect.y + 10))
			
			# Draw input text
			input_surface = self.font.render(input_text, True, self.text_color)
			screen.blit(input_surface, (self.box_rect.x + 10, self.box_rect.y + 50))
			
			pygame.display.flip()
			
		return input_text

class GameTimer:
    def __init__(self):
        self.start_time = time.time()
        self.elapsed_time = 0
        self.font = pygame.font.SysFont('Bauhaus 93', 30)

    def update(self):
        self.elapsed_time = time.time() - self.start_time

    def draw(self, screen):
        minutes, seconds = divmod(int(self.elapsed_time), 60)
        time_str = f"{minutes:02d}:{seconds:02d}"
        time_surface = self.font.render(time_str, True, (255, 255, 255))
        screen.blit(time_surface, (screen_width - 100, 10))

    def reset(self):
        self.start_time = time.time()
        self.elapsed_time = 0

    def save_time(self, level):
        with open('level_times.txt', 'a') as f:
            f.write(f"Level {level}: {int(self.elapsed_time)} seconds\n")
			
class StoryManager:
    def __init__(self):
        self.player_name = ""
        self.current_stage = 0
        self.storyline = [
            "Welcome to Decoding Island! You've woken up on a mysterious island...",
            "You must escape by solving coding puzzles and platforming challenges!",
            "Be careful of the enemies and obstacles ahead...",
            "Each level brings you closer to freedom, but also closer to the final boss!",
            "The puzzles will get progressively harder. Are you ready for the challenge?"
        ]
        self.level_messages = {
            1: "Level 1: The Beach - Your journey begins here...",
            2: "Level 2: The Jungle - Things are getting trickier...",
            3: "Level 3: The Mountains - The path grows more treacherous...",
            4: "Level 4: The Temple - Ancient coding secrets lie within...",
            5: "Level 5: The Summit - The final boss awaits...",
            6: "Level 6: The Escape - One last challenge to freedom...",
            7: "Level 7: Victory - You've mastered the Decoding Island!"
        }
        self.puzzles = {
            1: {"question": "What does print('Hello') output?", "answer": "Hello"},
            2: {"question": "What is 2 + 2 in Python?", "answer": "4"},
            3: {"question": "What is len('code')?", "answer": "4"},
            4: {"question": "What is the first index in a Python list?", "answer": "0"},
            5: {"question": "Is Python case-sensitive? (yes/no)", "answer": "yes"},
            6: {"question": "What type is 'True' in Python?", "answer": "bool"},
            7: {"question": "What symbol is used for comments in Python?", "answer": "#"}
        }

def play_wordle():
    """Run the Wordle game and return True if the player wins, False otherwise."""
    return wordle_game()  # Assume the main function in Wordle.py returns True for a win, False for a loss

def solve_puzzle_wordle(dialogue_box, puzzle):
    wordle_result = play_wordle()
    if wordle_result:
        dialogue_box.show_dialogue("You solved the Wordle puzzle! Moving to the next level...")
        return True
    else:
        dialogue_box.show_dialogue("You didn't solve the Wordle puzzle. Try the level again!")
        return False

def load_tmx_level(level_number):
    tmx_data = pytmx.load_pygame(f'LEVEL{level_number}GAME.tmx')
    world_data = []
    
    # Convert TMX layers to our world data format
    for layer in tmx_data.visible_layers:
        if hasattr(layer, 'data'):
            layer_data = []
            for y in range(layer.height):
                row = []
                for x in range(layer.width):
                    # Get tile GID and convert to our tile system
                    gid = layer.data[y][x]
                    # Convert TMX tile IDs to your game's tile system
                    if gid == 0:  # Empty tile
                        row.append(0)
                    elif gid in [90, 91, 92]:  # Platform tiles
                        row.append(1)
                    elif gid in [96, 97]:  # Ground tiles
                        row.append(2)
                    # Add more tile conversions as needed
                row.append(row)
            world_data.append(layer_data)
    
    return world_data

def draw_text(text, font, text_col, x, y):
	img = font.render(text, True, text_col)
	screen.blit(img, (x, y))

dialogue_box = DialogueBox(screen, font_score)
story_manager = StoryManager()

def reset(self, x, y):
    self.rect.x = x
    self.rect.y = y
    # Other initialization code remains the same

#function to reset level
def reset_level(level):
	player.reset(100, screen_height - 130)
	blob_group.empty()
	platform_group.empty()
	key_group.empty()
	lava_group.empty()
	exit_group.empty()

	#load in level data and create world
	if path.exists(f'level{level}_data'):
		pickle_in = open(f'level{level}_data', 'rb')
		world_data = pickle.load(pickle_in)
	world = World(world_data)
	#create dummy key for showing the score
	score_key = Key(tile_size // 2, tile_size // 2)
	key_group.add(score_key)
	return world

def eye_blink_effect(blink_count=2, blink_speed=0.5):
    original_surface = screen.copy()

    for _ in range(blink_count):
        # Closing eye effect
        for i in range(20):
            screen.blit(original_surface, (0, 0))
            height = int(screen_height * (i / 20)**2)  # Use quadratic easing for more natural movement
            pygame.draw.rect(screen, (0, 0, 0), (0, 0, screen_width, height))
            pygame.draw.rect(screen, (0, 0, 0), (0, screen_height - height, screen_width, height))
            pygame.display.update()
            pygame.time.wait(int((blink_speed / 40) * 1000))

        # Eye closed
        screen.fill((0, 0, 0))
        pygame.display.update()
        pygame.time.wait(int(blink_speed * 500))  # Half the blink_speed for closed eye

        # Opening eye effect
        for i in range(20, 0, -1):
            screen.blit(original_surface, (0, 0))
            height = int(screen_height * (i / 20)**2)  # Use quadratic easing for more natural movement
            pygame.draw.rect(screen, (0, 0, 0), (0, 0, screen_width, height))
            pygame.draw.rect(screen, (0, 0, 0), (0, screen_height - height, screen_width, height))
            pygame.display.update()
            pygame.time.wait(int((blink_speed / 40) * 1000))

        # Pause between blinks
        screen.blit(original_surface, (0, 0))
        pygame.display.update()
        pygame.time.wait(int(blink_speed * 2000))  # 2 seconds pause between blinks

    # Ensure the original screen is restored
    screen.blit(original_surface, (0, 0))
    pygame.display.update()

def reveal_text_gradually(screen, text, font, color, x, y, delay=150):
    """Reveal text one character at a time, keeping the event loop active."""
    start_time = pygame.time.get_ticks()
    running = True

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                return  # Ensure the game quits

        elapsed_time = pygame.time.get_ticks() - start_time
        char_count = elapsed_time // delay

        # Clear the screen
        screen.fill((0, 0, 0))  
        
        # Draw "Unknown Voice:" at the top
        voice_font = pygame.font.Font(None, 48)
        voice_surface = voice_font.render("Unknown Voice:", True, color)
        voice_rect = voice_surface.get_rect(center=(screen.get_width() // 2, 50))
        screen.blit(voice_surface, voice_rect)

        # Draw the gradually revealed text
        text_surface = font.render(text[:char_count], True, color)
        text_rect = text_surface.get_rect(center=(x, y))
        screen.blit(text_surface, text_rect)

        pygame.display.update()

        if char_count >= len(text):
            running = False  # Stop when all characters are revealed

def shake_text(screen, text, font, color, x, y, duration=1000, intensity=5):
    """Shake text for a given duration, keeping the event loop active."""
    start_time = pygame.time.get_ticks()
    running = True

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                return  # Ensure the game quits

        elapsed_time = pygame.time.get_ticks() - start_time
        if elapsed_time > duration:
            running = False  # Stop after the duration

        # Clear the screen
        screen.fill((0, 0, 0))  

        # Draw "Unknown Voice:" at the top
        voice_font = pygame.font.Font(None, 48)
        voice_surface = voice_font.render("Unknown Voice:", True, color)
        voice_rect = voice_surface.get_rect(center=(screen.get_width() // 2, 50))
        screen.blit(voice_surface, voice_rect)

        # Draw the shaking text
        offset_x = random.randint(-intensity, intensity)
        offset_y = random.randint(-intensity, intensity)
        text_surface = font.render(text, True, color)
        text_rect = text_surface.get_rect(center=(x + offset_x, y + offset_y))
        screen.blit(text_surface, text_rect)

        pygame.display.update()
        pygame.time.delay(50)  # Keep shaking at intervals

def blink_and_reveal_text(screen, font):
    """Simulate eye blink effect and reveal text with various effects."""
    # Define text properties
    text_color = (255, 255, 255)  # White color
    center_x = screen.get_width() // 2
    center_y = screen.get_height() // 2

    # Use a smaller font for the quotes
    quote_font = pygame.font.Font(None, 36)

    # Reveal each line of text gradually
    reveal_text_gradually(screen, "\"Hello?\"", quote_font, text_color, center_x, center_y, delay=150)
    pygame.time.wait(1500)  # Wait between lines

    reveal_text_gradually(screen, "\"Helloooo?\"", quote_font, text_color, center_x, center_y, delay=150)
    pygame.time.wait(1500)  # Wait between lines

    reveal_text_gradually(screen, "\"HELLO!!!\"", quote_font, text_color, center_x, center_y, delay=100)

    pygame.time.wait(1000)  # Wait after shaking

    # Fade back to the game
    original_surface = pygame.display.get_surface().copy()
    for alpha in range(0, 255, 5):
        screen.fill((0, 0, 0))
        original_surface.set_alpha(alpha)
        screen.blit(original_surface, (0, 0))
        pygame.display.update()
        pygame.time.wait(20)
		
def change_music(level):
    pygame.mixer.music.fadeout(500)  # Fade out current music
    pygame.time.wait(500)  # Wait for fadeout to complete
    if level in LEVEL_SOUNDTRACKS:
        try:
            pygame.mixer.music.load(LEVEL_SOUNDTRACKS[level])
            pygame.mixer.music.play(-1)  # Loop indefinitely
            pygame.mixer.music.set_volume(0.5)  # Adjust volume as needed
        except Exception as e:
            print(f"Could not load music for level {level}: {e}")

change_music(level)  # Start the music for level 1

def solve_puzzle(dialogue_box, puzzle):
    answer = ""
    solving = True
    print("Entering solve_puzzle function")  # Debug print
    dialogue_box.show_dialogue(f"Puzzle: {puzzle['question']}\nYour answer: ", wait_for_input=True)
    
    while solving:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                return False
            if event.type == pygame.KEYDOWN:
                print(f"Key pressed: {event.unicode}")  # Debug print
                if event.key == pygame.K_RETURN and answer.strip():
                    print(f"Submitted answer: {answer}")  # Debug print
                    return answer.strip().lower() == puzzle['answer'].lower()
                elif event.key == pygame.K_BACKSPACE:
                    answer = answer[:-1]
                else:
                    answer += event.unicode
                
                # Update the dialogue box with the current answer
                dialogue_box.show_dialogue(f"Puzzle: {puzzle['question']}\nYour answer: {answer}", wait_for_input=True)
        
        pygame.display.flip()
        clock.tick(fps)
        
        screen.blit(bg_img, (0, 0))
        screen.blit(sun_img, (100, 100))
        
        dialogue_box.show_dialogue(f"Puzzle: {puzzle['question']}\nYour answer: {answer}", 0)
        
        pygame.display.flip()
    
    return answer.strip().lower() == puzzle['answer'].lower()
		
class Button():
	def __init__(self, x, y, image):
		self.image = image
		self.rect = self.image.get_rect()
		self.rect.x = x
		self.rect.y = y
		self.clicked = False

	def draw(self):
		action = False

		#get mouse position
		pos = pygame.mouse.get_pos()

		#check mouseover and clicked conditions
		if self.rect.collidepoint(pos):
			if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
				action = True
				self.clicked = True

		if pygame.mouse.get_pressed()[0] == 0:
			self.clicked = False


		#draw button
		screen.blit(self.image, self.rect)

		return action


class Player():
	def __init__(self, x, y):
		self.reset(x, y)

	def update(self, game_over):
		dx = 0
		dy = 0
		walk_cooldown = 5
		col_thresh = 20

		if game_over == 0:
			#get keypresses
			key = pygame.key.get_pressed()
			if key[pygame.K_SPACE] and self.jumped == False and self.in_air == False:
				jump_fx.play()
				self.vel_y = -15
				self.jumped = True
			if key[pygame.K_SPACE] == False:
				self.jumped = False
			if key[pygame.K_LEFT]:
				dx -= 5
				self.counter += 1
				self.direction = -1
			if key[pygame.K_RIGHT]:
				dx += 5
				self.counter += 1
				self.direction = 1
			if key[pygame.K_LEFT] == False and key[pygame.K_RIGHT] == False:
				self.counter = 0
				self.index = 0
				if self.direction == 1:
					self.image = self.images_right[self.index]
				if self.direction == -1:
					self.image = self.images_left[self.index]


			#handle animation
			if self.counter > walk_cooldown:
				self.counter = 0
				self.index += 1
				if self.index >= len(self.images_right):
					self.index = 0
				if self.direction == 1:
					self.image = self.images_right[self.index]
				if self.direction == -1:
					self.image = self.images_left[self.index]


			#add gravity
			self.vel_y += 1
			if self.vel_y > 10:
				self.vel_y = 10
			dy += self.vel_y

			#check for collision
			self.in_air = True
			for tile in world.tile_list:
				#check for collision in x direction
				if tile[1].colliderect(self.rect.x + dx, self.rect.y, self.width, self.height):
					dx = 0
				#check for collision in y direction
				if tile[1].colliderect(self.rect.x, self.rect.y + dy, self.width, self.height):
					#check if below the ground i.e. jumping
					if self.vel_y < 0:
						dy = tile[1].bottom - self.rect.top
						self.vel_y = 0
					#check if above the ground i.e. falling
					elif self.vel_y >= 0:
						dy = tile[1].top - self.rect.bottom
						self.vel_y = 0
						self.in_air = False


			#check for collision with enemies
			if pygame.sprite.spritecollide(self, blob_group, False):
				game_over = -1
				game_over_fx.play()

			#check for collision with lava
			if pygame.sprite.spritecollide(self, lava_group, False):
				game_over = -1
				game_over_fx.play()

			#check for collision with exit
			if pygame.sprite.spritecollide(self, exit_group, False):
				game_over = 1


			#check for collision with platforms
			for platform in platform_group:
				#collision in the x direction
				if platform.rect.colliderect(self.rect.x + dx, self.rect.y, self.width, self.height):
					dx = 0
				#collision in the y direction
				if platform.rect.colliderect(self.rect.x, self.rect.y + dy, self.width, self.height):
					#check if below platform
					if abs((self.rect.top + dy) - platform.rect.bottom) < col_thresh:
						self.vel_y = 0
						dy = platform.rect.bottom - self.rect.top
					#check if above platform
					elif abs((self.rect.bottom + dy) - platform.rect.top) < col_thresh:
						self.rect.bottom = platform.rect.top - 1
						self.in_air = False
						dy = 0
					#move sideways with the platform
					if platform.move_x != 0:
						self.rect.x += platform.move_direction


			#update player coordinates
			self.rect.x += dx
			self.rect.y += dy


		elif game_over == -1:
			self.image = self.dead_image
			draw_text('GAME OVER!', font, blue, (screen_width // 2) - 200, screen_height // 2)
			if self.rect.y > 200:
				self.rect.y -= 5

		#draw player onto screen
		screen.blit(self.image, self.rect)

		return game_over

	
	def reset(self, x, y):
		self.images_right = []
		self.images_left = []
		self.index = 0
		self.counter = 0
		for num in range(1, 5):
			img_right = pygame.image.load(f'img/dino{num}.png')
			img_right = pygame.transform.scale(img_right, (30, 40))
			img_left = pygame.transform.flip(img_right, True, False)
			self.images_right.append(img_right)
			self.images_left.append(img_left)
		self.dead_image = pygame.image.load('img/Skeleton.png')
		self.image = self.images_right[self.index]
		self.rect = self.image.get_rect()
		self.rect.x = x
		self.rect.y = y
		self.width = self.image.get_width()
		self.height = self.image.get_height()
		self.vel_y = 0
		self.jumped = False
		self.direction = 0
		self.in_air = True



class World():
	def __init__(self, data):
		self.tile_list = []

		#load images
		dirt_block_img = pygame.image.load('img/dirt_block.png')
		grass_block_img = pygame.image.load('img/grass_block.png')
		self.dirt_img = pygame.image.load('img/dirt.png')
		self.grass_img = pygame.image.load('img/grass.png')
		self.platform_img = pygame.image.load('img/platform.png')

		row_count = 0
		for row in data:
			col_count = 0
			for tile in row:
				if tile == 1:
					img = pygame.transform.scale(dirt_block_img, (tile_size, tile_size))
					img_rect = img.get_rect()
					img_rect.x = col_count * tile_size
					img_rect.y = row_count * tile_size
					tile = (img, img_rect)
					self.tile_list.append(tile)
				if tile == 2:
					img = pygame.transform.scale(grass_block_img, (tile_size, tile_size))
					img_rect = img.get_rect()
					img_rect.x = col_count * tile_size
					img_rect.y = row_count * tile_size
					tile = (img, img_rect)
					self.tile_list.append(tile)
				if tile == 3:
					blob = Enemy(col_count * tile_size, row_count * tile_size + 15)
					blob_group.add(blob)
				if tile == 4:
					platform = Platform(col_count * tile_size, row_count * tile_size, 1, 0)
					platform_group.add(platform)
				if tile == 5:
					platform = Platform(col_count * tile_size, row_count * tile_size, 0, 1)
					platform_group.add(platform)
				if tile == 6:
					lava = Lava(col_count * tile_size, row_count * tile_size + (tile_size // 2))
					lava_group.add(lava)
				if tile == 7:
					key = Key(col_count * tile_size + (tile_size // 2), row_count * tile_size + (tile_size // 2))
					key_group.add(key)
				if tile == 8:
					exit = Exit(col_count * tile_size, row_count * tile_size - (tile_size // 2))
					exit_group.add(exit)
				col_count += 1
			row_count += 1


	def draw(self):
		for tile in self.tile_list:
			screen.blit(tile[0], tile[1])



class Enemy(pygame.sprite.Sprite):
	def __init__(self, x, y):
		pygame.sprite.Sprite.__init__(self)
		self.image = pygame.image.load('img/Zombie.png')
		self.rect = self.image.get_rect()
		self.rect.x = x
		self.rect.y = y
		self.move_direction = 1
		self.move_counter = 0

	def update(self):
		self.rect.x += self.move_direction
		self.move_counter += 1
		if abs(self.move_counter) > 50:
			self.move_direction *= -1
			self.move_counter *= -1


class Platform(pygame.sprite.Sprite):
	def __init__(self, x, y, move_x, move_y):
		pygame.sprite.Sprite.__init__(self)
		img = pygame.image.load('img/grass_plat.png')
		self.image = pygame.transform.scale(img, (tile_size, tile_size // 2))
		self.rect = self.image.get_rect()
		self.rect.x = x
		self.rect.y = y
		self.move_counter = 0
		self.move_direction = 1
		self.move_x = move_x
		self.move_y = move_y


	def update(self):
		self.rect.x += self.move_direction * self.move_x
		self.rect.y += self.move_direction * self.move_y
		self.move_counter += 1
		if abs(self.move_counter) > 50:
			self.move_direction *= -1
			self.move_counter *= -1


class Lava(pygame.sprite.Sprite):
	def __init__(self, x, y):
		pygame.sprite.Sprite.__init__(self)
		img = pygame.image.load('img/lava.png')
		self.image = pygame.transform.scale(img, (tile_size, tile_size // 2))
		self.rect = self.image.get_rect()
		self.rect.x = x
		self.rect.y = y


class Key(pygame.sprite.Sprite):
	def __init__(self, x, y):
		pygame.sprite.Sprite.__init__(self)
		img = pygame.image.load('img/key.png')
		self.image = pygame.transform.scale(img, (tile_size // 2.5, tile_size // 2))
		self.rect = self.image.get_rect()
		self.rect.center = (x, y)


class Exit(pygame.sprite.Sprite):
	def __init__(self, x, y):
		pygame.sprite.Sprite.__init__(self)
		img = pygame.image.load('img/exit.png')
		self.image = pygame.transform.scale(img, (tile_size, int(tile_size * 1.5)))
		self.rect = self.image.get_rect()
		self.rect.x = x
		self.rect.y = y

level_questions = {
    1: {"question": "What does this code print? print('Hello, World!')", "answer": "Hello, World!"},
    2: {"question": "Decode this: print(str(2 + 2))", "answer": "4"},
    3: {"question": "What's the output? print('Python'[1:4])", "answer": "yth"},
    4: {"question": "Decode: print(len('code'))", "answer": "4"},
    5: {"question": "Result of: print(list(range(3)))", "answer": "[0, 1, 2]"},
    6: {"question": "Output of: print('a' * 3)", "answer": "aaa"},
    7: {"question": "What prints? x = 5; print(f'{x + 2}')", "answer": "7"},
    # Add more questions for each level
}
game_timer = GameTimer()

def show_level_banner(screen, level, duration=2000):
    """Show a level transition banner"""
    # Create a semi-transparent overlay
    overlay = pygame.Surface((screen_width, screen_height))
    overlay.fill((0, 0, 0))
    overlay.set_alpha(128)
    screen.blit(overlay, (0, 0))
    
    # Draw level text
    level_text = f"Level {level}"
    draw_text(level_text, font, white, (screen_width // 2) - 100, screen_height // 2 - 50)
    
    # Draw keys required text
    keys_text = f"Collect {KEYS_REQUIRED[level]} keys to proceed"
    draw_text(keys_text, font_score, white, (screen_width // 2) - 150, screen_height // 2 + 20)
    
    pygame.display.update()
    pygame.time.wait(duration)

# Then modify your level transition code:
if game_over == 1:
    if score >= KEYS_REQUIRED[level]:
        game_timer.save_time(level)
        level += 1
        if level <= max_levels:
            world_data = []
            world = reset_level(level)
            game_over = 0
            score = 0
            game_timer.reset()
            # Change music for new level
            change_music(level)
            # Show level banner
            show_level_banner(screen, level)

class LevelIndicator:
    def __init__(self):
        self.font = pygame.font.SysFont('Bauhaus 93', 30)
        self.bg_color = (0, 0, 0, 128)  # Semi-transparent black
        self.text_color = white
        self.padding = 10
        
    def draw(self, screen, level, score, required_keys):
        # Draw level indicator box
        level_text = f"Level {level}"
        key_text = f"keys: {score}/{required_keys}"
        
        # Create text surfaces
        level_surface = self.font.render(level_text, True, self.text_color)
        key_surface = self.font.render(key_text, True, self.text_color)
        
        # Calculate box dimensions
        box_width = max(level_surface.get_width(), key_surface.get_width()) + self.padding * 2
        box_height = level_surface.get_height() + key_surface.get_height() + self.padding * 3
        
        # Create semi-transparent background
        bg_surface = pygame.Surface((box_width, box_height))
        bg_surface.fill((0, 0, 0))
        bg_surface.set_alpha(128)
        
        # Position the box in the top-right corner
        box_x = screen_width - box_width - 10
        box_y = 10
        
        # Draw background
        screen.blit(bg_surface, (box_x, box_y))
        
        # Draw text
        screen.blit(level_surface, (box_x + self.padding, box_y + self.padding))
        screen.blit(key_surface, (box_x + self.padding, 
                                 box_y + self.padding * 2 + level_surface.get_height()))

# Initialize the level indicator
level_indicator = LevelIndicator()

def ask_question(level):
    if level not in level_questions:
        return True  # If no question for this level, assume correct

    question_data = level_questions[level]
    question = question_data["question"]
    correct_answer = question_data["answer"]
    user_answer = ""

    while True:
        screen.fill((0, 0, 0))
        draw_text("Level " + str(level) + " Question:", font, white, screen_width // 2 - 200, screen_height // 2 - 100)
        draw_text(question, font_score, white, screen_width // 2 - 200, screen_height // 2 - 50)
        draw_text("Your Answer: " + user_answer, font, white, screen_width // 2 - 200, screen_height // 2 + 50)
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                return False
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_RETURN:
                    if user_answer.lower().strip() == correct_answer.lower().strip():
                        return True
                    else:
                        return False
                elif event.key == pygame.K_BACKSPACE:
                    user_answer = user_answer[:-1]
                else:
                    user_answer += event.unicode

        pygame.display.update()


player = Player(100, screen_height - 130)

blob_group = pygame.sprite.Group()
platform_group = pygame.sprite.Group()
lava_group = pygame.sprite.Group()
key_group = pygame.sprite.Group()
exit_group = pygame.sprite.Group()

#create dummy coin for showing the score
score_key = Key(tile_size // 2, tile_size // 2)
key_group.add(score_key)

#load in level data and create world
if path.exists(f'level{level}_data'):
	pickle_in = open(f'level{level}_data', 'rb')
	world_data = pickle.load(pickle_in)
world = World(world_data)


#create buttons
restart_button = Button(screen_width // 2 - 50, screen_height // 2 + 100, restart_img)
start_button = Button(screen_width // 2 - 350, screen_height // 2, start_img)
exit_button = Button(screen_width // 2 + 150, screen_height // 2, exit_img)


run = True
while run:

	clock.tick(fps)

	screen.blit(bg_img, (0, 0))
	screen.blit(sun_img, (100, 100))

	for event in pygame.event.get():
		if event.type == pygame.QUIT:
			run = False

	if main_menu:
		if start_button.draw():
			if not story_manager.player_name:
				story_manager.player_name = dialogue_box.get_player_name()
				for intro_text in story_manager.storyline:
					dialogue_box.show_dialogue(intro_text)
				main_menu = False	
		if exit_button.draw():
			run = False
	
	else:
		world.draw()
		
		if game_over == 0:
			blob_group.update()
			platform_group.update()
			game_timer.update()  # Update the timer
			game_timer.draw(screen)  # Draw the timer
			#update score
			#check if a key has been collected
			if pygame.sprite.spritecollide(player, key_group, True):
				score += 1
				key_fx.play()
				if level == 2 and not hasattr(story_manager, 'level_2_message_shown'):
					dialogue_box.show_dialogue("Your better than I thought...")
					story_manager.level_2_message_shown = True
					pygame.time.wait(500)  # Short pause before continuing
				# Add level-specific story elements
				if level == 3 and not hasattr(story_manager, 'level_3_message_shown'):
					dialogue_box.show_dialogue("You've reached the mountains. The air is getting thinner...")
					story_manager.level_3_message_shown = True
				
				if level == 5 and not hasattr(story_manager, 'boss_warning_shown'):
					dialogue_box.show_dialogue("Be careful! The final boss is near. Prepare for the ultimate challenge!")
					story_manager.boss_warning_shown = True
			draw_text(f'Keys: {score}/{KEYS_REQUIRED[level]}', font_score, white, tile_size - 10, 10)

			# When player reaches exit, check keys
			if pygame.sprite.spritecollide(player, exit_group, False):
				if score >= KEYS_REQUIRED[level]:
					if level in story_manager.puzzles:
						puzzle = story_manager.puzzles[level]
						dialogue_box.show_dialogue(f"Solve this puzzle to proceed to the next level:")
						pygame.display.update()
						pygame.time.wait(1000)
					game_over = 1
				else:
					draw_text(f'Need {KEYS_REQUIRED[level] - score} more keys!', 
							font_score, white, 
							screen_width // 2 - 100, screen_height // 2)
					pygame.display.update()
					pygame.time.wait(1000)
					# Respawn player at the original spawn point
					player.reset(original_spawn_x, original_spawn_y)  # Reset to original spawn
					game_over = 0  # Allow the player to continue playing
					
		blob_group.draw(screen)
		platform_group.draw(screen)
		lava_group.draw(screen)
		key_group.draw(screen)
		exit_group.draw(screen)

		game_over = player.update(game_over)

		if game_over == -1:
			draw_text(f'GAME OVER, {story_manager.player_name}!', font, blue, (screen_width // 2) - 200, screen_height // 2)
			if restart_button.draw():
				world_data = []
				world = reset_level(level)
				game_over = 0
				score = 0

# In your main game loop, replace the level completion section with:

		if game_over == 1:
			if score >= KEYS_REQUIRED[level]:
				if level in story_manager.puzzles:
					puzzle = story_manager.puzzles[level]
					dialogue_box.show_dialogue(f"Solve this puzzle to proceed to the next level:")
					pygame.display.update()
					pygame.time.wait(1000)
					if solve_puzzle_wordle(dialogue_box, puzzle):
						game_timer.save_time(level)
						level += 1
						if level <= max_levels:
							world_data = []
							world = reset_level(level)
							game_over = 0
							score = 0
							change_music(level)
							show_level_banner(screen, level)
						else:
							dialogue_box.show_dialogue(f"Congratulations {story_manager.player_name}!\nYou've escaped Decoding Island!")
					else:
						game_over = 0  # Allow the player to try the level again
				else:
					# If there's no puzzle for this level, just proceed
					game_timer.save_time(level)
					level += 1
					if level <= max_levels:
						world_data = []
						world = reset_level(level)
						game_over = 0
						score = 0
						change_music(level)
						show_level_banner(screen, level)
					else:
						dialogue_box.show_dialogue(f"Congratulations {story_manager.player_name}!\nYou've escaped Decoding Island!")
			else:
				# Not enough keys
				keys_needed = KEYS_REQUIRED[level] - score
				draw_text(f'Need {keys_needed} more keys!', font_score, white, screen_width // 2 - 100, screen_height // 2)
				pygame.display.update()
				pygame.time.wait(1000)
				game_over = 0  # Allow the player to continue playing the current level

	if main_menu == False:  # Only show when not in main menu
		# Draw level indicator
		draw_text(f'Level: {level}', font_score, white, screen_width - 550, 10)
		# Draw key counter
		

	for event in pygame.event.get():
		if event.type == pygame.QUIT:
			run = False

	pygame.display.update()

pygame.quit()

================
File: Archive/Platformer_project/main.py
================
import pygame
from components.player import Player
from components.world import World
from components.enemy import Enemy
from components.platform import Platform
from components.objects import Lava, key, Exit
from components.button import Button
from utils.helpers import draw_text, reset_level

pygame.init()

# Game setup
screen_width = 1000
screen_height = 1000
screen = pygame.display.set_mode((screen_width, screen_height))
pygame.display.set_caption('Platformer')

# Load assets
bg_img = pygame.image.load('assets/img/sky.png')
sun_img = pygame.image.load('assets/img/sun.png')

# Initialize player and world
player = Player(100, screen_height - 130)
world = reset_level(1)

# Main game loop
run = True
while run:
    screen.blit(bg_img, (0, 0))
    screen.blit(sun_img, (100, 100))

    # Draw the world and player
    world.draw(screen)
    player.update(screen)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    pygame.display.update()

pygame.quit()

================
File: Archive/Platformer_project/utils/helpers.py
================
import pickle
from os import path

def draw_text(text, font, color, x, y, screen):
    img = font.render(text, True, color)
    screen.blit(img, (x, y))

def reset_level(level):
    if path.exists(f'levels/level{level}_data.pkl'):
        with open(f'levels/level{level}_data.pkl', 'rb') as file:
            world_data = pickle.load(file)
        return world_data
    return []

================
File: Archive/Platformer_project/components/world.py
================
import pygame
from components.enemy import Enemy

class World:
    def __init__(self, data):
        self.tile_list = []
        for row in data:
            for tile in row:
                if tile == 3:  # Example: Add enemy
                    self.tile_list.append(Enemy())

    def draw(self, screen):
        for tile in self.tile_list:
            tile.draw(screen)

================
File: Archive/Platformer_project/components/platform.py
================
import pygame

class Platform:
    def __init__(self, x, y, move_x, move_y):
        self.rect = pygame.Rect(x, y, 50, 10)
        self.move_x = move_x
        self.move_y = move_y

    def update(self):
        self.rect.x += self.move_x
        self.rect.y += self.move_y

================
File: Archive/Platformer_project/components/button.py
================
import pygame

class Button:
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect(topleft=(x, y))

    def draw(self, screen):
        screen.blit(self.image, self.rect)

================
File: Archive/Platformer_project/components/player.py
================
import pygame

class Player:
    def __init__(self, x, y):
        self.rect = pygame.Rect(x, y, 40, 80)
        self.vel_y = 0

    def update(self, screen):
        self.vel_y += 1  # Gravity
        self.rect.y += self.vel_y

        pygame.draw.rect(screen, (0, 0, 255), self.rect)  # Temporary visual

================
File: Archive/Platformer_project/components/objects.py
================
import pygame

class Lava:
    def __init__(self, x, y):
        self.rect = pygame.Rect(x, y, 50, 10)

    def draw(self, screen):
        pygame.draw.rect(screen, (255, 100, 0), self.rect)

class key:
    def __init__(self, x, y):
        self.rect = pygame.Rect(x, y, 20, 20)

    def draw(self, screen):
        pygame.draw.circle(screen, (255, 215, 0), self.rect.center, 10)

class Exit:
    def __init__(self, x, y):
        self.rect = pygame.Rect(x, y, 50, 50)

    def draw(self, screen):
        pygame.draw.rect(screen, (0, 255, 0), self.rect)

================
File: Archive/Platformer_project/components/enemy.py
================
import pygame

class Enemy:
    def __init__(self):
        self.rect = pygame.Rect(100, 100, 30, 30)

    def draw(self, screen):
        pygame.draw.rect(screen, (255, 0, 0), self.rect)  # Temporary visual

================
File: Archive/Reference Pickle/level_times.txt
================
Level 1: 4 seconds
Level 3: 22 seconds
Level 5: 14 seconds
Level 7: 20 seconds
Level 9: 20 seconds
Level 11: 20 seconds
Level 1: 44 seconds
Level 3: 41 seconds
Level 5: 21 seconds
Level 1: 29 seconds
Level 1: 33 seconds
Level 2: 53 seconds
Level 3: 92 seconds
Level 4: 118 seconds
Level 5: 162 seconds
Level 6: 185 seconds
Level 7: 214 seconds
Level 1: 30 seconds
Level 1: 22 seconds
Level 1: 27 seconds
Level 1: 25 seconds
Level 2: 77 seconds
Level 1: 35 seconds
Level 2: 60 seconds
Level 3: 85 seconds
Level 4: 115 seconds
Level 5: 161 seconds
Level 6: 188 seconds
Level 7: 230 seconds
Level 1: 25 seconds
Level 1: 19 seconds
Level 1: 7 seconds
Level 1: 6 seconds
Level 1: 13 seconds
Level 1: 24 seconds
Level 1: 11 seconds
Level 1: 8 seconds
Level 1: 10 seconds
Level 1: 14 seconds
Level 1: 10 seconds
Level 1: 10 seconds
Level 1: 11 seconds
Level 1: 10 seconds
Level 1: 8 seconds
Level 1: 7 seconds
Level 1: 7 seconds
Level 1: 14 seconds
Level 1: 8 seconds
Level 1: 8 seconds
Level 1: 47 seconds
Level 1: 6 seconds
Level 2: 34 seconds
Level 3: 69 seconds
Level 1: 9 seconds
Level 1: 14 seconds
Level 1: 13 seconds
Level 1: 11 seconds
Level 2: 43 seconds
Level 3: 84 seconds
Level 4: 113 seconds
Level 5: 139 seconds
Level 6: 164 seconds
Level 7: 198 seconds
Level 1: 12 seconds
Level 1: 11 seconds
Level 1: 23 seconds
Level 2: 58 seconds
Level 3: 82 seconds
Level 4: 118 seconds
Level 5: 149 seconds
Level 6: 175 seconds
Level 7: 221 seconds
Level 1: 21 seconds
Level 1: 10 seconds
Level 1: 16 seconds
Level 1: 28 seconds
Level 1: 7 seconds
Level 2: 28 seconds
Level 1: 11 seconds
Level 2: 35 seconds
Level 1: 9 seconds
Level 1: 14 seconds
Level 1: 9 seconds
Level 1: 16 seconds

================
File: Level Data/LEVEL0.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os

# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Get the screen resolution
infoObject = pygame.display.Info()
monitor_width = infoObject.current_w
monitor_height = infoObject.current_h

# Calculate the game window size (90% of screen size while maintaining aspect ratio)
SCREEN_SCALE = 0.9
target_width = int(monitor_width * SCREEN_SCALE)
target_height = int(monitor_height * SCREEN_SCALE)

# Load and scale the background
original_bg = pygame.image.load('Level Data/Level Image/LEVEL0.png')
bg_aspect_ratio = original_bg.get_width() / original_bg.get_height()

# Adjust window size to maintain aspect ratio
if target_width / target_height > bg_aspect_ratio:
    SCREEN_WIDTH = int(target_height * bg_aspect_ratio)
    SCREEN_HEIGHT = target_height
else:
    SCREEN_WIDTH = target_width
    SCREEN_HEIGHT = int(target_width / bg_aspect_ratio)

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Platformer')

# Define game variables
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.8
JUMP_SPEED = -15
MOVE_SPEED = 8
game_over = 0
score = 0

# Define colors
white = (255, 255, 255)
blue = (0, 0, 255)

# Load images
sun_img = pygame.image.load('img/sun.png')
bg_img = pygame.transform.scale(original_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
restart_img = pygame.image.load('img/restart_btn.png')

# Load sounds
pygame.mixer.music.load('img/music.wav')
pygame.mixer.music.play(-1, 0.0, 5000)
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)


class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2))
        
        for i in range(1, 5):
            img = pygame.image.load(f'img/dino{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, player_size)
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def update(self, game_over):
        dx = 0
        dy = 0
        walk_cooldown = 5

        if game_over == 0:
            key = pygame.key.get_pressed()
            
            # Jump only if we're on the ground (not in_air) and haven't jumped yet
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
            
            # Reset jumped state when space is released
            if not key[pygame.K_SPACE]:
                self.jumped = False

            if key[pygame.K_LEFT]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
            if key[pygame.K_RIGHT]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
            if not key[pygame.K_LEFT] and not key[pygame.K_RIGHT]:
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Add gravity
            self.vel_y += GRAVITY
            if self.vel_y > 10:
                self.vel_y = 10
            dy += self.vel_y

            # Assume we're in the air unless collision detection proves otherwise
            self.in_air = True

            # Check for collision
            dx, dy = world.check_collision(self, dx, dy)

            # Update player position
            self.rect.x += dx
            self.rect.y += dy

            # Keep player on screen
            if self.rect.left < 0:
                self.rect.left = 0
            if self.rect.right > SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH
                
            # Check if player has fallen off the map
            if self.rect.top > SCREEN_HEIGHT:
                game_over = -1
                game_over_fx.play()

        elif game_over == -1:
            self.image = self.dead_image
            if self.rect.y > 200:
                self.rect.y -= 5

        return game_over

class World:
    def __init__(self):
        self.collision_tiles = []
        
        # Platform data for level 1
        platform_data = [
            # Top platforms
            (5.2, 13.4, 6, 2.5),    
            (48, 13.4, 6, 2.5),   

            # small-top platform
            (13.3, 15.5, 1.4, 1.0), 
            (44.4, 15.5, 1.6, 1.0), 
            
            # semi-top platform
            (16.7, 16.6, 4.5, 1.0), 
            (38, 16.6, 4.5, 1.0), 

            # Middle platform
            (26.5, 18.3, 6.2, 2.5),  
            
            # Lower platforms
            (34.6, 23.2, 4.8, 2.5),
            (19.9, 23.2, 4.7, 2.5),
            
            # Bottom platforms
            (11.8, 28, 6.2, 2.5),
            (26.6, 28, 6.2, 2.5),
            (41.3, 28, 8, 1.),
            
            # Ground level
            (0, 33, 8, 3.0),
            (51, 33, 8.2, 3.0),
        ]
        
        for plat in platform_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            collision_rect = pygame.Rect(
                x + 2,
                y + 2,
                width - 4,
                height - 4
            )
            self.collision_tiles.append(CollisionTile(x, y, width, height))

    def check_collision(self, player, dx, dy):
        for tile in self.collision_tiles:
            # Check x collision
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            
            # Check y collision
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                # Check if below the ground i.e. jumping
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                # Check if above the ground i.e. falling
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False  # We've hit a platform, so we're not in the air
                
        return dx, dy

    def draw(self, screen):
        for tile in self.collision_tiles:
            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)

class Button():
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self):
        action = False
        pos = pygame.mouse.get_pos()

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font, text_col, x, y):
    img = font.render(text, True, text_col)
    screen.blit(img, (x, y))

def draw_grid(screen):
    # Create a new surface for the grid
    grid_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
    
    # Set the alpha value for translucency
    grid_surface.set_alpha(128)  # Adjust this value for more or less transparency

    # Draw vertical lines
    for x in range(0, SCREEN_WIDTH, TILE_SIZE):
        color = (255, 0, 0) if (x // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (x, 0), (x, SCREEN_HEIGHT), 1)

    # Draw horizontal lines
    for y in range(0, SCREEN_HEIGHT, TILE_SIZE):
        color = (255, 0, 0) if (y // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (0, y), (SCREEN_WIDTH, y), 1)

    # Blit the grid surface onto the main screen
    screen.blit(grid_surface, (0, 0))

# Initialize game objects
world = World()
player = Player(100, SCREEN_HEIGHT - 130)
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Game loop
clock = pygame.time.Clock()
fps = 60
run = True

while run:
    clock.tick(fps)

    screen.blit(bg_img, (0, 0))

    if game_over == 0:
        game_over = player.update(game_over)
    elif game_over == -1:
        draw_text('GAME OVER!', pygame.font.SysFont('Bauhaus 93', 70), blue, 
                 (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
        if restart_button.draw():
            player.rect.x = 100
            player.rect.y = SCREEN_HEIGHT - 130
            game_over = 0

    # Draw the world (collision boxes)
    world.draw(screen)
    draw_grid(screen)
    
    # Draw the player
    screen.blit(player.image, player.rect)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                run = False

    pygame.display.update()

pygame.quit()

================
File: Level Data/LEVEL4.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os

# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Get the screen resolution
infoObject = pygame.display.Info()
monitor_width = infoObject.current_w
monitor_height = infoObject.current_h

# Calculate the game window size (90% of screen size while maintaining aspect ratio)
SCREEN_SCALE = 0.9
target_width = int(monitor_width * SCREEN_SCALE)
target_height = int(monitor_height * SCREEN_SCALE)

# Load and scale the background
original_bg = pygame.image.load('Level Data/Level Image/LEVEL4.png')
bg_aspect_ratio = original_bg.get_width() / original_bg.get_height()

# Adjust window size to maintain aspect ratio
if target_width / target_height > bg_aspect_ratio:
    SCREEN_WIDTH = int(target_height * bg_aspect_ratio)
    SCREEN_HEIGHT = target_height
else:
    SCREEN_WIDTH = target_width
    SCREEN_HEIGHT = int(target_width / bg_aspect_ratio)

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Platformer')

# Define game variables
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.8
JUMP_SPEED = -15
MOVE_SPEED = 8
game_over = 0
score = 0

# Define colors
white = (255, 255, 255)
blue = (0, 0, 255)

# Load images
sun_img = pygame.image.load('img/sun.png')
bg_img = pygame.transform.scale(original_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
restart_img = pygame.image.load('img/restart_btn.png')

# Load sounds
pygame.mixer.music.load('img/music.wav')
pygame.mixer.music.play(-1, 0.0, 5000)
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2))
        
        for i in range(1, 5):
            img = pygame.image.load(f'img/dino{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, player_size)
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def update(self, game_over):
        dx = 0
        dy = 0
        walk_cooldown = 5

        if game_over == 0:
            key = pygame.key.get_pressed()
            
            # Jump only if we're on the ground (not in_air) and haven't jumped yet
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
            
            # Reset jumped state when space is released
            if not key[pygame.K_SPACE]:
                self.jumped = False

            if key[pygame.K_LEFT]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
            if key[pygame.K_RIGHT]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
            if not key[pygame.K_LEFT] and not key[pygame.K_RIGHT]:
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Add gravity
            self.vel_y += GRAVITY
            if self.vel_y > 10:
                self.vel_y = 10
            dy += self.vel_y

            # Assume we're in the air unless collision detection proves otherwise
            self.in_air = True

            # Check for collision
            dx, dy = world.check_collision(self, dx, dy)

            # Update player position
            self.rect.x += dx
            self.rect.y += dy

            # Keep player on screen
            if self.rect.left < 0:
                self.rect.left = 0
            if self.rect.right > SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH
                
            # Check if player has fallen off the map
            if self.rect.top > SCREEN_HEIGHT:
                game_over = -1
                game_over_fx.play()

        elif game_over == -1:
            self.image = self.dead_image
            if self.rect.y > 200:
                self.rect.y -= 5

        return game_over

def draw_grid(screen):
    # Create a new surface for the grid
    grid_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
    
    # Set the alpha value for translucency
    grid_surface.set_alpha(128)  # Adjust this value for more or less transparency

    # Draw vertical lines
    for x in range(0, SCREEN_WIDTH, TILE_SIZE):
        color = (255, 0, 0) if (x // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (x, 0), (x, SCREEN_HEIGHT), 1)

    # Draw horizontal lines
    for y in range(0, SCREEN_HEIGHT, TILE_SIZE):
        color = (255, 0, 0) if (y // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (0, y), (SCREEN_WIDTH, y), 1)

    # Blit the grid surface onto the main screen
    screen.blit(grid_surface, (0, 0))

# Add this with other game data at the top
ENEMY_DATA = [
    (17, 33.4, "horizontal", 17, 32),
    (36.2, 22, "horizontal", 36.2, 41.2),
    (50.5, 10.6, "horizontal", 50.5, 56),
    (18.5, 19, "horizontal", 18.5, 27.2)
]

class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(
            pygame.image.load('img/skeleton.png'),
            (int(TILE_SIZE * 0.8), int(TILE_SIZE * 0.8))
        )
        self.rect = self.image.get_rect()
        self.rect.x = x * TILE_SIZE
        self.rect.y = y * TILE_SIZE
        self.direction = direction
        self.speed = 2
        self.moving_right = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE

    def update(self):
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)
    
    def check_collision(self, player):
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class World:
    def __init__(self):
        
        self.collision_tiles = []
        
        # Platform data for level 1
        platform_data = [

            # 7th layer


            # 6th layer

            # 5th layer



            # 4th layer
            (33.2, 15.2, 7.8, 5.8),
            (31.3, 16.8, 2, 1),

            (6.8, 11.9, 5, 1),
            (10.2, 5.3, 3, 2.4),
            (15, 21.9, 1.2, 2),
            (13, 7, 1.8, 2.3),

            (19.9, 7, 1.2, 2.3),
            (21.4, 5.2, 1.3, 11),
            (22.6, 7, 1.8, 1),
            (11.9, 5.3, 1.1, 10.9),
            (13, 14.9, 8.4, 1.3),
            (16.4, 8.5, 1.7, 1),
            (14.9, 11.9, 5, 1),

            (24.8, 11.9, 3, 1),
            (46, 11.9, 5, 1),
            (44.4, 16.8, 6.6, 1),

            (51, 20, 8, 1),
            (38.1, 0, 1.3, 8),
            (39.3, 6.8, 6.3, 1.2),
            (39.3, 3.5, 1.7, 1),



            # 3rd layer
            (8.5, 21.8, 1.5, 1),
            (21.2, 21.8, 1.5, 1),
            (16.9, 29.5, 1.6, 1.5),
            (19.4, 29.5, 1.6, 1.5),
            (10, 23.4, 11.3, 1.3),
            (18.5, 23.4, 1, 7.6),
            (26.4, 20, 1.8, 1),
            (29.4, 20, 1.8, 1),
            (28.2, 15.2, 1.2, 9.3),
            (26.4, 23.4, 1.8, 1),
            (29.4, 23.4, 3.3, 1),

            (22, 13.8, 2, 2),
            (20, 22.4, 2.4, 2),
            

            # 2nd layer
            (6.9, 28.3, 4.3, 1),
            (1.7, 25, 6.3, 1),
            (0, 20, 9, 1),
            (0, 15.1, 5, 1),
            (11.9, 26.7, 1.3, 6),
            (13, 31.2, 1.3, 1.4),
            (11.9, 26.6, 6.7, 1),
            (23, 26.7, 5, 1),
            (33, 26.7, 3, 1),
            (39, 38.2, 5, 1),
            (29.8, 30, 3, 1),
            (56, 30, 3, 1),
            (41, 23.4, 5, 1),
            (52.9, 33.1, 2.9, 4),
            (38, 28.2, 5, 1),
            (46, 26.7, 6.7, 5.8),
            (44.7, 31.2, 1.5, 1.3),


            # Ground level
            (0, 33.3, 6.3, 6),
            (6.7, 34.9, 3, 6),
            (11.6, 34.9, 8.1, 6),
            (21.6, 34.9, 1.3, 6),
            (23, 33.2, 6.5, 0.9),
            (34.7, 33.3, 9.5, 6)
        ]
        
        for plat in platform_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            collision_rect = pygame.Rect(
                x + 2,
                y + 2,
                width - 4,
                height - 4
            )
            self.collision_tiles.append(CollisionTile(x, y, width, height))

    def check_collision(self, player, dx, dy):
        for tile in self.collision_tiles:
            # Check x collision
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            
            # Check y collision
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                # Check if below the ground i.e. jumping
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                # Check if above the ground i.e. falling
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False  # We've hit a platform, so we're not in the air
                
        return dx, dy

    def draw(self, screen):
        for tile in self.collision_tiles:
            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)

class Button():
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self):
        action = False
        pos = pygame.mouse.get_pos()

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font, text_col, x, y):
    img = font.render(text, True, text_col)
    screen.blit(img, (x, y))

# Initialize game objects
world = World()
player = Player(100, SCREEN_HEIGHT - 130)
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Add this line to create enemy group
moving_enemies = pygame.sprite.Group()
for enemy_data in ENEMY_DATA:
    x, y, direction, boundary_start, boundary_end = enemy_data
    enemy = MovingEnemy(x, y, direction, boundary_start, boundary_end)
    moving_enemies.add(enemy)

# Game loop
clock = pygame.time.Clock()
fps = 60
run = True

while run:
    clock.tick(fps)

    screen.blit(bg_img, (0, 0))

    if game_over == 0:
        game_over = player.update(game_over)
        
        # Add these lines for enemy updates and collision checks
        moving_enemies.update()
        for enemy in moving_enemies:
            if enemy.check_collision(player):
                game_over = -1
                game_over_fx.play()
                
    elif game_over == -1:
        draw_text('GAME OVER!', pygame.font.SysFont('Bauhaus 93', 70), blue, 
                 (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
        if restart_button.draw():
            player.rect.x = 100
            player.rect.y = SCREEN_HEIGHT - 130
            game_over = 0

    # Draw the world (collision boxes)
    world.draw(screen)
    draw_grid(screen)
    
    # Draw the player
    screen.blit(player.image, player.rect)
    
    # Add this line to draw enemies
    moving_enemies.draw(screen)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                run = False

    pygame.display.update()

================
File: Level Data/LEVEL5.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os

# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Get the screen resolution
infoObject = pygame.display.Info()
monitor_width = infoObject.current_w
monitor_height = infoObject.current_h

# Calculate the game window size (90% of screen size while maintaining aspect ratio)
SCREEN_SCALE = 0.9
target_width = int(monitor_width * SCREEN_SCALE)
target_height = int(monitor_height * SCREEN_SCALE)

# Load and scale the background
original_bg = pygame.image.load('Level Data/Level Image/LEVEL5.png')
bg_aspect_ratio = original_bg.get_width() / original_bg.get_height()

# Adjust window size to maintain aspect ratio
if target_width / target_height > bg_aspect_ratio:
    SCREEN_WIDTH = int(target_height * bg_aspect_ratio)
    SCREEN_HEIGHT = target_height
else:
    SCREEN_WIDTH = target_width
    SCREEN_HEIGHT = int(target_width / bg_aspect_ratio)

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Platformer')

# Define game variables
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.8
JUMP_SPEED = -15
MOVE_SPEED = 8
game_over = 0
score = 0

# Define colors
white = (255, 255, 255)
blue = (0, 0, 255)

# Load images
sun_img = pygame.image.load('img/sun.png')
bg_img = pygame.transform.scale(original_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
restart_img = pygame.image.load('img/restart_btn.png')

# Load sounds
pygame.mixer.music.load('img/music.wav')
pygame.mixer.music.play(-1, 0.0, 5000)
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2))
        
        for i in range(1, 5):
            img = pygame.image.load(f'img/dino{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, player_size)
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def update(self, game_over):
        dx = 0
        dy = 0
        walk_cooldown = 5

        if game_over == 0:
            key = pygame.key.get_pressed()
            
            # Jump only if we're on the ground (not in_air) and haven't jumped yet
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
            
            # Reset jumped state when space is released
            if not key[pygame.K_SPACE]:
                self.jumped = False

            if key[pygame.K_LEFT]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
            if key[pygame.K_RIGHT]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
            if not key[pygame.K_LEFT] and not key[pygame.K_RIGHT]:
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Add gravity
            self.vel_y += GRAVITY
            if self.vel_y > 10:
                self.vel_y = 10
            dy += self.vel_y

            # Assume we're in the air unless collision detection proves otherwise
            self.in_air = True

            # Check for collision
            dx, dy = world.check_collision(self, dx, dy)

            # Update player position
            self.rect.x += dx
            self.rect.y += dy

            # Keep player on screen
            if self.rect.left < 0:
                self.rect.left = 0
            if self.rect.right > SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH
                
            # Check if player has fallen off the map
            if self.rect.top > SCREEN_HEIGHT:
                game_over = -1
                game_over_fx.play()

        elif game_over == -1:
            self.image = self.dead_image
            if self.rect.y > 200:
                self.rect.y -= 5

        return game_over

def draw_grid(screen):
    # Create a new surface for the grid
    grid_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
    
    # Set the alpha value for translucency
    grid_surface.set_alpha(128)  # Adjust this value for more or less transparency

    # Draw vertical lines
    for x in range(0, SCREEN_WIDTH, TILE_SIZE):
        color = (255, 0, 0) if (x // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (x, 0), (x, SCREEN_HEIGHT), 1)

    # Draw horizontal lines
    for y in range(0, SCREEN_HEIGHT, TILE_SIZE):
        color = (255, 0, 0) if (y // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (0, y), (SCREEN_WIDTH, y), 1)

    # Blit the grid surface onto the main screen
    screen.blit(grid_surface, (0, 0))

class World:
    def __init__(self):
        self.collision_tiles = []
        
        # Platform data for level 1
        platform_data = [

            (15.4, 28, 2.2, 3),
            (22, 25.4, 2, 2),
            (25, 12, 2.4, 2.7),
            (28.4, 18.7, 2.4, 2.3),
            (31.8, 25.2,  2.3, 2),
            (26.9, 32, 2, 2),
            (40.2, 25.3, 2, 2),
            (41.7, 30, 2, 2),
            


            (0, 5.2, 9.5, 1),
            (0, 13.5, 11.4, 1),
            (0.2, 23.4, 1.1, 14),
            (3.5, 26.7, 1.4, 11),

            (6.8, 30, 3, 1),
            (6.7, 23.4, 3, 1),
            (10, 18.5, 4.6, 1),
            (10, 26.7, 8.2, 1.5),
            (26.3, 26.7, 5.3, 1.5),
            (31.1, 26.7, 3.3, 1.5),
            (19.6, 26.7, 5.3, 1.5),
            (36.1, 26.7, 3.7, 1.5),
            (41, 26.7, 5, 1.5),

            (15, 13.5, 3, 1), 
            (18, 8.5, 5, 1),
            (49.3, 30, 3.3, 1.1), 
            (46, 23.3, 6.5, 1),
            (44.4, 18.5, 4.8, 1),

            (16.5, 20, 5, 1.3),
            (23, 20, 1.7, 1.3),
            (26.4, 20, 4.8, 1.3),
            (33, 20, 3.3, 1.3),
            (38, 20, 4.7, 1.3),
            (41.2, 13.5, 3.2, 1),
            (29.7, 7, 6.5, 1.1),
            (22.9, 7, 5, 1.2),

            (19.8, 13.5, 5, 1.3),
            (26.2, 13.5, 1.7, 1.3),
            (29.6, 13.5, 1.7, 1.3),
            (34.4, 13.5, 5.2, 1.3),
            (36.4, 8.5, 4.5, 1.2),
            (42.9, 5.3, 6.5, 1),
            (51, 15, 8, 1),

            (15.1, 26.8, 1, 8),
            (43.1, 26.8, 1, 8),
            (21.7, 13.6, 1.2, 7.7),
            (36.5, 13.6, 1.2, 7.7),
            (18.4, 20, 1, 8.1), 
            (39.9, 20, 1, 8.1),
            (25, 7, 1, 7.8),
            (33.3, 7, 1, 7.8),

            (54.5, 26.8, 1.2, 11),
            (57.9, 23.4, 1.2, 14),
            (51.3, 3.2, 1.5, 6.3),
            (53, 8.3, 4.4, 1.3),
            (57.6, 3.3, 1.5, 6),
            (54.3, 5, 1.7, 1.3),

            (28.2, 12, 1.2, 2.5), 
            (31.5, 18.5, 1.3, 2.5),
            (25, 25, 1, 3),
            (34.9, 31.7, 1, 3),
            (17.7, 31.5, 1.8, 1),



            (9.9, 33.2, 5, 1.3),
            (19.4, 33.2, 7.3, 1.3),
            (29.4, 33.2, 5.4, 1.3),
            (36, 33.2, 5.5, 1.3),
            (44, 33.2, 5.3, 1.3)
        ]
        
        for plat in platform_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            collision_rect = pygame.Rect(
                x + 2,
                y + 2,
                width - 4,
                height - 4
            )
            self.collision_tiles.append(CollisionTile(x, y, width, height))

    def check_collision(self, player, dx, dy):
        for tile in self.collision_tiles:
            # Check x collision
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            
            # Check y collision
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                # Check if below the ground i.e. jumping
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                # Check if above the ground i.e. falling
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False  # We've hit a platform, so we're not in the air
                
        return dx, dy

    def draw(self, screen):
        for tile in self.collision_tiles:
            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)

# Add this with other game data at the top
ENEMY_DATA = [
            


            (0, 4.2, "horizontal", 0, 9.5),
            (0, 12.5, "horizontal", 0, 11.4),

            (10, 25.7, "horizontal", 10, 18.2),

            (41, 25.7, "horizontal", 41, 45),

            (16.5, 19, "horizontal", 16.5, 22.3),
            
            (38, 19, "horizontal", 38, 42),

            (19.8, 12.5, "horizontal", 19.8, 24),

            (34.4, 12.5, "horizontal", 34.4, 39.7),
            (42.9, 4.3, "horizontal", 42.9, 48.9),
            (51, 14, "horizontal", 51, 59),

            (44, 32.2, "horizontal", 44, 49),
            (10, 32.2, "horizontal", 10, 14)
]

class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(
            pygame.image.load('img/skeleton.png'),
            (int(TILE_SIZE * 0.8), int(TILE_SIZE * 0.8))
        )
        self.rect = self.image.get_rect()
        self.rect.x = x * TILE_SIZE
        self.rect.y = y * TILE_SIZE
        self.direction = direction
        self.speed = 2
        self.moving_right = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE

    def update(self):
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)
    
    def check_collision(self, player):
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button():
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self):
        action = False
        pos = pygame.mouse.get_pos()

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font, text_col, x, y):
    img = font.render(text, True, text_col)
    screen.blit(img, (x, y))

# Initialize game objects
world = World()
player = Player(100, SCREEN_HEIGHT - 130)
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Add this line to create enemy group
moving_enemies = pygame.sprite.Group()
for enemy_data in ENEMY_DATA:
    x, y, direction, boundary_start, boundary_end = enemy_data
    enemy = MovingEnemy(x, y, direction, boundary_start, boundary_end)
    moving_enemies.add(enemy)

# Game loop
clock = pygame.time.Clock()
fps = 60
run = True

while run:
    clock.tick(fps)

    screen.blit(bg_img, (0, 0))

    if game_over == 0:
        game_over = player.update(game_over)
        
        # Add these lines for enemy updates and collision checks
        moving_enemies.update()
        for enemy in moving_enemies:
            if enemy.check_collision(player):
                game_over = -1
                game_over_fx.play()
                
    elif game_over == -1:
        draw_text('GAME OVER!', pygame.font.SysFont('Bauhaus 93', 70), blue, 
                 (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
        if restart_button.draw():
            player.rect.x = 100
            player.rect.y = SCREEN_HEIGHT - 130
            game_over = 0

    # Draw the world (collision boxes)
    world.draw(screen)
    draw_grid(screen)
    
    # Draw the player
    screen.blit(player.image, player.rect)
    
    # Add this line to draw enemies
    moving_enemies.draw(screen)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                run = False

    pygame.display.update()

================
File: Level Data/LEVEL1.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os

# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Get the screen resolution
infoObject = pygame.display.Info()
monitor_width = infoObject.current_w
monitor_height = infoObject.current_h

# Calculate the game window size (90% of screen size while maintaining aspect ratio)
SCREEN_SCALE = 0.9
target_width = int(monitor_width * SCREEN_SCALE)
target_height = int(monitor_height * SCREEN_SCALE)

# Load and scale the background
original_bg = pygame.image.load('Level Data/Level Image/LEVEL1.png')
bg_aspect_ratio = original_bg.get_width() / original_bg.get_height()

# Adjust window size to maintain aspect ratio
if target_width / target_height > bg_aspect_ratio:
    SCREEN_WIDTH = int(target_height * bg_aspect_ratio)
    SCREEN_HEIGHT = target_height
else:
    SCREEN_WIDTH = target_width
    SCREEN_HEIGHT = int(target_width / bg_aspect_ratio)

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Platformer')

# Define game variables
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.8
JUMP_SPEED = -15
MOVE_SPEED = 8
game_over = 0
score = 0
win = False

# Define colors
white = (255, 255, 255)
blue = (0, 0, 255)

# Load images
sun_img = pygame.image.load('img/sun.png')
bg_img = pygame.transform.scale(original_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
restart_img = pygame.image.load('img/restart_btn.png')
door_img = pygame.image.load('img/exit.png')
door_img = pygame.transform.scale(door_img, (int(TILE_SIZE * 1.5), int(TILE_SIZE * 2)))

# Load sounds
pygame.mixer.music.load('img/music.wav')
pygame.mixer.music.play(-1, 0.0, 5000)
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Door(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = door_img
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2))
        
        for i in range(1, 5):
            img = pygame.image.load(f'img/dino{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, player_size)
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def update(self, game_over, win, door):
        dx = 0
        dy = 0
        walk_cooldown = 5

        if game_over == 0 and not win:
            key = pygame.key.get_pressed()
            
            # Jump only if we're on the ground (not in_air) and haven't jumped yet
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
            
            # Reset jumped state when space is released
            if not key[pygame.K_SPACE]:
                self.jumped = False

            if key[pygame.K_LEFT]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
            if key[pygame.K_RIGHT]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
            if not key[pygame.K_LEFT] and not key[pygame.K_RIGHT]:
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Add gravity
            self.vel_y += GRAVITY
            if self.vel_y > 10:
                self.vel_y = 10
            dy += self.vel_y

            # Assume we're in the air unless collision detection proves otherwise
            self.in_air = True

            # Check for collision
            dx, dy = world.check_collision(self, dx, dy)

            # Check for collision with the door
            if self.rect.colliderect(door.rect):
                win = True

            # Update player position
            self.rect.x += dx
            self.rect.y += dy

            # Keep player on screen
            if self.rect.left < 0:
                self.rect.left = 0
            if self.rect.right > SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH
                
            # Check if player has fallen off the map
            if self.rect.top > SCREEN_HEIGHT:
                game_over = -1
                game_over_fx.play()

        elif game_over == -1:
            self.image = self.dead_image
            if self.rect.y > 200:
                self.rect.y -= 5

        return game_over, win

def draw_grid(screen):
    # Create a new surface for the grid
    grid_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
    
    # Set the alpha value for translucency
    grid_surface.set_alpha(128)  # Adjust this value for more or less transparency

    # Draw vertical lines
    for x in range(0, SCREEN_WIDTH, TILE_SIZE):
        color = (255, 0, 0) if (x // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (x, 0), (x, SCREEN_HEIGHT), 1)

    # Draw horizontal lines
    for y in range(0, SCREEN_HEIGHT, TILE_SIZE):
        color = (255, 0, 0) if (y // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (0, y), (SCREEN_WIDTH, y), 1)

    # Blit the grid surface onto the main screen
    screen.blit(grid_surface, (0, 0))

class World:
    def __init__(self):
        self.collision_tiles = []
        
        # Platform data for level 1
        platform_data = [
            # 5th layer
            (23.1, 8.4, 4.8, 1.4),
            (44.5, 8.4, 4.8, 1.4),
            (15, 5.1, 6.2, 3),
            (0, 6.8, 9.8, 1.3),

            # 4th layer
            (28.1, 11.7, 6.4, 3),
            (51.2, 11.7, 6.3, 3),

            # 3rd layer
            (24.8, 15.5, 1.4, 1.7),
            (36.3, 16.6, 4.8, 1.3),
            (44.5, 16.6, 4.8, 1.3),

            # 2nd layer
            (51.1, 21.5, 6.4, 3),
            (36.3, 23.2, 6.4, 1),
            (18.3, 19.9, 9.6, 3),
            (31.3, 19.9, 3.3, 1.4),

            # Ground level
            (44.6, 26.4, 6.4, 3),
            (33, 29.7, 9.7, 3),
            (16.6, 28.1, 4.8, 1.4),
            (16.6, 34.7, 16, 12),

            # Ground Pillars
            (11.7, 23.2, 3.1, 12),
            (6.7, 26.4, 3.1, 9),
            (1.7, 29.8, 3.1, 6)
        ]
        
        for plat in platform_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            collision_rect = pygame.Rect(
                x + 2,
                y + 2,
                width - 4,
                height - 4
            )
            self.collision_tiles.append(CollisionTile(x, y, width, height))

    def check_collision(self, player, dx, dy):
        for tile in self.collision_tiles:
            # Check x collision
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            
            # Check y collision
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                # Check if below the ground i.e. jumping
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                # Check if above the ground i.e. falling
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False  # We've hit a platform, so we're not in the air
                
        return dx, dy

    def draw(self, screen):
        for tile in self.collision_tiles:
            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)

# Add this with other game data at the top
ENEMY_DATA = [
    (17, 33.4, "horizontal", 17, 32),
    (36.2, 22, "horizontal", 36.2, 41.2),
    (50.5, 10.6, "horizontal", 50.5, 56),
    (18.5, 19, "horizontal", 18.5, 27.2)
]

class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(
            pygame.image.load('img/skeleton.png'),
            (int(TILE_SIZE * 0.8), int(TILE_SIZE * 0.8))
        )
        self.rect = self.image.get_rect()
        self.rect.x = x * TILE_SIZE
        self.rect.y = y * TILE_SIZE
        self.direction = direction
        self.speed = 2
        self.moving_right = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE

    def update(self):
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)
    
    def check_collision(self, player):
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button():
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self):
        action = False
        pos = pygame.mouse.get_pos()

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font, text_col, x, y):
    img = font.render(text, True, text_col)
    screen.blit(img, (x, y))

# Initialize game objects
world = World()
player = Player(100, SCREEN_HEIGHT - 130)
door = Door(SCREEN_WIDTH - 100, SCREEN_HEIGHT - 200)
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Game loop
clock = pygame.time.Clock()
fps = 60
run = True

while run:
    clock.tick(fps)

    screen.blit(bg_img, (0, 0))

    if game_over == 0 and not win:
        game_over, win = player.update(game_over, win, door)
    elif game_over == -1:
        draw_text('GAME OVER!', pygame.font.SysFont('Bauhaus 93', 70), blue, 
                 (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
        if restart_button.draw():
            player.rect.x = 100
            player.rect.y = SCREEN_HEIGHT - 130
            game_over = 0
            win = False
    elif win:
        draw_text('You Win!', pygame.font.SysFont('Bauhaus 93', 70), blue, 
                 (SCREEN_WIDTH // 2) - 150, SCREEN_HEIGHT // 2)
        if restart_button.draw():
            player.rect.x = 100
            player.rect.y = SCREEN_HEIGHT - 130
            game_over = 0
            win = False

    # Draw the world (collision boxes)
    world.draw(screen)
    draw_grid(screen)
    
    # Draw the player
    screen.blit(player.image, player.rect)
    
    # Draw the door
    screen.blit(door.image, door.rect)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                run = False

    pygame.display.update()

pygame.quit()

================
File: Level Data/LEVEL2.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os

# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Get the screen resolution
infoObject = pygame.display.Info()
monitor_width = infoObject.current_w
monitor_height = infoObject.current_h

# Calculate the game window size (90% of screen size while maintaining aspect ratio)
SCREEN_SCALE = 0.9
target_width = int(monitor_width * SCREEN_SCALE)
target_height = int(monitor_height * SCREEN_SCALE)

# Load and scale the background
original_bg = pygame.image.load('Level Data/Level Image/LEVEL2.png')


bg_aspect_ratio = original_bg.get_width() / original_bg.get_height()

# Adjust window size to maintain aspect ratio
if target_width / target_height > bg_aspect_ratio:
    SCREEN_WIDTH = int(target_height * bg_aspect_ratio)
    SCREEN_HEIGHT = target_height
else:
    SCREEN_WIDTH = target_width
    SCREEN_HEIGHT = int(target_width / bg_aspect_ratio)

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Platformer')

# Define game variables
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.8
JUMP_SPEED = -15
MOVE_SPEED = 8
game_over = 0
score = 0

# Define colors
white = (255, 255, 255)
blue = (0, 0, 255)

# Load images
sun_img = pygame.image.load('img/sun.png')
bg_img = pygame.transform.scale(original_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
restart_img = pygame.image.load('img/restart_btn.png')

# Load sounds
pygame.mixer.music.load('img/music.wav')
pygame.mixer.music.play(-1, 0.0, 5000)
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2))
        
        for i in range(1, 5):
            img = pygame.image.load(f'img/dino{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, player_size)
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def update(self, game_over):
        dx = 0
        dy = 0
        walk_cooldown = 5

        if game_over == 0:
            key = pygame.key.get_pressed()
            
            # Jump only if we're on the ground (not in_air) and haven't jumped yet
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
            
            # Reset jumped state when space is released
            if not key[pygame.K_SPACE]:
                self.jumped = False

            if key[pygame.K_LEFT]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
            if key[pygame.K_RIGHT]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
            if not key[pygame.K_LEFT] and not key[pygame.K_RIGHT]:
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Add gravity
            self.vel_y += GRAVITY
            if self.vel_y > 10:
                self.vel_y = 10
            dy += self.vel_y

            # Assume we're in the air unless collision detection proves otherwise
            self.in_air = True

            # Check for collision
            dx, dy = world.check_collision(self, dx, dy)

            # Update player position
            self.rect.x += dx
            self.rect.y += dy

            # Keep player on screen
            if self.rect.left < 0:
                self.rect.left = 0
            if self.rect.right > SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH
                
            # Check if player has fallen off the map
            if self.rect.top > SCREEN_HEIGHT:
                game_over = -1
                game_over_fx.play()

        elif game_over == -1:
            self.image = self.dead_image
            if self.rect.y > 200:
                self.rect.y -= 5

        return game_over

def draw_grid(screen):
    # Create a new surface for the grid
    grid_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
    
    # Set the alpha value for translucency
    grid_surface.set_alpha(128)  # Adjust this value for more or less transparency

    # Draw vertical lines
    for x in range(0, SCREEN_WIDTH, TILE_SIZE):
        color = (255, 0, 0) if (x // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (x, 0), (x, SCREEN_HEIGHT), 1)

    # Draw horizontal lines
    for y in range(0, SCREEN_HEIGHT, TILE_SIZE):
        color = (255, 0, 0) if (y // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (0, y), (SCREEN_WIDTH, y), 1)

    # Blit the grid surface onto the main screen
    screen.blit(grid_surface, (0, 0))

class World:
    def __init__(self):
        self.collision_tiles = []
        
        # Platform data for level 1
        platform_data = [

            # 7th layer
            (23.2, 3.6, 3, 1),
            (13.5, 2, 7.6, 4),
            (10.1, 3.7, 3, 1),
            (0.3, 3.7, 4.6, 1),
            (5.2, 5.3, 1.3, 1),

            # 6th layer
            (51.3, 10.2, 7.5, 5.7),
            (26.4, 10.2, 4.8, 1.3),
            (5.2, 8.6, 4.6, 1),

            # 5th layer
            (43, 11.9, 6.3, 1),
            (11.8, 13.5, 4.6, 1),
            (0.2, 13.5, 4.6, 1),

            # 4th layer
            (31.7, 18.1, 1.8, 1.3),
            (42.3, 18.1, 1.8, 1.3),
            (33.3, 15.2, 9.2, 4),
            (0, 18.4, 9.5, 2.5),

            # 3rd layer
            (47.9, 20, 4.7, 1),
            (29.85, 20, 1.3, 1),
            (13.6, 21.7, 6, 1),
            (9.9, 20.1, 1.4, 1),

            # 2nd layer
            (48, 26.7, 6.2, 1),
            (41.4, 23.4, 4.6, 1),
            (26.7, 23.4, 7.6, 2.5),
            (7, 25, 14, 5),

            # Ground level
            (0.5, 28.4, 6.6, 8.0),
            (21, 28.4, 6.7, 8.0),
            (43.2, 31.7, 27, 5.0),

            # Ground Pillars
            (39.8, 31.7, 1.2, 3),
            (34.8, 31.7, 1.2, 3),
            (29.9, 31.7, 1.2, 3)
        ]
        
        for plat in platform_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            collision_rect = pygame.Rect(
                x + 2,
                y + 2,
                width - 4,
                height - 4
            )
            self.collision_tiles.append(CollisionTile(x, y, width, height))

    def check_collision(self, player, dx, dy):
        for tile in self.collision_tiles:
            # Check x collision
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            
            # Check y collision
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                # Check if below the ground i.e. jumping
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                # Check if above the ground i.e. falling
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False  # We've hit a platform, so we're not in the air
                
        return dx, dy

    def draw(self, screen):
        for tile in self.collision_tiles:
            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)

# Add this with other game data at the top
ENEMY_DATA = [
        (8.5, 24, "horizontal", 8.5, 20),
        (0.2, 17.2, "horizontal", 0.2, 8.7),
        (44.5, 30.5, "horizontal", 44, 58.5),
        (35, 14, "horizontal", 35, 41),
        (52.3, 9.1, "horizontal", 52.3, 58.5),
]

class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(
            pygame.image.load('img/skeleton.png'),
            (int(TILE_SIZE * 0.8), int(TILE_SIZE * 0.8))
        )
        self.rect = self.image.get_rect()
        self.rect.x = x * TILE_SIZE
        self.rect.y = y * TILE_SIZE
        self.direction = direction
        self.speed = 2
        self.moving_right = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE

    def update(self):
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)
    
    def check_collision(self, player):
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button():
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self):
        action = False
        pos = pygame.mouse.get_pos()

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font, text_col, x, y):
    img = font.render(text, True, text_col)
    screen.blit(img, (x, y))

# Initialize game objects
world = World()
player = Player(100, SCREEN_HEIGHT - 130)
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Add this line to create enemy group
moving_enemies = pygame.sprite.Group()
for enemy_data in ENEMY_DATA:
    x, y, direction, boundary_start, boundary_end = enemy_data
    enemy = MovingEnemy(x, y, direction, boundary_start, boundary_end)
    moving_enemies.add(enemy)

# Game loop
clock = pygame.time.Clock()
fps = 60
run = True

while run:
    clock.tick(fps)

    screen.blit(bg_img, (0, 0))

    if game_over == 0:
        game_over = player.update(game_over)
        
        # Add these lines for enemy updates and collision checks
        moving_enemies.update()
        for enemy in moving_enemies:
            if enemy.check_collision(player):
                game_over = -1
                game_over_fx.play()
                
    elif game_over == -1:
        draw_text('GAME OVER!', pygame.font.SysFont('Bauhaus 93', 70), blue, 
                 (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
        if restart_button.draw():
            player.rect.x = 100
            player.rect.y = SCREEN_HEIGHT - 130
            game_over = 0

    # Draw the world (collision boxes)
    world.draw(screen)
    draw_grid(screen)
    
    # Draw the player
    screen.blit(player.image, player.rect)
    
    # Add this line to draw enemies
    moving_enemies.draw(screen)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                run = False

    pygame.display.update()

================
File: Level Data/LEVEL3.py
================
import pygame
from pygame.locals import *
from pygame import mixer
import os

# Initialize Pygame
pygame.mixer.pre_init(44100, -16, 2, 512)
mixer.init()
pygame.init()

# Get the screen resolution
infoObject = pygame.display.Info()
monitor_width = infoObject.current_w
monitor_height = infoObject.current_h

# Calculate the game window size (90% of screen size while maintaining aspect ratio)
SCREEN_SCALE = 0.9
target_width = int(monitor_width * SCREEN_SCALE)
target_height = int(monitor_height * SCREEN_SCALE)

# Load and scale the background
original_bg = pygame.image.load('Level Data/Level Image/LEVEL3.png')
bg_aspect_ratio = original_bg.get_width() / original_bg.get_height()

# Adjust window size to maintain aspect ratio
if target_width / target_height > bg_aspect_ratio:
    SCREEN_WIDTH = int(target_height * bg_aspect_ratio)
    SCREEN_HEIGHT = target_height
else:
    SCREEN_WIDTH = target_width
    SCREEN_HEIGHT = int(target_width / bg_aspect_ratio)

# Center the window on the screen
os.environ['SDL_VIDEO_CENTERED'] = '1'

# Set up the display
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption('Platformer')

# Define game variables
TILE_SIZE = SCREEN_HEIGHT // 36
GRAVITY = 0.8
JUMP_SPEED = -15
MOVE_SPEED = 8
game_over = 0
score = 0

# Define colors
white = (255, 255, 255)
blue = (0, 0, 255)

# Load images
sun_img = pygame.image.load('img/sun.png')
bg_img = pygame.transform.scale(original_bg, (SCREEN_WIDTH, SCREEN_HEIGHT))
restart_img = pygame.image.load('img/restart_btn.png')

# Load sounds
pygame.mixer.music.load('img/music.wav')
pygame.mixer.music.play(-1, 0.0, 5000)
jump_fx = pygame.mixer.Sound('img/jump.wav')
jump_fx.set_volume(0.5)
game_over_fx = pygame.mixer.Sound('img/game_over.wav')
game_over_fx.set_volume(0.5)

class CollisionTile:
    def __init__(self, x, y, width, height):
        self.rect = pygame.Rect(x, y, width, height)

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.animations_right = []
        self.animations_left = []
        player_size = (int(TILE_SIZE * 1.2), int(TILE_SIZE * 1.2))
        
        for i in range(1, 5):
            img = pygame.image.load(f'img/dino{i}.png')
            img = pygame.transform.scale(img, player_size)
            self.animations_right.append(img)
            self.animations_left.append(pygame.transform.flip(img, True, False))
        
        self.dead_image = pygame.image.load('img/Skeleton.png')
        self.dead_image = pygame.transform.scale(self.dead_image, player_size)
        
        self.index = 0
        self.counter = 0
        self.image = self.animations_right[self.index]
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.width = self.rect.width
        self.height = self.rect.height
        self.vel_y = 0
        self.jumped = False
        self.direction = 1
        self.in_air = True

    def update(self, game_over):
        dx = 0
        dy = 0
        walk_cooldown = 5

        if game_over == 0:
            key = pygame.key.get_pressed()
            
            # Jump only if we're on the ground (not in_air) and haven't jumped yet
            if key[pygame.K_SPACE] and not self.jumped and not self.in_air:
                jump_fx.play()
                self.vel_y = JUMP_SPEED
                self.jumped = True
                self.in_air = True
            
            # Reset jumped state when space is released
            if not key[pygame.K_SPACE]:
                self.jumped = False

            if key[pygame.K_LEFT]:
                dx -= MOVE_SPEED
                self.counter += 1
                self.direction = -1
            if key[pygame.K_RIGHT]:
                dx += MOVE_SPEED
                self.counter += 1
                self.direction = 1
            if not key[pygame.K_LEFT] and not key[pygame.K_RIGHT]:
                self.counter = 0
                self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Handle animation
            if self.counter > walk_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.animations_right):
                    self.index = 0
                if self.direction == 1:
                    self.image = self.animations_right[self.index]
                else:
                    self.image = self.animations_left[self.index]

            # Add gravity
            self.vel_y += GRAVITY
            if self.vel_y > 10:
                self.vel_y = 10
            dy += self.vel_y

            # Assume we're in the air unless collision detection proves otherwise
            self.in_air = True

            # Check for collision
            dx, dy = world.check_collision(self, dx, dy)

            # Update player position
            self.rect.x += dx
            self.rect.y += dy

            # Keep player on screen
            if self.rect.left < 0:
                self.rect.left = 0
            if self.rect.right > SCREEN_WIDTH:
                self.rect.right = SCREEN_WIDTH
                
            # Check if player has fallen off the map
            if self.rect.top > SCREEN_HEIGHT:
                game_over = -1
                game_over_fx.play()

        elif game_over == -1:
            self.image = self.dead_image
            if self.rect.y > 200:
                self.rect.y -= 5

        return game_over

def draw_grid(screen):
    # Create a new surface for the grid
    grid_surface = pygame.Surface((SCREEN_WIDTH, SCREEN_HEIGHT), pygame.SRCALPHA)
    
    # Set the alpha value for translucency
    grid_surface.set_alpha(128)  # Adjust this value for more or less transparency

    # Draw vertical lines
    for x in range(0, SCREEN_WIDTH, TILE_SIZE):
        color = (255, 0, 0) if (x // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (x, 0), (x, SCREEN_HEIGHT), 1)

    # Draw horizontal lines
    for y in range(0, SCREEN_HEIGHT, TILE_SIZE):
        color = (255, 0, 0) if (y // TILE_SIZE) % 5 == 0 else (200, 200, 200)  # Red for every 5 tiles
        pygame.draw.line(grid_surface, color, (0, y), (SCREEN_WIDTH, y), 1)

    # Blit the grid surface onto the main screen
    screen.blit(grid_surface, (0, 0))

class World:
    def __init__(self):
        self.collision_tiles = []
        
        # Platform data for level 1
        platform_data = [

            # 7th layer


            # 6th layer
            (3.5, 7, 6.2, 1),
            (0.3, 2, 4.3, 2.5),
            (20, 8.5, 3, 1),
            (46.4, 8.5, 11.4, 1),
            (57.8, 0.4, 1.3, 9),
            (29.9, 3.7, 9.5, 1),
            (48, 3.7, 4.6, 1),
            (19.9, 1.9, 3, 1.4),
            

            # 5th layer
            (26.4, 11.5, 2.8, 1.3),
            (25, 8.6, 1.4, 4.3),
            (11.5, 10.2, 5, 1),


            # 4th layer
            (18.1, 10.3, 1.7, 5.8),
            (7.1, 14.8, 10.9, 1.3),
            (31.5, 13.6, 3, 0.8),
            (36.5, 16.8, 7.8, 0.8),

            # 3rd layer
            (51.3, 20.1, 2.8, 5.7),
            (44.8, 20.1, 2.8, 5.7),
            (47.6, 24.8, 3.8, 1),
            (33.2, 23.4, 7.8, 1),
            (9.9, 25, 11.3, 1),
            (1.4, 20.1, 6.5, 5.8),
            (23.4, 18.5, 7.5, 4.2),
            (11.8, 21.8, 3, 0.8),
            (1.7, 13.6, 1.6, 1),
            (37.9, 11.9, 1.6, 1),
            (43, 10.3, 1.2, 2.7),
            (47.7, 13.5, 3.2, 1.3),
            (16.7, 13.5, 1.3, 1.3),
            

            # 2nd layer
            (34.8, 30, 2.9, 1),
            (26.7, 26.7, 5.9, 1),
            (31.3, 26.7, 1.4, 5.8),
            (23.6, 31.3, 7.7, 1.2),
            (10, 28.4, 4.8, 1),
            (21.6, 21.9, 1.4, 2.3),
            (19.8, 18.5, 1.6, 1),
            (8.3, 20, 1.6, 1),
            (0.1, 18.4, 1.6, 1),


            # Ground level
            (0.3, 35, 19, 6),
            (19.5, 35, 3.7, 6),
            (23.4, 35, 20.6, 6),
            (44.2, 35, 2.2, 6),
            (46.6, 35, 12.6, 6)
        ]
        
        for plat in platform_data:
            x = plat[0] * TILE_SIZE
            y = plat[1] * TILE_SIZE
            width = plat[2] * TILE_SIZE
            height = int(plat[3] * TILE_SIZE)
            collision_rect = pygame.Rect(
                x + 2,
                y + 2,
                width - 4,
                height - 4
            )
            self.collision_tiles.append(CollisionTile(x, y, width, height))


    def check_collision(self, player, dx, dy):
        for tile in self.collision_tiles:
            # Check x collision
            if tile.rect.colliderect(player.rect.x + dx, player.rect.y, player.width, player.height):
                dx = 0
            
            # Check y collision
            if tile.rect.colliderect(player.rect.x, player.rect.y + dy, player.width, player.height):
                # Check if below the ground i.e. jumping
                if player.vel_y < 0:
                    dy = tile.rect.bottom - player.rect.top
                    player.vel_y = 0
                # Check if above the ground i.e. falling
                elif player.vel_y >= 0:
                    dy = tile.rect.top - player.rect.bottom
                    player.vel_y = 0
                    player.in_air = False  # We've hit a platform, so we're not in the air
                
        return dx, dy

    def draw(self, screen):
        for tile in self.collision_tiles:
            pygame.draw.rect(screen, (255, 0, 0), tile.rect, 1)

# Add this with other game data at the top
ENEMY_DATA = [
        (10.5, 24, "horizontal", 10.5, 20.5),
        (24, 34, "horizontal", 24, 43),
        (7, 13.6, "horizontal", 7, 15.5),
        (30, 2.6, "horizontal", 30, 38.5),
        (48, 7.5, "horizontal", 48, 57),
        (37.5, 15.8, "horizontal", 37.5, 43.5),
]

class MovingEnemy(pygame.sprite.Sprite):
    def __init__(self, x, y, direction, boundary_start, boundary_end):
        super().__init__()
        self.image = pygame.transform.scale(
            pygame.image.load('img/skeleton.png'),
            (int(TILE_SIZE * 0.8), int(TILE_SIZE * 0.8))
        )
        self.rect = self.image.get_rect()
        self.rect.x = x * TILE_SIZE
        self.rect.y = y * TILE_SIZE
        self.direction = direction
        self.speed = 2
        self.moving_right = True
        self.boundary_start = boundary_start * TILE_SIZE
        self.boundary_end = boundary_end * TILE_SIZE

    def update(self):
        if self.direction == "horizontal":
            if self.moving_right:
                self.rect.x += self.speed
                if self.rect.x >= self.boundary_end:
                    self.moving_right = False
                    self.image = pygame.transform.flip(self.image, True, False)
            else:
                self.rect.x -= self.speed
                if self.rect.x <= self.boundary_start:
                    self.moving_right = True
                    self.image = pygame.transform.flip(self.image, True, False)
    
    def check_collision(self, player):
        collision_margin = 4
        collision_rect = pygame.Rect(
            self.rect.x + collision_margin,
            self.rect.y + collision_margin,
            self.rect.width - (collision_margin * 2),
            self.rect.height - (collision_margin * 2)
        )
        return collision_rect.colliderect(player.rect)

class Button():
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.x = x
        self.rect.y = y
        self.clicked = False

    def draw(self):
        action = False
        pos = pygame.mouse.get_pos()

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
                action = True
                self.clicked = True

        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False

        screen.blit(self.image, self.rect)
        return action

def draw_text(text, font, text_col, x, y):
    img = font.render(text, True, text_col)
    screen.blit(img, (x, y))

# Initialize game objects
world = World()
player = Player(100, SCREEN_HEIGHT - 130)
restart_button = Button(SCREEN_WIDTH // 2 - 50, SCREEN_HEIGHT // 2 + 100, restart_img)

# Add this line to create enemy group
moving_enemies = pygame.sprite.Group()
for enemy_data in ENEMY_DATA:
    x, y, direction, boundary_start, boundary_end = enemy_data
    enemy = MovingEnemy(x, y, direction, boundary_start, boundary_end)
    moving_enemies.add(enemy)

# Game loop
clock = pygame.time.Clock()
fps = 60
run = True

while run:
    clock.tick(fps)

    screen.blit(bg_img, (0, 0))

    if game_over == 0:
        game_over = player.update(game_over)
        
        # Add these lines for enemy updates and collision checks
        moving_enemies.update()
        for enemy in moving_enemies:
            if enemy.check_collision(player):
                game_over = -1
                game_over_fx.play()
                
    elif game_over == -1:
        draw_text('GAME OVER!', pygame.font.SysFont('Bauhaus 93', 70), blue, 
                 (SCREEN_WIDTH // 2) - 200, SCREEN_HEIGHT // 2)
        if restart_button.draw():
            player.rect.x = 100
            player.rect.y = SCREEN_HEIGHT - 130
            game_over = 0

    # Draw the world (collision boxes)
    world.draw(screen)
    draw_grid(screen)
    
    # Draw the player
    screen.blit(player.image, player.rect)
    
    # Add this line to draw enemies
    moving_enemies.draw(screen)

    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False
        if event.type == pygame.KEYDOWN:
            if event.key == pygame.K_ESCAPE:
                run = False

    pygame.display.update()

================
File: modules/world.py
================
import pygame
import pickle

class World:
    def __init__(self, data):
        self.tile_list = data  # Store tiles here

    def draw(self, screen):
        for tile in self.tile_list:
            screen.blit(tile[0], tile[1])  # Ensure you have a list of tuples (image, position)

def reset_level(level, player, blobs, platforms, keys, lava, exits):
    player.reset(100, 850)
    blobs.empty()
    platforms.empty()
    keys.empty()
    lava.empty()
    exits.empty()

    with open(f'levels/level{level}_data', 'rb') as f:
        world_data = pickle.load(f)
    return World(world_data)

# In your main game loop
world = reset_level(current_level, player, blobs, platforms, keys, lava, exits)

while run:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            run = False

    screen.fill((0, 0, 0))
    world.draw(screen)  # Make sure to pass the screen here
    start_button.draw(screen)
    exit_button.draw(screen)

    pygame.display.update()

================
File: modules/utils.py
================
import pygame
import pickle

class World:
    def __init__(self, data):
        self.tile_list = []  # Store tiles here
        # Initialize the world data if needed
        # Example: self.tile_list = self.create_tiles(data)
    
    def draw(self, screen):
        for tile in self.tile_list:
            screen.blit(tile[0], tile[1])

def reset_level(level, player, blobs, platforms, keys, lava, exits):
    player.reset(100, 850)
    blobs.empty()
    platforms.empty()
    keys.empty()
    lava.empty()
    exits.empty()
    with open(f'levels/level{level}_data', 'rb') as f:
        world_data = pickle.load(f)
    return World(world_data)

class Button:
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect(topleft=(x, y))
        self.clicked = False  # Track if the button was clicked
    
    def draw(self, screen):
        action = False
        pos = pygame.mouse.get_pos()  # Get mouse position
        # Check if the mouse is hovering over the button
        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1 and not self.clicked:
                action = True  # Action triggered on click
                self.clicked = True  # Set clicked to True
        if pygame.mouse.get_pressed()[0] == 0:
            self.clicked = False  # Reset clicked on mouse release
        # Draw the button
        screen.blit(self.image, self.rect)
        return self.rect.collidepoint(pygame.mouse.get_pos()) and pygame.mouse.get_pressed()[0]  # Return action status

def draw_text(text, font, text_color, x, y, screen):
    """Renders text to the screen at the given coordinates."""
    img = font.render(text, True, text_color)
    screen.blit(img, (x, y))

================
File: modules/player.py
================
import pygame
from pygame import mixer

class Player(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.images_right = [pygame.image.load(f'img/dino{num}.png') for num in range(1, 5)]
        self.images_left = [pygame.transform.flip(img, True, False) for img in self.images_right]
        self.image = self.images_right[0]
        self.rect = self.image.get_rect(topleft=(x, y))
        self.vel_y, self.jumped, self.in_air = 0, False, True
        self.counter, self.index, self.direction = 0, 0, 1

    def update(self, game_over, blobs, lava, exits, platforms):
        # Handle movement, collisions, and game logic here (same as original)
        # Return game_over status
        pass

================
File: modules/entities.py
================
import pygame

class key(pygame.sprite.Sprite):
    def __init__(self, x, y):
        super().__init__()
        self.image = pygame.image.load('img/key.png')
        self.rect = self.image.get_rect(center=(x, y))

# Define other entities similarly (Enemy, Lava, Exit, etc.)
